# 100. Напишите регулярное выражение, которое найдёт всё содержимое тегов p.
#      Нужно найти теги, подходящие по следующим условиям:
#      В начале тега стоит:
#      <p
#      Тут может быть последовательность символов минимально возможной длины
#      >
#      Внутри тега последовательность из любых символов минимально возможной длины
#      В конце тега стоит </p>
#      На вход программе подаётся 1 строка с html-разметкой.
#      Выведите в консоль содержимое тегов p. Каждое совпадение на новой строке.

import re

pattern = r'<p.*?>(.*?)</p>'
match = re.findall(pattern, input())
print(*match, sep='\n')

# 101. Напишите программу, которая будет находить ссылки и разделять их на части: протокол, адрес, параметры, якорь. Протокол и адрес у ссылок есть всегда.
#      Нужно найти ссылки, подходящие по следующим условиям:
#      Протокол https или http
#      После протокола идёт ://
#      Домен состоит из символов a-z, .
#      Путь состоит из символов a-z, 0-9, -, _, /
#      Параметры начинаются с ? и состоят из a-z, =, &, 0-9
#      Якорь начинается с # и состоит из a-z
#      Протокол и адрес у ссылок есть всегда, остальных частей может не быть
#      Ссылка не может быть подпоследовательностью
#      На вход программе подаётся 1 строка текста.
#      Выведите в консоль ссылку, протокол, домен, параметры, якорь найденных совпадений в следующем виде:
#      Полная ссылка: https://example.com/test/42523/step/2?q=query&s=search#test
#      Протокол: https | Домен: example.com | Параметры: ?q=query&s=search | Якорь: #test
#      Если группа ничего не нашла, то вместо совпадения нужно вывести None.

import re

pattern = r'(?P<protocol>http[s]?)+:\/\/(?P<domen>[a-z.\d]*?)\/[a-z\/\d_-]*(?P<params>\?[^# ]*)?(?P<anchor>[#][a-z]*)?'
match = re.finditer(pattern, input())
for i in match:
    print(f"Полная ссылка: {i[0]}")
    print(f"Протокол: {i['protocol']} | Домен: {i['domen']} | Параметры: {i['params']} | Якорь: {i['anchor']}") 
    print()

# 103. Получите все названия html-тегов.
#      Нужно названия html-тегов. Большинство html-тегов выглядит так:
#      В начале тега стоит < или </
#      В середине название тега, оно состоит из латинских букв нижнего регистра и арабских цифр максимальной длины
#      После названия может идти последовательность из любых символов минимальной длины
#      В конце тега стоит >
#      На вход программе подаётся 1 строка.
#      Список с найденными названиями html-тегов.

import re

pattern = r'</*([a-z\d]+).*?>'
print(re.findall(pattern, input()))

# 104. Получите список кортежей с логином, паролем, и токеном.
#      Нужно найти логин, пароль, и токен:
#      Логин состоит из 0-9
#      Пароль состоит из a-z, A-Z, 0-9
#      Токен состоит из a-z, 0-9
#      Длина минимум 1 символ
#      На вход программе подаётся 1 строка.
#      Список кортежей с логином, паролем, токеном, если они найдены в тексте. Если их нет - пустой список.

import re

pattern = r'(\d{1,}):([A-z\d]*):([a-z\d]*)'
print(re.findall(pattern, input()))

# 105. Разделите строку по знакам математических операций, удалив мусор вокруг них, и оставив в выходных данных математическое выражение.
#      Нужно разделить строку по следующей последовательности:
#      В левой части нечисловая последовательность символов любой длины
#      В  середине стоит один из символов +:=*/-
#      В правой части нечисловая последовательность символов любой длины
#      На вход программе подаётся 1 строка.
#      Список с числами и математическими операциями.

import re

pattern = r'[а-яё\.]+'
print(re.split(pattern, input()))

# 106. Разделите строку по символам ? и &.
#      Нужно разделить строку по символвам ? и &, оставив эти символы в полученном списке.
#      На вход программе подаётся 1 строка.
#      Список, с частями исходной строки.

import re

pattern = r'([?&])' 
print(re.split(pattern, input()))