# 100. Напишите регулярное выражение, которое найдёт всё содержимое тегов p.
#      Нужно найти теги, подходящие по следующим условиям:
#      В начале тега стоит:
#      - <p
#      - Тут может быть последовательность символов минимально возможной длины
#      - >
#      - Внутри тега последовательность из любых символов минимально возможной длины
#      - В конце тега стоит </p>
#      На вход программе подаётся 1 строка с html-разметкой.
#      Выведите в консоль содержимое тегов p. Каждое совпадение на новой строке.

import re

pattern = r'<p.*?>(.*?)</p>'
match = re.findall(pattern, input())
print(*match, sep='\n')

# 101. Напишите программу, которая будет находить ссылки и разделять их на части: протокол, адрес, параметры, якорь. Протокол и адрес у ссылок есть всегда.
#      Нужно найти ссылки, подходящие по следующим условиям:
#      - Протокол https или http
#      - После протокола идёт ://
#      - Домен состоит из символов a-z, .
#      - Путь состоит из символов a-z, 0-9, -, _, /
#      - Параметры начинаются с ? и состоят из a-z, =, &, 0-9
#      - Якорь начинается с # и состоит из a-z
#      - Протокол и адрес у ссылок есть всегда, остальных частей может не быть
#      - Ссылка не может быть подпоследовательностью
#      На вход программе подаётся 1 строка текста.
#      Выведите в консоль ссылку, протокол, домен, параметры, якорь найденных совпадений в следующем виде:
#      - Полная ссылка: https://example.com/test/42523/step/2?q=query&s=search#test
#      - Протокол: https | Домен: example.com | Параметры: ?q=query&s=search | Якорь: #test
#      Если группа ничего не нашла, то вместо совпадения нужно вывести None.

import re

pattern = r'(?P<protocol>http[s]?)+:\/\/(?P<domen>[a-z.\d]*?)\/[a-z\/\d_-]*(?P<params>\?[^# ]*)?(?P<anchor>[#][a-z]*)?'
match = re.finditer(pattern, input())
for i in match:
    print(f"Полная ссылка: {i[0]}")
    print(f"Протокол: {i['protocol']} | Домен: {i['domen']} | Параметры: {i['params']} | Якорь: {i['anchor']}") 
    print()

# 103. Получите все названия html-тегов.
#      Нужно названия html-тегов. Большинство html-тегов выглядит так:
#      - В начале тега стоит < или </
#      - В середине название тега, оно состоит из латинских букв нижнего регистра и арабских цифр максимальной длины
#      - После названия может идти последовательность из любых символов минимальной длины
#      - В конце тега стоит >
#      На вход программе подаётся 1 строка.
#      Список с найденными названиями html-тегов.

import re

pattern = r'</*([a-z\d]+).*?>'
print(re.findall(pattern, input()))

# 104. Получите список кортежей с логином, паролем, и токеном.
#      Нужно найти логин, пароль, и токен:
#      - Логин состоит из 0-9
#      - Пароль состоит из a-z, A-Z, 0-9
#      - Токен состоит из a-z, 0-9
#      - Длина минимум 1 символ
#      На вход программе подаётся 1 строка.
#      Список кортежей с логином, паролем, токеном, если они найдены в тексте. Если их нет - пустой список.

import re

pattern = r'(\d{1,}):([A-z\d]*):([a-z\d]*)'
print(re.findall(pattern, input()))

# 105. Разделите строку по знакам математических операций, удалив мусор вокруг них, и оставив в выходных данных математическое выражение.
#      Нужно разделить строку по следующей последовательности:
#      - В левой части нечисловая последовательность символов любой длины
#      - В  середине стоит один из символов +:=*/-
#      - В правой части нечисловая последовательность символов любой длины
#      На вход программе подаётся 1 строка.
#      Список с числами и математическими операциями.

import re

pattern = r'\D*([+:=*/-])\D*'
print(re.split(pattern, input()))

# 106. Разделите строку по символам ? и &.
#      Нужно разделить строку по символвам ? и &, оставив эти символы в полученном списке.
#      На вход программе подаётся 1 строка.
#      Список, с частями исходной строки.

import re

pattern = r'([?&])' 
print(re.split(pattern, input()))

# 107. Замените два повторяющиеся слова на одно. Если слова одинаковые, но регистр разный - считаем что и слова разные.
#      Нужно заменить 2 повторяющиеся слова на одно:
#      - Слова состоят из кириллических букв
#      - Между ними стоит пробел
#      - Если у слов разный регистр - слова разные
#      На вход программе подаётся 1 строка.
#      Строка с удалёнными повторяющимися словами.

import re

print(re.sub(r'(?P<group>[а-яё]+)\s(?P=group)', r'\1', input()))

# 108. Замените **Жирный текст** на <strong>Жирный текст</strong>, и *Курсив* на <em>Курсив</em>.
#      Нужно найти следующие последовательности:
#      - Начинается и заканчивается с ** или *
#      - В середине последовательность любой длины из букв кириллического и латинского алфавитов обоих регистров, а также пробелов
#      - И заменить **text** на <strong>text</strong>, а *text* на <em>text</em>
#      На вход программе подаётся 1 строка.
#      Строка, в которой Markdown изменён на HTML.

import re

print(re.sub(r'\*(.*)\*', r'<em>\1</em>', re.sub(r'\*\*(.*)\*\*', r'<strong>\1</strong>', input())))

# 109. Найдите все прокси, и добавьте к ним в начало протокол http://.
#      Нужно найти следующие последовательности:
#      - Адрес состоит из любых числовых последовательностей, разделённых .
#      - В середине стоит :
#      - Порт является любой числовой последовательностью
#      и в начало к ним добавить протокол http://.
#      На вход программе подаётся 1 строка.
#      Строка, в которой у всех прокси стоит протокол.

import re

print(re.sub(r'(?P<g1>[\d.]+)(?P<g2>:)(?P<g3>[\d]+)', r'http://\1\2\3', input()))

# 110. Все даты в примерах - даты формата mm/dd/yyyy, замените их на dd/mm/yyyy.  Для разделителей используются символы . и /.
#      Нужно найти следующие последовательности:
#      - Дата типа mm/dd/yyyy
#      - mm, dd, yyyy - любые числовые последовательности длиной 2, 2, 4 соответственно
#      - Между ними стоят разделители . или /
#      и переставить mm с dd местами, чтобы получилась дата вида dd/mm/yyyy
#      На вход программе подаётся 1 строка.
#      Измените формат всех дат в тексте по условию задачи.

import re

print(re.sub(r'(?P<month>\d+)(?P<sep>/|\.)(?P<day>\d+)', r'\g<day>\g<sep>\g<month>', input()))

# 111. Замените егонный/еённый/ихний на его/её/их
#      Нужно найти следующие последовательности:
#      - Начинается с его/её/их или Его/Её/Их
#      - Потом идёт последовательность кириллических букв максимальной длины
#      - и убрать из них ненужную часть.
#      На вход программе подаётся 1 строка.
#      Строка, в которой ошибки в словах были исправлены.

import re

print(re.sub(r'(?P<word>(его|Его|её|Её|Их|их)+)([а-яё]+)*', r'\1', input()))

# 112. Напишите программу, которая находит в строке первую попавшуюся цену, и выводит её в следующем виде: Цена данного товара x. Если цены нет в тексте - ничего выводить не нужно.
#      Нужно найти первую цену в тексте:
#      - Любая числовая последовательность
#      - В конце стоит ₽$
#      - и подставить её в строку Цена данного товара x.
#      На вход программе подаётся 1 строка.
#      Строка, в соответствии с условием задачи, если найдена цена. Если цены нет - ничего не нужно выводить.

import re

match = re.search(r'(?P<price>\d+)(?P<currency>(₽|\$))', input())
if match:
    print(match.expand(r'Цена данного товара \1\2'))

# 113. Найдите все числа в тексте и возведите их в квадрат.
#      Нужно найти все числовые последовательности и заменить на их квадрат.
#      На вход программе подаётся 1 строка.
#      Строка с числами, возведёнными в квадрат.

import re

def square_numbers(text):
    return re.sub(r'\d+', lambda match: str(int(match.group(0)) ** 2), text)

text = input()
print(square_numbers(text))

# 114. Замените все слова, которые начинаются на букву А в любом регистре, на удалено(n), где n - длина удалённого слова.
#      Нужно найти все слова, которые начинаются на букву А или а и заменить их на удалено(n), где n - длина удалённого слова.
#      На вход программе подаётся 1 строка.
#      Строка с удалёнными словами.

import re

def func(m):
    return f'удалено({str(len(m[0]))})'

pattern = r'\b(?:[аА]\w*)\b'
text = input()

res_func = re.sub(pattern, func, text)
res_lambda = re.sub(pattern, lambda m: str(len(m[0])), text)

print(res_func)

# 115. Напишите программу, которая найдёт все am и pm в тексте и заменит их друг на друга.
#      Нужно заменить все am на pm, а pm на am.
#      На вход программе подаётся 1 строка.
#      Строка с am, заменённым на pm, и pm, заменённым на am.

import re

print(re.sub(r'(?P<am>am)|(?P<pm>pm)', lambda x: 'pm' if x[0]=='am' else 'am', input()))

# 116. Напишите программу, которая делит на 3 все числа, кратные 3.
#      Найти все числа в тексте, и проверить, кратно число 3 или нет:
#      - Если кратно, то заменить его на это же число, разделённое на 3
#      - Если нет - оставить его как есть
#      На вход программе подаётся 1 строка.
#      Строка с заменёнными числами.

import re

print(re.sub(r'\d+', lambda x: str(int(int(x.group(0)) / 3)) if int(x[0]) % 3 == 0 else str(int(x.group(0))), input()))