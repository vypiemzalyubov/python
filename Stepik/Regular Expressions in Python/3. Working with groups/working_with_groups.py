# 100. Напишите регулярное выражение, которое найдёт всё содержимое тегов p.
#      Нужно найти теги, подходящие по следующим условиям:
#      В начале тега стоит:
#      <p
#      Тут может быть последовательность символов минимально возможной длины
#      >
#      Внутри тега последовательность из любых символов минимально возможной длины
#      В конце тега стоит </p>
#      На вход программе подаётся 1 строка с html-разметкой.
#      Выведите в консоль содержимое тегов p. Каждое совпадение на новой строке.

import re

pattern = r'<p.*?>(.*?)</p>'
match = re.findall(pattern, input())
print(*match, sep='\n')

# 101. Напишите программу, которая будет находить ссылки и разделять их на части: протокол, адрес, параметры, якорь. Протокол и адрес у ссылок есть всегда.
#      Нужно найти ссылки, подходящие по следующим условиям:
#      Протокол https или http
#      После протокола идёт ://
#      Домен состоит из символов a-z, .
#      Путь состоит из символов a-z, 0-9, -, _, /
#      Параметры начинаются с ? и состоят из a-z, =, &, 0-9
#      Якорь начинается с # и состоит из a-z
#      Протокол и адрес у ссылок есть всегда, остальных частей может не быть
#      Ссылка не может быть подпоследовательностью
#      На вход программе подаётся 1 строка текста.
#      Выведите в консоль ссылку, протокол, домен, параметры, якорь найденных совпадений в следующем виде:
#      Полная ссылка: https://example.com/test/42523/step/2?q=query&s=search#test
#      Протокол: https | Домен: example.com | Параметры: ?q=query&s=search | Якорь: #test
#      Если группа ничего не нашла, то вместо совпадения нужно вывести None.

import re

pattern = r'(?P<protocol>http[s]?)+:\/\/(?P<domen>[a-z.\d]*?)\/[a-z\/\d_-]*(?P<params>\?[^# ]*)?(?P<anchor>[#][a-z]*)?'
match = re.finditer(pattern, input())
for i in match:
    print(f"Полная ссылка: {i[0]}")
    print(f"Протокол: {i['protocol']} | Домен: {i['domen']} | Параметры: {i['params']} | Якорь: {i['anchor']}") 
    print()

# 103. Получите все названия html-тегов.
#      Нужно названия html-тегов. Большинство html-тегов выглядит так:
#      В начале тега стоит < или </
#      В середине название тега, оно состоит из латинских букв нижнего регистра и арабских цифр максимальной длины
#      После названия может идти последовательность из любых символов минимальной длины
#      В конце тега стоит >
#      На вход программе подаётся 1 строка.
#      Список с найденными названиями html-тегов.

import re

pattern = r'</*([a-z\d]+).*?>'
print(re.findall(pattern, input()))

# 104. Получите список кортежей с логином, паролем, и токеном.
#      Нужно найти логин, пароль, и токен:
#      Логин состоит из 0-9
#      Пароль состоит из a-z, A-Z, 0-9
#      Токен состоит из a-z, 0-9
#      Длина минимум 1 символ
#      На вход программе подаётся 1 строка.
#      Список кортежей с логином, паролем, токеном, если они найдены в тексте. Если их нет - пустой список.

import re

pattern = r'(\d{1,}):([A-z\d]*):([a-z\d]*)'
print(re.findall(pattern, input()))

# 105. Разделите строку по знакам математических операций, удалив мусор вокруг них, и оставив в выходных данных математическое выражение.
#      Нужно разделить строку по следующей последовательности:
#      В левой части нечисловая последовательность символов любой длины
#      В  середине стоит один из символов +:=*/-
#      В правой части нечисловая последовательность символов любой длины
#      На вход программе подаётся 1 строка.
#      Список с числами и математическими операциями.

import re

pattern = r'\D*([+:=*/-])\D*'
print(re.split(pattern, input()))

# 106. Разделите строку по символам ? и &.
#      Нужно разделить строку по символвам ? и &, оставив эти символы в полученном списке.
#      На вход программе подаётся 1 строка.
#      Список, с частями исходной строки.

import re

pattern = r'([?&])' 
print(re.split(pattern, input()))

# 107. Замените два повторяющиеся слова на одно. Если слова одинаковые, но регистр разный - считаем что и слова разные.
#      Нужно заменить 2 повторяющиеся слова на одно:
#      Слова состоят из кириллических букв
#      Между ними стоит пробел
#      Если у слов разный регистр - слова разные
#      На вход программе подаётся 1 строка.
#      Строка с удалёнными повторяющимися словами.

import re

print(re.sub(r'(?P<group>[а-яё]+)\s(?P=group)', r'\1', input()))

# 108. Замените **Жирный текст** на <strong>Жирный текст</strong>, и *Курсив* на <em>Курсив</em>.
#      Нужно найти следующие последовательности:
#      Начинается и заканчивается с ** или *
#      В середине последовательность любой длины из букв кириллического и латинского алфавитов обоих регистров, а также пробелов
#      И заменить **text** на <strong>text</strong>, а *text* на <em>text</em>
#      На вход программе подаётся 1 строка.
#      Строка, в которой Markdown изменён на HTML.

import re

print(re.sub(r'\*(.*)\*', r'<em>\1</em>', re.sub(r'\*\*(.*)\*\*', r'<strong>\1</strong>', input())))

# 109. Найдите все прокси, и добавьте к ним в начало протокол http://.
#      Нужно найти следующие последовательности:
#      Адрес состоит из любых числовых последовательностей, разделённых .
#      В середине стоит :
#      Порт является любой числовой последовательностью
#      и в начало к ним добавить протокол http://.
#      На вход программе подаётся 1 строка.
#      Строка, в которой у всех прокси стоит протокол.

import re

print(re.sub(r'(?P<g1>[\d.]+)(?P<g2>:)(?P<g3>[\d]+)', r'http://\1\2\3', input()))