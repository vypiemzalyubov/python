# Перепишите код ниже так, чтобы напротив результата вызова функции выводилось значение, хранящееся по ключу

def red():
    return 'Color is red'

def green():
    return 'Color is green'

def blue():
    return 'Color is blue'

colors = {}
colors[green] = '00FF00'
colors[blue] = '0000FF'
colors[red] = 'FF0000'

for i, j in colors.items():
    print(f'{i()} - {j}')

# Представь, что ты работаешь в компании, которая занимается разработкой программного обеспечения.
# Твой начальник дал тебе задание написать программу, которая будет вычислять факториал числа.
# Факториал числа - это произведение всех натуральных чисел от 1 до этого числа. Например, факториал числа 5 равен 1 * 2 * 3 * 4 * 5 = 120.
# Однако, есть одно условие: ты должен сохранить результат вычисления факториала в глобальной переменной, чтобы его можно было использовать в других частях программы.
# Это означает, что значение факториала будет доступно для использования в других функциях или блоках кода.
# Также, твой начальник хочет, чтобы программа была оптимизирована и не вычисляла факториал числа каждый раз заново.
# Вместо этого, программа должна проверять, вызывалась ли уже функция с таким параметром.
# Если функция уже вызывалась с таким параметром, то программа должна вернуть сохраненное значение, а не вычислять его заново.
# Также перед возвратом такого значения функция должна вывести на экран «Get from cache value factorial(n)»
# Таким образом, твоя задача - написать функцию factorial, которая будет вычислять факториал числа, сохранять результат в глобальной переменной и проверять,
# вызывалась ли уже функция с таким параметром.

fact = 1
cache = dict()


def factorial(n):
    if cache.get(n) is not None:
        print(f'Get from cache value factorial({n})')
        return cache.get(n)
    global fact
    res = 1
    for i in range(1, n + 1):
        res *= i
    cache[n] = res
    fact = res
    return res

# Одной из базовых банковских услуг является обмен валют.
# Напишите функцию convert, которая умеет конвертировать доллар в другую валюту и наоборот.
# Для конвертации используются текущие курсы валют, которые хранятся в глобальном словаре exchange_rates.
# Результат округлите до двух знаков после запятой при помощи функции round

exchange_rates = {
    "USD": 1.0,
    "EUR": 0.861775,
    "GBP": 0.726763,
    "INR": 75.054725,
    "AUD": 1.333679,
    "CAD": 1.237816,
    "SGD": 1.346851,
}


def convert(currency1: str, currency2: str, count: int):
    return round(exchange_rates[currency2] / exchange_rates[currency1] * count, 2)

# Начальник дал джуну Ване реализовать анонимную функцию, которая принимает два числа, возводит каждое в квадрат и складывает полученные результаты.
# Сохранить функцию необходимо было в переменную square Но Ваня очень разволновался и допустил несколько ошибок.
# Вам, как опытному коллеге, необходимо исправить ошибки Вани, чтобы начальник не лишил его зарплаты.  Исправления нужно сделать только в пределах одной строки.
# Вводить и выводить ничего не нужно

square = lambda x, y: x**2 + y**2

# В переменную adding_10 присвойте lambda функцию, которая принимает одно число и увеличивает его на 10.
# Ничего кроме создания переменной adding_10 делать не нужно

adding_10 = lambda x: x + 10

# В переменную starts_with присвойте lambda функцию, которая принимает строку и возвращает True, когда переданная строка начинается с буквы «W».
# Во всех остальных случаях нужно возвращать False. Ничего кроме создания переменной starts_with делать не нужно

starts_with = lambda s: s.startswith('W')

# В переменную check_word присвойте lambda функцию, которая принимает строку и возвращает True,
# если переданная строка начинается с букв «Q» или «R» и заканчивается любой из гласных «A», «E», «I», «U» или «O».
# Регистр во время проверок не должен иметь значения.
# Во всех остальных случаях нужно возвращать False. Ничего кроме создания переменной check_word делать не нужно

check_word = lambda s: s.lower().startswith(('q', 'r')) and s.lower().endswith(('a', 'e', 'i', 'u', 'o'))

# Помните задачу «Проверка на високосность»? Ваша задача реализовать данную функцию при помощи lambda оператора
# Полученную функцию сохраните в переменную is_leap

is_leap = lambda year: (year % 4 == 0 and year % 100 != 0) or year % 400 == 0

# Имеется функция sale, которая возвращает цену товара со скидкой 10%.
# def sale(x):
#     return x*0.9
# Однако мы изучаем анонимные функции, поэтому на основе данной функции создайте анонимную функцию и присвойте её переменной sale_lambda

sale_lambda = lambda n: n * 0.9

# Хорошо постарались с прошлой задачей! Однако мы забыли, что скидка должна быть только для тех товаров, стоимость которых больше 50.
# Вам стоит внести это изменение в прошлый код. Ваша задача только переопределить переменную sale_lambda

sale_lambda = lambda n: n * 0.9 if n > 50 else n

# Напишите lambda функцию, которая принимает произвольное количество числовых аргументов и выводит их среднее арифметическое.
# Для проверки решения присвойте вашу lambda функцию переменной average.
# Вводить и выводить ничего не нужно, только определить переменную average

average = lambda *args: sum(args) / len(args)

# Напишите функцию print_results, которая принимает список кортежей. Каждый элемент вложенного кортежа состоит из названия предмета и оценки по нему.
# Функция print_results должна вывести информацию по экзаменам, отсортированную по возрастанию оценок.
# Название каждой пары предмета и оценки печатается на отдельной строке через пробел.
# В случае равенства оценок предметы должны выводиться на экран в том же порядке, в котором они следовали во входном списке

def print_results(lst: list[tuple]):
    for i in sorted(lst, key=lambda x: x[1]):
        print(*i)

# Перепишите функцию print_results так, чтобы информация выводилась по убыванию оценок.
# В случае равенства оценок предметы должны выводиться на экран в том же порядке, в котором они следовали во входном списке

def print_results(lst: list[tuple]):
    [print(*i) for i in sorted(lst, key=lambda x: -x[1])]

# Перепишите функцию print_results так, чтобы информация выводилась по убыванию оценок,
# а в случае их равенства предметы должны выводиться в алфавитном порядке без учета регистра

def print_results(lst: list[tuple]):
    [print(*i) for i in sorted(lst, key=lambda x: (-x[1], x[0].lower()))]

# Перепишите функцию print_results так, чтобы информация выводилась по убыванию оценок,
# а в случае их равенства предметы должны выводиться в обратном алфавитном порядке без учета регистра

def print_results(lst: list[tuple]):
    [print(*i) for i in sorted(lst, key=lambda x: (x[1], x[0].lower()), reverse=True)]

# Напишите функцию get_sort_lines, которая принимает список кортежей, в котором хранится информация о координатах двух точек на координатной прямой.
# Функция get_sort_lines должна вернуть новый список, в котором элементы расположены в порядке возрастания расстояния между точками, хранящимися в одном элементе.
# В случае равенства расстояний необходимо сортировать по возрастанию значения координаты первой точки, затем по возрастанию значения второй точки

def get_sort_lines(lst: list[tuple]):
    return [i for i in sorted(lst, key=lambda x: (max(x) - min(x), x[0], x[1]))]

# Напишите функцию print_goods, которая принимает список словарей. В самих словарях хранится информация о товарах: имя, модель и цвет.
# Задача функции print_goods вывести на экран информацию о товарах  в следующем формате
# Производитель: <make>, модель: <model>, цвет: <color>
# при этом товары должны быть отсортированы по цвету в лексикографическом порядке (по алфавиту) без учета регистра и по убыванию модели (второй критерий сортировки)

def print_goods(lst):
    for i in sorted(lst, key=lambda x: (x['color'].lower(), -x['model'])):
        print(f'Производитель: {i["make"]}, модель: {i["model"]}, цвет: {i["color"]}')

# Поставщик скидывает нашему заказчику информацию о товарах, а он хочет взглянуть на нее в отсортированном виде.
# Заказчик хочет видеть вывод, где вверху самые дорогие товары, внизу самые дешевые.
# Вот только поставщик предоставляет данные в виде списка строк, где каждая строка хранит информацию о товаре в виде
# Название_товара: цена_товара
# Название товара отделено от цены знаком двоеточия :.
# Ваша задача написать функцию print_goods , которая принимает список строк.
# Далее print_goods  должна выводить информацию о товарах, сортируя их сперва по цене, а затем по алфавиту без учета регистра.
# Вывод информации о каждом товаре делается в отдельной строке в следующем формате
# Цена_товара - Название_товара
# Цена должна выводиться с точностью до двух знаком после запятой

def print_goods(lst):
    for goods in sorted(lst, key=lambda x: (-float(x.split(': ')[1]), x.split(': ')[0].lower())):
        item, price = goods.split(': ')
        print(f'{round(float(price), 2):.2f} - {item}')

# Представьте, что мы с вами сами можем решать кому и сколько статуэток Оскара уйдет (Лео бы тогда давно купался в этих статуэтках).
# Ваша задача написать функцию print_best_and_worst_laureate, которая находит информацию, кто из номинантов получил наибольшее и наименьшее количество статуэток.
# Функция print_best_and_worst_laureate принимает на вход словарь, где указана номинация и имя победителя в ней (название фильма или имя актера).
# На основании этой информации функция print_best_and_worst_laureate должна в отдельных строках вывести лауреатов премии,
# набравших наибольшее и наименьшее количество статуэток и через запятую их количество.

from collections import Counter


def print_best_and_worst_laureate(dct):
    tmp = Counter(dct.values())
    print(*sorted(tmp.items(), key=lambda x: x[1])[-1], sep=', ')
    print(*sorted(tmp.items(), key=lambda x: x[1])[0], sep=', ')

# Руководитель таксопарка хочет увидеть отчет по всем таксистам, где нужно указать имя таксиста и его среднюю оценку.
# Информацию в отчете нужно расположить по убыванию средней оценки таксиста. Для этого вам нужно написать функцию print_order_rating,
# которая принимает на вход список кортежей. Каждый кортеж состоит из двух элементов: имя таксиста и оценка за поездку (целое число от 1 до 5).
# Функция print_order_rating должна расположить таксистов в порядке убывания их средней оценки и вывести имя каждого таксиста
# и его среднюю оценку в отдельной строке. В случае совпадения средних оценок нужно расположить каждую группу таксистов, имеющих одинаковый рейтинг,
# по имени в алфавитном порядке без учета регистра

def print_order_rating(dct):
    driver = dict()
    for name, rating in dct:
        driver.setdefault(name, []).append(rating)
    for k, v in sorted(driver.items(), key=lambda x: (-sum(x[1])/len(x[1]), x[0].lower())):
        print(k, sum(v)/len(v))

# В социальных сетях все как обычно: одни люди выкладывают посты, другие их комментируют.
# Сервис по сбору аналитики решил найти у кого из владельцев постов самое большое количество уникальных комментаторов.
# Ваша задача помочь им в этом и собрать нужную информацию. Для это вам потребуется написать функцию print_statistic, которая принимает список кортежей.
# Каждый кортеж состоит из пары значений: автор поста и далее ник пользователя, оставившего комментарий к этому посту.
# Комментаторы могут повторяться и комментировать разных авторов.
# Функция print_statistic должна посчитать для каждого автора его уникальное количество комментаторов.
# Исходя из найденного количества определяется популярность автора. Чем больше уникальных пользователей прокомментировало автора, тем он считается популярнее.
# Затем функция print_statistic должна для каждого автора вывести в порядке уменьшения популярности информацию в следующем виде
# "Количество уникальных комментаторов у <имя героя> - <количество комментаторов>"
# На склонение давайте не будем обращать внимание в этой задаче.
# В случае одинаковой популярности у нескольких авторов, необходимо ранжировать по алфавитному порядку имени авторов без учета регистра

def print_statistic(dct):
    tmp = dict()
    for author, commentator in dct:
        tmp.setdefault(author, []).append(commentator)
    for k, v in sorted(tmp.items(), key=lambda x: (-len(set(x[1])), x[0].lower())):
        print(f'Количество уникальных комментаторов у {k} - {len(set(v))}')

# Напишите функцию get_info_about_object, которая принимает объект и выводит информацию обо всех его атрибутах и методах в следующем формате:
# сперва выводится список всех атрибутов и методов
# на следующей строке фраза «Всего у объекта {count} атрибутов и методов»

def get_info_about_object(obj):
    print(dir(obj), f'Всего у объекта {len(dir(obj))} атрибутов и методов', sep='\n')

# Напишите функцию check_exist_attrs, которая принимает объект obj и список строк, в котором хранятся имена атрибутов.
# Функция check_exist_attrs должна вернуть словарь, в котором ключами будут являться имена атрибутов из переданного списка.
# Напротив каждого ключа должно быть булево значение: True, если атрибут присутствует в объекте obj , в обратном случае - False.
# Ключи в итоговом словаре необходимо создавать в порядке следования имен атрибутов во входном списке

def check_exist_attrs(obj, lst):
    return {i: hasattr(obj, i) for i in lst}

# Напишите функцию create_attrs, которая принимает объект obj и список кортежей.
# Каждый кортеж состоит из пары значений: имя атрибута в виде строки и его будущее значение.
# Задача функции create_attrs — создать на основании внутренних кортежей списка новые атрибуты к переданному объекту.
# Для проверки работоспособности программы скопируйте реализацию функции check_exist_attrs из предыдущего задания

def create_attrs(obj, lst):
    for i in lst:
        setattr(obj, i[0], i[1])


def check_exist_attrs(obj, lst):
    return {i: hasattr(obj, i) for i in lst}

# Ваша задача написать функцию count_strings, которая принимает произвольное количество аргументов.
# Функция должна среди всех переданных значений найти только строки, найти их количество и  вернуть в качестве результата.
# Ваша задача написать только определение функции count_strings

def count_strings(*args):
    return sum([1 for i in args if isinstance(i, str)])

# Ваша задача написать функцию find_keys, которая принимает произвольное количество именованных аргументов.
# Функция должна отобрать только те имена параметров, у которых значения являются списками или кортежами.
# Функция find_keys должна собрать все имена таких параметров в список, отсортировать их по алфавиту вне зависимости от регистра букв и вернуть в качестве результата.
# Ниже представлены примеры:
# find_keys(t=[4, 5], W=[5, 3], A=(3, 2), a={2, 3}, b=[4]) => ['A', 'b', 't', 'W']
# find_keys(name='Bruce', surname='Wayne') => []
# find_keys(marks=[4, 5], name='ashle', surname='Brown', age=20, Also=(1, 2)) => ['Also', 'marks']
# Ваша задача написать только определение функции find_keys

def find_keys(**kwargs):
    return sorted([k for k, v in kwargs.items() if isinstance(v, list | tuple)], key=str.lower)

# Перед вами код из предыдущего задания. Исправьте его так, чтобы на экране появилась строка «hello», затем «bye»

def outer() -> None:
    def say_hello() -> None:
        print('hello')

    def say_bye() -> None:
        print('bye')
        
    say_hello()
    say_bye()


outer()

# Имеется функция wrap_increment, которая должна принимать значение и увеличивать его на 1. Увеличение на один должно выполняться за счет вложенной функции _inc.
# Ваша задача дописать в теле wrap_increment определение функции _inc, которая принимает значение и увеличивает его.

def wrap_increment(value):
    
    def _inc(value):
        return value + 1

    return _inc(value)

# Перед вами вполне работающая функция get_extensions, которая принимает список названий файлов.
# Функция get_extensions находит расширение у названий файлов и составляет из них список, который возвращает в качестве ответа.
# Если у файла нет расширения, то для такого файла get_extensions подставляет пустую строку.
# Ваша задача — произвести рефакторинг данного кода для создания внутренней вспомогательной функции, которая выполняет всю работу по поиску расширения.
# Вы можете, к примеру, назвать ее _get_extension и тогда, определив такую функцию, ей можно пользоваться следующим образом:
# for i in file_list:
#     results.append(_get_extension(i))
# или даже сразу так
# return [_get_extension(i) for i in file_list]
# Перепишите функцию get_extensions с учетом описанных пожеланий по созданию внутренней функции.

def get_extensions(file_list):
    
    def _get_extension(file_list):
        return [i.split(".")[-1] if "." in i else "" for i in file_list]
    
    return _get_extension(file_list)

# Перед вами частично реализованная функция double_odd_numbers, которая принимает список чисел и возвращает в качестве результата новый список,
# составленный из нечетных чисел, увеличенных в два раза.
# Внутри себя double_odd_numbers использует две функции:
# double, увеличивающая число в два раза;
# is_odd, проверяющая на нечетность
# Ваша задача реализовать эти функции внутри  double_odd_numbers

def double_odd_numbers(numbers):
    
    def is_odd(num):
        return num % 2
    
    def double(num):
        return num * 2
    
    return [double(num) for num in numbers if is_odd(num)]

# Пользуясь вложенными функциями, реализуйте простой калькулятор. Для этого необходимо реализовать функцию calculate , которая принимает три параметра:
# - обязательный числовой параметр x
# - обязательный числовой параметр y
# - необязательный строковый параметр operation,  по умолчанию принимает значение английской буквы a
# В данной функции должны быть реализованы следующие функции:
# - addition - сложение двух чисел,
# - subtraction - вычитание из первого переданного параметра второго;
# - division - деление первого на второго,
# - multiplication - умножение двух чисел.
# Каждая из этих четырёх вложенных функций должна распечатать результат математической операции и ничего не возвращать
# А при помощи параметра operation и условного оператора нужно выбрать какая из функций должна быть вызвана:
# если operation = a, вызываем функцию addition;
# если operation = s, вызываем функцию subtraction;
# если operation = d, вызываем функцию division;
# если operation = m, вызываем функцию multiplication;
# calculate(2, 5) # Печатает 7.0
# calculate(2.2, 15, 'a') # Печатает 17.2
# calculate(22, 15, 's') # Печатает 7.0
# calculate(2, 3.2, 'm') # Печатает 6.4
# calculate(10, 0.4, 'd') # Печатает 25.0
# Если operation принимает значение, отличное от перечисленных выше букв, то необходимо вывести на экран  сообщение «Ошибка. Данной операции не существует».
# Также если мы выполняем деление, то второе число (y) не должно равняться нулю, в противном случае необходимо вывести на экран: «На ноль делить нельзя!».
# Вам необходимо написать только определение функции  calculate

def calculate(x, y, operation='a'):
    
    addition = lambda x, y: print(x+y)
    subtraction = lambda x, y: print(x-y)
    division = lambda x, y: print(x/y) if y != 0 else print('На ноль делить нельзя!')
    multiplication = lambda x, y: print(x*y)
    
    match operation:
        case 'a':
            addition(x, y)
        case 's':
            subtraction(x, y)
        case 'd':
            division(x, y)
        case 'm':
            multiplication(x, y)
        case _:
            print('Ошибка. Данной операции не существует')

# Напишите функцию apply, которая принимает функцию и итерируемый объект (например, список) и применяет функцию к каждому элементу итерируемого объекта.
# В качестве ответа функция apply должна вернуть список из вычисленных значений.

def apply(func, lst):
    return [func(i) for i in lst]

# Затем создайте функцию compute, которая принимает список функций и произвольное количество значений.
# Функция compute должна применить каждую функцию к каждому значению в переданном порядке и сформировать из полученных значений новый список,
# который и будет возвращаться в качестве ответа

def compute(func_lst, *args):
    return [func(i) for func in func_lst for i in args]

# Затем создайте функцию compute, которая принимает список функций и произвольное количество значений.
# Функция compute должна применить последовательно в переданном порядке все функции сразу к каждому значению и сформировать из полученных значений новый список,
# который и будет возвращаться в качестве ответа

def compute(func_lst, *args):
    res = []
    for i in args:
        total = i
        for func in func_lst:
            x = func(total)
            total = x
        res.append(total)
    return res

# Напишите функцию filter_list, которая принимает функцию f и список lst.
# Функция f обязательно должна проверять определенное условие и возвращать булев тип.
# Задача функции filter_list состоит в том, чтобы вернуть новый список, составленный из элементов входного lst, отфильтрованных согласно функции f.

def filter_list(f, lst):
    return [i for i in lst if f(i)]

# На основании предыдущей функции filter_list, напишем новую функцию filter_collection.
# Особенность функции filter_collection заключается в том, что она возвращает тот же тип коллекции, который она принимала на вход.
# А остальной принцип  ее работы похож с функцией filter_list: обе принимают функцию f для проверки, при помощи которой фильтруются элементы коллекции
# Функция f обязательно должна проверять определенное условие и возвращать булев тип.

def filter_collection(f, collection):
    if isinstance(collection, str):
        return ''.join([i for i in collection if f(i)])
    elif isinstance(collection, tuple):
        return tuple([i for i in collection if f(i)])
    return [i for i in collection if f(i)]

# Реализуйте функцию aggregation, которая принимает на вход функцию func и коллекцию элементов sequence. Функция func будет принимать только два элемента.
# Задача функции aggregation уметь накапливать результат вычисления функции func путем последовательного применения ее ко всем элементам. 
# Но так как функция func умеет работать только с двумя значениями, вам необходимо передавать элементы последовательно парами. 
# В результате у вас должен получиться список, в котором копятся результаты работы функции aggregation
# Пример, в качестве func возьмем функцию 
# def get_add(x, y):
#     return x + y
# Коллекцией у нас будет следующий список
# numbers = [5, 2, 4, 3, 5]
# Применяя func к первым элементам коллекции 5 и 2, получим сумму 7. Это первое наше агрегированное значение
# Далее берем уже накопленное значение 7 и следующий необработанный элемент 4, суммируем и получаем новую агрегацию 11.
# Затем суммируем нашу агрегацию 11 со значением 3, получаем 14. И в конце добавляем последний элемент и готово итоговое значение 19. 
# В итоге в процессе применения функции func мы нашли следующие значения [7, 11, 14, 19]. Данный список и нужно будет вернуть в качестве ответа.

def aggregation(func, sequence):
    res = []
    total = None
    for i in range(len(sequence)-1):
        if total is None:
            total = func(sequence[i], sequence[i+1])
            res.append(total)            
        else:
            total = func(total, sequence[i+1])
            res.append(total)
    return res

# Перепишите функцию aggregation так, чтобы она возвращала итоговое значение агрегации.
# Функция aggregation по-прежнему должна принимать на вход функцию func и коллекцию элементов sequence. 

def aggregation(func, sequence):
    total = sequence[0]
    while len(sequence) > 1:
        total = func(total, sequence.pop())
    return total

# Перепишите функцию aggregation с прошлого шага так, чтобы у нее появился необязательный параметр initial по умолчанию равный None. 
# Данный параметр отвечает за начальное состояние агрегации, если в него передать значение. Если ничего не передавать в initial, то функция aggregation работает как прежде

def aggregation(func, sequence, initial = None):
    if initial is not None:
        sequence.append(initial)
    total = sequence[0]
    while len(sequence) > 1:
        total = func(total, sequence.pop())
    return total