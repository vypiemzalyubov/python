# Перепишите код ниже так, чтобы напротив результата вызова функции выводилось значение, хранящееся по ключу

def red():
    return 'Color is red'

def green():
    return 'Color is green'

def blue():
    return 'Color is blue'

colors = {}
colors[green] = '00FF00'
colors[blue] = '0000FF'
colors[red] = 'FF0000'

for i, j in colors.items():
    print(f'{i()} - {j}')

# Представь, что ты работаешь в компании, которая занимается разработкой программного обеспечения.
# Твой начальник дал тебе задание написать программу, которая будет вычислять факториал числа.
# Факториал числа - это произведение всех натуральных чисел от 1 до этого числа. Например, факториал числа 5 равен 1 * 2 * 3 * 4 * 5 = 120.
# Однако, есть одно условие: ты должен сохранить результат вычисления факториала в глобальной переменной, чтобы его можно было использовать в других частях программы.
# Это означает, что значение факториала будет доступно для использования в других функциях или блоках кода.
# Также, твой начальник хочет, чтобы программа была оптимизирована и не вычисляла факториал числа каждый раз заново.
# Вместо этого, программа должна проверять, вызывалась ли уже функция с таким параметром.
# Если функция уже вызывалась с таким параметром, то программа должна вернуть сохраненное значение, а не вычислять его заново.
# Также перед возвратом такого значения функция должна вывести на экран «Get from cache value factorial(n)»
# Таким образом, твоя задача - написать функцию factorial, которая будет вычислять факториал числа, сохранять результат в глобальной переменной и проверять,
# вызывалась ли уже функция с таким параметром.

fact = 1
cache = dict()


def factorial(n):
    if cache.get(n) is not None:
        print(f'Get from cache value factorial({n})')
        return cache.get(n)
    global fact
    res = 1
    for i in range(1, n + 1):
        res *= i
    cache[n] = res
    fact = res
    return res

# Одной из базовых банковских услуг является обмен валют.
# Напишите функцию convert, которая умеет конвертировать доллар в другую валюту и наоборот.
# Для конвертации используются текущие курсы валют, которые хранятся в глобальном словаре exchange_rates.
# Результат округлите до двух знаков после запятой при помощи функции round

exchange_rates = {
    "USD": 1.0,
    "EUR": 0.861775,
    "GBP": 0.726763,
    "INR": 75.054725,
    "AUD": 1.333679,
    "CAD": 1.237816,
    "SGD": 1.346851,
}


def convert(currency1: str, currency2: str, count: int):
    return round(exchange_rates[currency2] / exchange_rates[currency1] * count, 2)

# Начальник дал джуну Ване реализовать анонимную функцию, которая принимает два числа, возводит каждое в квадрат и складывает полученные результаты.
# Сохранить функцию необходимо было в переменную square Но Ваня очень разволновался и допустил несколько ошибок.
# Вам, как опытному коллеге, необходимо исправить ошибки Вани, чтобы начальник не лишил его зарплаты.  Исправления нужно сделать только в пределах одной строки.
# Вводить и выводить ничего не нужно

square = lambda x, y: x**2 + y**2

# В переменную adding_10 присвойте lambda функцию, которая принимает одно число и увеличивает его на 10.
# Ничего кроме создания переменной adding_10 делать не нужно

adding_10 = lambda x: x + 10

# В переменную starts_with присвойте lambda функцию, которая принимает строку и возвращает True, когда переданная строка начинается с буквы «W».
# Во всех остальных случаях нужно возвращать False. Ничего кроме создания переменной starts_with делать не нужно

starts_with = lambda s: s.startswith('W')

# В переменную check_word присвойте lambda функцию, которая принимает строку и возвращает True,
# если переданная строка начинается с букв «Q» или «R» и заканчивается любой из гласных «A», «E», «I», «U» или «O».
# Регистр во время проверок не должен иметь значения.
# Во всех остальных случаях нужно возвращать False. Ничего кроме создания переменной check_word делать не нужно

check_word = lambda s: s.lower().startswith(('q', 'r')) and s.lower().endswith(('a', 'e', 'i', 'u', 'o'))

# Помните задачу «Проверка на високосность»? Ваша задача реализовать данную функцию при помощи lambda оператора
# Полученную функцию сохраните в переменную is_leap

is_leap = lambda year: (year % 4 == 0 and year % 100 != 0) or year % 400 == 0

# Имеется функция sale, которая возвращает цену товара со скидкой 10%.
# def sale(x):
#     return x*0.9
# Однако мы изучаем анонимные функции, поэтому на основе данной функции создайте анонимную функцию и присвойте её переменной sale_lambda

sale_lambda = lambda n: n * 0.9

# Хорошо постарались с прошлой задачей! Однако мы забыли, что скидка должна быть только для тех товаров, стоимость которых больше 50.
# Вам стоит внести это изменение в прошлый код. Ваша задача только переопределить переменную sale_lambda

sale_lambda = lambda n: n * 0.9 if n > 50 else n

# Напишите lambda функцию, которая принимает произвольное количество числовых аргументов и выводит их среднее арифметическое.
# Для проверки решения присвойте вашу lambda функцию переменной average.
# Вводить и выводить ничего не нужно, только определить переменную average

average = lambda *args: sum(args) / len(args)

# Напишите функцию print_results, которая принимает список кортежей. Каждый элемент вложенного кортежа состоит из названия предмета и оценки по нему.
# Функция print_results должна вывести информацию по экзаменам, отсортированную по возрастанию оценок.
# Название каждой пары предмета и оценки печатается на отдельной строке через пробел.
# В случае равенства оценок предметы должны выводиться на экран в том же порядке, в котором они следовали во входном списке

def print_results(lst: list[tuple]):
    for i in sorted(lst, key=lambda x: x[1]):
        print(*i)

# Перепишите функцию print_results так, чтобы информация выводилась по убыванию оценок.
# В случае равенства оценок предметы должны выводиться на экран в том же порядке, в котором они следовали во входном списке

def print_results(lst: list[tuple]):
    [print(*i) for i in sorted(lst, key=lambda x: -x[1])]

# Перепишите функцию print_results так, чтобы информация выводилась по убыванию оценок,
# а в случае их равенства предметы должны выводиться в алфавитном порядке без учета регистра

def print_results(lst: list[tuple]):
    [print(*i) for i in sorted(lst, key=lambda x: (-x[1], x[0].lower()))]

# Перепишите функцию print_results так, чтобы информация выводилась по убыванию оценок,
# а в случае их равенства предметы должны выводиться в обратном алфавитном порядке без учета регистра

def print_results(lst: list[tuple]):
    [print(*i) for i in sorted(lst, key=lambda x: (x[1], x[0].lower()), reverse=True)]

# Напишите функцию get_sort_lines, которая принимает список кортежей, в котором хранится информация о координатах двух точек на координатной прямой.
# Функция get_sort_lines должна вернуть новый список, в котором элементы расположены в порядке возрастания расстояния между точками, хранящимися в одном элементе.
# В случае равенства расстояний необходимо сортировать по возрастанию значения координаты первой точки, затем по возрастанию значения второй точки

def get_sort_lines(lst: list[tuple]):
    return [i for i in sorted(lst, key=lambda x: (max(x) - min(x), x[0], x[1]))]

# Напишите функцию print_goods, которая принимает список словарей. В самих словарях хранится информация о товарах: имя, модель и цвет.
# Задача функции print_goods вывести на экран информацию о товарах  в следующем формате
# Производитель: <make>, модель: <model>, цвет: <color>
# при этом товары должны быть отсортированы по цвету в лексикографическом порядке (по алфавиту) без учета регистра и по убыванию модели (второй критерий сортировки)

def print_goods(lst):
    for i in sorted(lst, key=lambda x: (x['color'].lower(), -x['model'])):
        print(f'Производитель: {i["make"]}, модель: {i["model"]}, цвет: {i["color"]}')

# Поставщик скидывает нашему заказчику информацию о товарах, а он хочет взглянуть на нее в отсортированном виде.
# Заказчик хочет видеть вывод, где вверху самые дорогие товары, внизу самые дешевые.
# Вот только поставщик предоставляет данные в виде списка строк, где каждая строка хранит информацию о товаре в виде
# Название_товара: цена_товара
# Название товара отделено от цены знаком двоеточия :.
# Ваша задача написать функцию print_goods , которая принимает список строк.
# Далее print_goods  должна выводить информацию о товарах, сортируя их сперва по цене, а затем по алфавиту без учета регистра.
# Вывод информации о каждом товаре делается в отдельной строке в следующем формате
# Цена_товара - Название_товара
# Цена должна выводиться с точностью до двух знаком после запятой

def print_goods(lst):
    for goods in sorted(lst, key=lambda x: (-float(x.split(': ')[1]), x.split(': ')[0].lower())):
        item, price = goods.split(': ')
        print(f'{round(float(price), 2):.2f} - {item}')

# Представьте, что мы с вами сами можем решать кому и сколько статуэток Оскара уйдет (Лео бы тогда давно купался в этих статуэтках).
# Ваша задача написать функцию print_best_and_worst_laureate, которая находит информацию, кто из номинантов получил наибольшее и наименьшее количество статуэток.
# Функция print_best_and_worst_laureate принимает на вход словарь, где указана номинация и имя победителя в ней (название фильма или имя актера).
# На основании этой информации функция print_best_and_worst_laureate должна в отдельных строках вывести лауреатов премии,
# набравших наибольшее и наименьшее количество статуэток и через запятую их количество.

from collections import Counter


def print_best_and_worst_laureate(dct):
    tmp = Counter(dct.values())
    print(*sorted(tmp.items(), key=lambda x: x[1])[-1], sep=', ')
    print(*sorted(tmp.items(), key=lambda x: x[1])[0], sep=', ')

# Руководитель таксопарка хочет увидеть отчет по всем таксистам, где нужно указать имя таксиста и его среднюю оценку.
# Информацию в отчете нужно расположить по убыванию средней оценки таксиста. Для этого вам нужно написать функцию print_order_rating,
# которая принимает на вход список кортежей. Каждый кортеж состоит из двух элементов: имя таксиста и оценка за поездку (целое число от 1 до 5).
# Функция print_order_rating должна расположить таксистов в порядке убывания их средней оценки и вывести имя каждого таксиста
# и его среднюю оценку в отдельной строке. В случае совпадения средних оценок нужно расположить каждую группу таксистов, имеющих одинаковый рейтинг,
# по имени в алфавитном порядке без учета регистра

def print_order_rating(dct):
    driver = dict()
    for name, rating in dct:
        driver.setdefault(name, []).append(rating)
    for k, v in sorted(driver.items(), key=lambda x: (-sum(x[1])/len(x[1]), x[0].lower())):
        print(k, sum(v)/len(v))

# В социальных сетях все как обычно: одни люди выкладывают посты, другие их комментируют.
# Сервис по сбору аналитики решил найти у кого из владельцев постов самое большое количество уникальных комментаторов.
# Ваша задача помочь им в этом и собрать нужную информацию. Для это вам потребуется написать функцию print_statistic, которая принимает список кортежей.
# Каждый кортеж состоит из пары значений: автор поста и далее ник пользователя, оставившего комментарий к этому посту.
# Комментаторы могут повторяться и комментировать разных авторов.
# Функция print_statistic должна посчитать для каждого автора его уникальное количество комментаторов.
# Исходя из найденного количества определяется популярность автора. Чем больше уникальных пользователей прокомментировало автора, тем он считается популярнее.
# Затем функция print_statistic должна для каждого автора вывести в порядке уменьшения популярности информацию в следующем виде
# "Количество уникальных комментаторов у <имя героя> - <количество комментаторов>"
# На склонение давайте не будем обращать внимание в этой задаче.
# В случае одинаковой популярности у нескольких авторов, необходимо ранжировать по алфавитному порядку имени авторов без учета регистра

def print_statistic(dct):
    tmp = dict()
    for author, commentator in dct:
        tmp.setdefault(author, []).append(commentator)
    for k, v in sorted(tmp.items(), key=lambda x: (-len(set(x[1])), x[0].lower())):
        print(f'Количество уникальных комментаторов у {k} - {len(set(v))}')