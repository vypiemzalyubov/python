# Перепишите код ниже так, чтобы напротив результата вызова функции выводилось значение, хранящееся по ключу

def red():
    return 'Color is red'

def green():
    return 'Color is green'

def blue():
    return 'Color is blue'

colors = {}
colors[green] = '00FF00'
colors[blue] = '0000FF'
colors[red] = 'FF0000'

for i, j in colors.items():
    print(f'{i()} - {j}')

# Представь, что ты работаешь в компании, которая занимается разработкой программного обеспечения.
# Твой начальник дал тебе задание написать программу, которая будет вычислять факториал числа.
# Факториал числа - это произведение всех натуральных чисел от 1 до этого числа. Например, факториал числа 5 равен 1 * 2 * 3 * 4 * 5 = 120.
# Однако, есть одно условие: ты должен сохранить результат вычисления факториала в глобальной переменной, чтобы его можно было использовать в других частях программы.
# Это означает, что значение факториала будет доступно для использования в других функциях или блоках кода.
# Также, твой начальник хочет, чтобы программа была оптимизирована и не вычисляла факториал числа каждый раз заново.
# Вместо этого, программа должна проверять, вызывалась ли уже функция с таким параметром.
# Если функция уже вызывалась с таким параметром, то программа должна вернуть сохраненное значение, а не вычислять его заново.
# Также перед возвратом такого значения функция должна вывести на экран «Get from cache value factorial(n)»
# Таким образом, твоя задача - написать функцию factorial, которая будет вычислять факториал числа, сохранять результат в глобальной переменной и проверять,
# вызывалась ли уже функция с таким параметром.

fact = 1
cache = dict()


def factorial(n):
    if cache.get(n) is not None:
        print(f'Get from cache value factorial({n})')
        return cache.get(n)
    global fact
    res = 1
    for i in range(1, n + 1):
        res *= i
    cache[n] = res
    fact = res
    return res

# Одной из базовых банковских услуг является обмен валют.
# Напишите функцию convert, которая умеет конвертировать доллар в другую валюту и наоборот.
# Для конвертации используются текущие курсы валют, которые хранятся в глобальном словаре exchange_rates.
# Результат округлите до двух знаков после запятой при помощи функции round

exchange_rates = {
    "USD": 1.0,
    "EUR": 0.861775,
    "GBP": 0.726763,
    "INR": 75.054725,
    "AUD": 1.333679,
    "CAD": 1.237816,
    "SGD": 1.346851,
}


def convert(currency1: str, currency2: str, count: int):
    return round(exchange_rates[currency2] / exchange_rates[currency1] * count, 2)

# Начальник дал джуну Ване реализовать анонимную функцию, которая принимает два числа, возводит каждое в квадрат и складывает полученные результаты.
# Сохранить функцию необходимо было в переменную square Но Ваня очень разволновался и допустил несколько ошибок.
# Вам, как опытному коллеге, необходимо исправить ошибки Вани, чтобы начальник не лишил его зарплаты.  Исправления нужно сделать только в пределах одной строки.
# Вводить и выводить ничего не нужно

square = lambda x, y: x**2 + y**2

# В переменную adding_10 присвойте lambda функцию, которая принимает одно число и увеличивает его на 10.
# Ничего кроме создания переменной adding_10 делать не нужно

adding_10 = lambda x: x + 10

# В переменную starts_with присвойте lambda функцию, которая принимает строку и возвращает True, когда переданная строка начинается с буквы «W».
# Во всех остальных случаях нужно возвращать False. Ничего кроме создания переменной starts_with делать не нужно

starts_with = lambda s: s.startswith('W')

# В переменную check_word присвойте lambda функцию, которая принимает строку и возвращает True,
# если переданная строка начинается с букв «Q» или «R» и заканчивается любой из гласных «A», «E», «I», «U» или «O».
# Регистр во время проверок не должен иметь значения.
# Во всех остальных случаях нужно возвращать False. Ничего кроме создания переменной check_word делать не нужно

check_word = lambda s: s.lower().startswith(('q', 'r')) and s.lower().endswith(('a', 'e', 'i', 'u', 'o'))

# Помните задачу «Проверка на високосность»? Ваша задача реализовать данную функцию при помощи lambda оператора
# Полученную функцию сохраните в переменную is_leap

is_leap = lambda year: (year % 4 == 0 and year % 100 != 0) or year % 400 == 0

# Имеется функция sale, которая возвращает цену товара со скидкой 10%.
# def sale(x):
#     return x*0.9
# Однако мы изучаем анонимные функции, поэтому на основе данной функции создайте анонимную функцию и присвойте её переменной sale_lambda

sale_lambda = lambda n: n * 0.9

# Хорошо постарались с прошлой задачей! Однако мы забыли, что скидка должна быть только для тех товаров, стоимость которых больше 50.
# Вам стоит внести это изменение в прошлый код. Ваша задача только переопределить переменную sale_lambda

sale_lambda = lambda n: n * 0.9 if n > 50 else n

# Напишите lambda функцию, которая принимает произвольное количество числовых аргументов и выводит их среднее арифметическое.
# Для проверки решения присвойте вашу lambda функцию переменной average.
# Вводить и выводить ничего не нужно, только определить переменную average

average = lambda *args: sum(args) / len(args)

# Напишите функцию print_results, которая принимает список кортежей. Каждый элемент вложенного кортежа состоит из названия предмета и оценки по нему.
# Функция print_results должна вывести информацию по экзаменам, отсортированную по возрастанию оценок.
# Название каждой пары предмета и оценки печатается на отдельной строке через пробел.
# В случае равенства оценок предметы должны выводиться на экран в том же порядке, в котором они следовали во входном списке

def print_results(lst: list[tuple]):
    for i in sorted(lst, key=lambda x: x[1]):
        print(*i)

# Перепишите функцию print_results так, чтобы информация выводилась по убыванию оценок.
# В случае равенства оценок предметы должны выводиться на экран в том же порядке, в котором они следовали во входном списке

def print_results(lst: list[tuple]):
    [print(*i) for i in sorted(lst, key=lambda x: -x[1])]

# Перепишите функцию print_results так, чтобы информация выводилась по убыванию оценок,
# а в случае их равенства предметы должны выводиться в алфавитном порядке без учета регистра

def print_results(lst: list[tuple]):
    [print(*i) for i in sorted(lst, key=lambda x: (-x[1], x[0].lower()))]

# Перепишите функцию print_results так, чтобы информация выводилась по убыванию оценок,
# а в случае их равенства предметы должны выводиться в обратном алфавитном порядке без учета регистра

def print_results(lst: list[tuple]):
    [print(*i) for i in sorted(lst, key=lambda x: (x[1], x[0].lower()), reverse=True)]

# Напишите функцию get_sort_lines, которая принимает список кортежей, в котором хранится информация о координатах двух точек на координатной прямой.
# Функция get_sort_lines должна вернуть новый список, в котором элементы расположены в порядке возрастания расстояния между точками, хранящимися в одном элементе.
# В случае равенства расстояний необходимо сортировать по возрастанию значения координаты первой точки, затем по возрастанию значения второй точки

def get_sort_lines(lst: list[tuple]):
    return [i for i in sorted(lst, key=lambda x: (max(x) - min(x), x[0], x[1]))]

# Напишите функцию print_goods, которая принимает список словарей. В самих словарях хранится информация о товарах: имя, модель и цвет.
# Задача функции print_goods вывести на экран информацию о товарах  в следующем формате
# Производитель: <make>, модель: <model>, цвет: <color>
# при этом товары должны быть отсортированы по цвету в лексикографическом порядке (по алфавиту) без учета регистра и по убыванию модели (второй критерий сортировки)

def print_goods(lst):
    for i in sorted(lst, key=lambda x: (x['color'].lower(), -x['model'])):
        print(f'Производитель: {i["make"]}, модель: {i["model"]}, цвет: {i["color"]}')

# Поставщик скидывает нашему заказчику информацию о товарах, а он хочет взглянуть на нее в отсортированном виде.
# Заказчик хочет видеть вывод, где вверху самые дорогие товары, внизу самые дешевые.
# Вот только поставщик предоставляет данные в виде списка строк, где каждая строка хранит информацию о товаре в виде
# Название_товара: цена_товара
# Название товара отделено от цены знаком двоеточия :.
# Ваша задача написать функцию print_goods , которая принимает список строк.
# Далее print_goods  должна выводить информацию о товарах, сортируя их сперва по цене, а затем по алфавиту без учета регистра.
# Вывод информации о каждом товаре делается в отдельной строке в следующем формате
# Цена_товара - Название_товара
# Цена должна выводиться с точностью до двух знаком после запятой

def print_goods(lst):
    for goods in sorted(lst, key=lambda x: (-float(x.split(': ')[1]), x.split(': ')[0].lower())):
        item, price = goods.split(': ')
        print(f'{round(float(price), 2):.2f} - {item}')

# Представьте, что мы с вами сами можем решать кому и сколько статуэток Оскара уйдет (Лео бы тогда давно купался в этих статуэтках).
# Ваша задача написать функцию print_best_and_worst_laureate, которая находит информацию, кто из номинантов получил наибольшее и наименьшее количество статуэток.
# Функция print_best_and_worst_laureate принимает на вход словарь, где указана номинация и имя победителя в ней (название фильма или имя актера).
# На основании этой информации функция print_best_and_worst_laureate должна в отдельных строках вывести лауреатов премии,
# набравших наибольшее и наименьшее количество статуэток и через запятую их количество.

from collections import Counter


def print_best_and_worst_laureate(dct):
    tmp = Counter(dct.values())
    print(*sorted(tmp.items(), key=lambda x: x[1])[-1], sep=', ')
    print(*sorted(tmp.items(), key=lambda x: x[1])[0], sep=', ')

# Руководитель таксопарка хочет увидеть отчет по всем таксистам, где нужно указать имя таксиста и его среднюю оценку.
# Информацию в отчете нужно расположить по убыванию средней оценки таксиста. Для этого вам нужно написать функцию print_order_rating,
# которая принимает на вход список кортежей. Каждый кортеж состоит из двух элементов: имя таксиста и оценка за поездку (целое число от 1 до 5).
# Функция print_order_rating должна расположить таксистов в порядке убывания их средней оценки и вывести имя каждого таксиста
# и его среднюю оценку в отдельной строке. В случае совпадения средних оценок нужно расположить каждую группу таксистов, имеющих одинаковый рейтинг,
# по имени в алфавитном порядке без учета регистра

def print_order_rating(dct):
    driver = dict()
    for name, rating in dct:
        driver.setdefault(name, []).append(rating)
    for k, v in sorted(driver.items(), key=lambda x: (-sum(x[1])/len(x[1]), x[0].lower())):
        print(k, sum(v)/len(v))

# В социальных сетях все как обычно: одни люди выкладывают посты, другие их комментируют.
# Сервис по сбору аналитики решил найти у кого из владельцев постов самое большое количество уникальных комментаторов.
# Ваша задача помочь им в этом и собрать нужную информацию. Для это вам потребуется написать функцию print_statistic, которая принимает список кортежей.
# Каждый кортеж состоит из пары значений: автор поста и далее ник пользователя, оставившего комментарий к этому посту.
# Комментаторы могут повторяться и комментировать разных авторов.
# Функция print_statistic должна посчитать для каждого автора его уникальное количество комментаторов.
# Исходя из найденного количества определяется популярность автора. Чем больше уникальных пользователей прокомментировало автора, тем он считается популярнее.
# Затем функция print_statistic должна для каждого автора вывести в порядке уменьшения популярности информацию в следующем виде
# "Количество уникальных комментаторов у <имя героя> - <количество комментаторов>"
# На склонение давайте не будем обращать внимание в этой задаче.
# В случае одинаковой популярности у нескольких авторов, необходимо ранжировать по алфавитному порядку имени авторов без учета регистра

def print_statistic(dct):
    tmp = dict()
    for author, commentator in dct:
        tmp.setdefault(author, []).append(commentator)
    for k, v in sorted(tmp.items(), key=lambda x: (-len(set(x[1])), x[0].lower())):
        print(f'Количество уникальных комментаторов у {k} - {len(set(v))}')

# Напишите функцию get_info_about_object, которая принимает объект и выводит информацию обо всех его атрибутах и методах в следующем формате:
# сперва выводится список всех атрибутов и методов
# на следующей строке фраза «Всего у объекта {count} атрибутов и методов»

def get_info_about_object(obj):
    print(dir(obj), f'Всего у объекта {len(dir(obj))} атрибутов и методов', sep='\n')

# Напишите функцию check_exist_attrs, которая принимает объект obj и список строк, в котором хранятся имена атрибутов.
# Функция check_exist_attrs должна вернуть словарь, в котором ключами будут являться имена атрибутов из переданного списка.
# Напротив каждого ключа должно быть булево значение: True, если атрибут присутствует в объекте obj , в обратном случае - False.
# Ключи в итоговом словаре необходимо создавать в порядке следования имен атрибутов во входном списке

def check_exist_attrs(obj, lst):
    return {i: hasattr(obj, i) for i in lst}

# Напишите функцию create_attrs, которая принимает объект obj и список кортежей.
# Каждый кортеж состоит из пары значений: имя атрибута в виде строки и его будущее значение.
# Задача функции create_attrs — создать на основании внутренних кортежей списка новые атрибуты к переданному объекту.
# Для проверки работоспособности программы скопируйте реализацию функции check_exist_attrs из предыдущего задания

def create_attrs(obj, lst):
    for i in lst:
        setattr(obj, i[0], i[1])


def check_exist_attrs(obj, lst):
    return {i: hasattr(obj, i) for i in lst}

# Ваша задача написать функцию count_strings, которая принимает произвольное количество аргументов.
# Функция должна среди всех переданных значений найти только строки, найти их количество и  вернуть в качестве результата.
# Ваша задача написать только определение функции count_strings

def count_strings(*args):
    return sum([1 for i in args if isinstance(i, str)])

# Ваша задача написать функцию find_keys, которая принимает произвольное количество именованных аргументов.
# Функция должна отобрать только те имена параметров, у которых значения являются списками или кортежами.
# Функция find_keys должна собрать все имена таких параметров в список, отсортировать их по алфавиту вне зависимости от регистра букв и вернуть в качестве результата.
# Ниже представлены примеры:
# find_keys(t=[4, 5], W=[5, 3], A=(3, 2), a={2, 3}, b=[4]) => ['A', 'b', 't', 'W']
# find_keys(name='Bruce', surname='Wayne') => []
# find_keys(marks=[4, 5], name='ashle', surname='Brown', age=20, Also=(1, 2)) => ['Also', 'marks']
# Ваша задача написать только определение функции find_keys

def find_keys(**kwargs):
    return sorted([k for k, v in kwargs.items() if isinstance(v, list | tuple)], key=str.lower)

# Перед вами код из предыдущего задания. Исправьте его так, чтобы на экране появилась строка «hello», затем «bye»

def outer() -> None:
    def say_hello() -> None:
        print('hello')

    def say_bye() -> None:
        print('bye')
        
    say_hello()
    say_bye()


outer()

# Имеется функция wrap_increment, которая должна принимать значение и увеличивать его на 1. Увеличение на один должно выполняться за счет вложенной функции _inc.
# Ваша задача дописать в теле wrap_increment определение функции _inc, которая принимает значение и увеличивает его.

def wrap_increment(value):
    
    def _inc(value):
        return value + 1

    return _inc(value)

# Перед вами вполне работающая функция get_extensions, которая принимает список названий файлов.
# Функция get_extensions находит расширение у названий файлов и составляет из них список, который возвращает в качестве ответа.
# Если у файла нет расширения, то для такого файла get_extensions подставляет пустую строку.
# Ваша задача — произвести рефакторинг данного кода для создания внутренней вспомогательной функции, которая выполняет всю работу по поиску расширения.
# Вы можете, к примеру, назвать ее _get_extension и тогда, определив такую функцию, ей можно пользоваться следующим образом:
# for i in file_list:
#     results.append(_get_extension(i))
# или даже сразу так
# return [_get_extension(i) for i in file_list]
# Перепишите функцию get_extensions с учетом описанных пожеланий по созданию внутренней функции.

def get_extensions(file_list):
    
    def _get_extension(file_list):
        return [i.split(".")[-1] if "." in i else "" for i in file_list]
    
    return _get_extension(file_list)

# Перед вами частично реализованная функция double_odd_numbers, которая принимает список чисел и возвращает в качестве результата новый список,
# составленный из нечетных чисел, увеличенных в два раза.
# Внутри себя double_odd_numbers использует две функции:
# double, увеличивающая число в два раза;
# is_odd, проверяющая на нечетность
# Ваша задача реализовать эти функции внутри  double_odd_numbers

def double_odd_numbers(numbers):
    
    def is_odd(num):
        return num % 2
    
    def double(num):
        return num * 2
    
    return [double(num) for num in numbers if is_odd(num)]

# Пользуясь вложенными функциями, реализуйте простой калькулятор. Для этого необходимо реализовать функцию calculate , которая принимает три параметра:
# - обязательный числовой параметр x
# - обязательный числовой параметр y
# - необязательный строковый параметр operation,  по умолчанию принимает значение английской буквы a
# В данной функции должны быть реализованы следующие функции:
# - addition - сложение двух чисел,
# - subtraction - вычитание из первого переданного параметра второго;
# - division - деление первого на второго,
# - multiplication - умножение двух чисел.
# Каждая из этих четырёх вложенных функций должна распечатать результат математической операции и ничего не возвращать
# А при помощи параметра operation и условного оператора нужно выбрать какая из функций должна быть вызвана:
# если operation = a, вызываем функцию addition;
# если operation = s, вызываем функцию subtraction;
# если operation = d, вызываем функцию division;
# если operation = m, вызываем функцию multiplication;
# calculate(2, 5) # Печатает 7.0
# calculate(2.2, 15, 'a') # Печатает 17.2
# calculate(22, 15, 's') # Печатает 7.0
# calculate(2, 3.2, 'm') # Печатает 6.4
# calculate(10, 0.4, 'd') # Печатает 25.0
# Если operation принимает значение, отличное от перечисленных выше букв, то необходимо вывести на экран  сообщение «Ошибка. Данной операции не существует».
# Также если мы выполняем деление, то второе число (y) не должно равняться нулю, в противном случае необходимо вывести на экран: «На ноль делить нельзя!».
# Вам необходимо написать только определение функции  calculate

def calculate(x, y, operation='a'):
    
    addition = lambda x, y: print(x+y)
    subtraction = lambda x, y: print(x-y)
    division = lambda x, y: print(x/y) if y != 0 else print('На ноль делить нельзя!')
    multiplication = lambda x, y: print(x*y)
    
    match operation:
        case 'a':
            addition(x, y)
        case 's':
            subtraction(x, y)
        case 'd':
            division(x, y)
        case 'm':
            multiplication(x, y)
        case _:
            print('Ошибка. Данной операции не существует')

# Напишите функцию apply, которая принимает функцию и итерируемый объект (например, список) и применяет функцию к каждому элементу итерируемого объекта.
# В качестве ответа функция apply должна вернуть список из вычисленных значений.

def apply(func, lst):
    return [func(i) for i in lst]

# Затем создайте функцию compute, которая принимает список функций и произвольное количество значений.
# Функция compute должна применить каждую функцию к каждому значению в переданном порядке и сформировать из полученных значений новый список,
# который и будет возвращаться в качестве ответа

def compute(func_lst, *args):
    return [func(i) for func in func_lst for i in args]

# Затем создайте функцию compute, которая принимает список функций и произвольное количество значений.
# Функция compute должна применить последовательно в переданном порядке все функции сразу к каждому значению и сформировать из полученных значений новый список,
# который и будет возвращаться в качестве ответа

def compute(func_lst, *args):
    res = []
    for i in args:
        total = i
        for func in func_lst:
            x = func(total)
            total = x
        res.append(total)
    return res

# Напишите функцию filter_list, которая принимает функцию f и список lst.
# Функция f обязательно должна проверять определенное условие и возвращать булев тип.
# Задача функции filter_list состоит в том, чтобы вернуть новый список, составленный из элементов входного lst, отфильтрованных согласно функции f.

def filter_list(f, lst):
    return [i for i in lst if f(i)]

# На основании предыдущей функции filter_list, напишем новую функцию filter_collection.
# Особенность функции filter_collection заключается в том, что она возвращает тот же тип коллекции, который она принимала на вход.
# А остальной принцип  ее работы похож с функцией filter_list: обе принимают функцию f для проверки, при помощи которой фильтруются элементы коллекции
# Функция f обязательно должна проверять определенное условие и возвращать булев тип.

def filter_collection(f, collection):
    if isinstance(collection, str):
        return ''.join([i for i in collection if f(i)])
    elif isinstance(collection, tuple):
        return tuple([i for i in collection if f(i)])
    return [i for i in collection if f(i)]

# Реализуйте функцию aggregation, которая принимает на вход функцию func и коллекцию элементов sequence. Функция func будет принимать только два элемента.
# Задача функции aggregation уметь накапливать результат вычисления функции func путем последовательного применения ее ко всем элементам.
# Но так как функция func умеет работать только с двумя значениями, вам необходимо передавать элементы последовательно парами.
# В результате у вас должен получиться список, в котором копятся результаты работы функции aggregation
# Пример, в качестве func возьмем функцию
# def get_add(x, y):
#     return x + y
# Коллекцией у нас будет следующий список
# numbers = [5, 2, 4, 3, 5]
# Применяя func к первым элементам коллекции 5 и 2, получим сумму 7. Это первое наше агрегированное значение
# Далее берем уже накопленное значение 7 и следующий необработанный элемент 4, суммируем и получаем новую агрегацию 11.
# Затем суммируем нашу агрегацию 11 со значением 3, получаем 14. И в конце добавляем последний элемент и готово итоговое значение 19.
# В итоге в процессе применения функции func мы нашли следующие значения [7, 11, 14, 19]. Данный список и нужно будет вернуть в качестве ответа.

def aggregation(func, sequence):
    res = []
    total = None
    for i in range(len(sequence)-1):
        if total is None:
            total = func(sequence[i], sequence[i+1])
            res.append(total)
        else:
            total = func(total, sequence[i+1])
            res.append(total)
    return res

# Перепишите функцию aggregation так, чтобы она возвращала итоговое значение агрегации.
# Функция aggregation по-прежнему должна принимать на вход функцию func и коллекцию элементов sequence.

def aggregation(func, sequence):
    total = sequence[0]
    while len(sequence) > 1:
        total = func(total, sequence.pop())
    return total

# Перепишите функцию aggregation с прошлого шага так, чтобы у нее появился необязательный параметр initial по умолчанию равный None.
# Данный параметр отвечает за начальное состояние агрегации, если в него передать значение. Если ничего не передавать в initial, то функция aggregation работает как прежде

def aggregation(func, sequence, initial = None):
    if initial is not None:
        sequence.append(initial)
    total = sequence[0]
    while len(sequence) > 1:
        total = func(total, sequence.pop())
    return total

# Ваша задача создать функцию multiply, которая принимает один аргумент.
# Функция должна запомнить это значение и вернуть результат умножения этого числа с переданным вновь значением

def multiply(x):
    
    def inner(y):
        return x * y
    
    return inner

# Ваша задача создать функцию-замыкание make_repeater, которая должна дублировать переданную в нее строку N раз.
# При создании замыкания передается число N - количество для повторения.

def make_repeater(n):
    
    def inner(s):
        return s * n
    
    return inner

# Ваша задача создать функцию-замыкание create_accumulator, которая должна накапливать (суммировать) внутри себя все значения, которые ей будут переданы.
# При создании замыкания стартовая сумма должна быть равна нулю. Посмотрите пример ниже:
# summator_1 = create_accumulator()
# print(summator_1(1)) # печатает 1
# print(summator_1(5)) # печатает 6
# print(summator_1(2)) # печатает 8
# summator_2 = create_accumulator()
# print(summator_2(3)) # печатает 3
# print(summator_2(4)) # печатает 7
# При каждом вызове должна возвращаться накопленная сумма, которая хранится в замыкании.
# Обратите внимание, что объекты из примера summator_1 и summator_2 хранят и накапливают свои собственные суммы.
# Необходимо только определить функцию-замыкание create_accumulator, остальное мы сделаем за вас

def create_accumulator():
    
    total = 0

    def inner(x):
        nonlocal total
        total += x
        return total
    
    return inner

# На предыдущем шаге мы реализовали функцию-замыкание create_accumulator, которая накапливала сумму, начиная с нуля.
# Давайте ее усовершенствуем, чтобы она могла начинать суммировать, начиная с определенного значения.
# Это значение мы ей будем передавать, но оно является необязательным.  Посмотрите пример ниже:
# summator_1 = create_accumulator(100)
# print(summator_1(1)) # печатает 101
# print(summator_1(5)) # печатает 106
# print(summator_1(2)) # печатает 108
# summator_2 = create_accumulator()
# print(summator_2(3)) # печатает 3
# print(summator_2(4)) # печатает 7
# Во втором примере мы не передали значение и значит сумма по умолчанию должна считаться с нуля.
# Необходимо только определить функцию-замыкание create_accumulator, остальное мы сделаем за вас

def create_accumulator(n=0):
    
    total = n

    def inner(x):
        nonlocal total
        total += x
        return total
    
    return inner

# Напишите функцию-замыкание countdown, которая будет вести обратный отсчёт от переданного числа N до нуля.
# После того как замыкание будет вызвано более N раз, необходимо выводить сообщение «Превышен лимит, вы вызвали более N раз»

def countdown(n):
    
    total = n

    def inner():
        nonlocal total
        result = total if total > 0 else f'Превышен лимит, вы вызвали более {n} раз'
        print(result)
        total -= 1
        
    return inner

# В этом задании вам нужно сделать функцию-замыкание count_calls, которая подсчитывает сколько раз она была вызвана.
# Особенность этого замыкания заключается в том, что количество вызовов должно храниться в атрибуте total_calls.

def count_calls():
    

    def inner():
        inner.total_calls += 1
        return inner.total_calls
    
    inner.total_calls = 0
    
    return inner

# Ваша задача — создать функцию-замыкание create_dict. Функция create_dict должна сохранять в себе в виде словаря все значения, которые ей будут переданы.
# Ключами данного словаря должны быть натуральные числа, равные номеру вызова данной функции. Посмотрите пример ниже:
# f_1 = create_dict()
# print(f_1('hello')) # f_1 возвращает {1: 'hello'}
# print(f_1(100)) # f_1 возвращает {1: 'hello', 2: 100}
# print(f_1([1, 2, 3])) # f_1 возвращает {1: 'hello', 2: 100, 3: [1, 2, 3]}
# f_2 = create_dict() # создаем новое замыкание в f_2
# print(f_2('PoweR')) # f_2 возвращает {1: 'PoweR'}
# Вызывая первый раз f_1 мы создали пару 1: 'hello', вызывая второй раз добавилась пара 2: 100. и т.д.
# При каждом вызове должен возвращаться словарь, хранящийся в замыкании
# Необходимо только определить функцию-замыкание create_dict, остальное мы сделаем за вас

def create_dict():
    
    count = 0
    dct = dict()

    def inner(value):
        nonlocal count
        count += 1
        dct.setdefault(count, value)
        return dct
    
    return inner

# Перед вами декоратор uppercase , который преобразует к заглавному регистру все буквы результата оригинальной функции
# Ваша задача задекорировать функцию calculate_tax декоратором uppercase, чтобы в трех принтах мы уже увидели результат задекорированной функции.

def uppercase(func):
    def inner(n, i, rate):
        res = func(n, i, rate)
        return res.upper()

    return inner


@uppercase
def calculate_tax(name, income, tax_rate):
    tax = income - income * (1 - tax_rate / 100)
    return f'{name} должен заплатить налог {tax}$'


print(calculate_tax("Ivan", 5000, 25))
print(calculate_tax("vaSilIy", 15000, 30))
print(calculate_tax("depardieu", 215000, 40))

# Программист Кузьма познакомился с декораторами и решил написать свой первый пример, где он пытался сопроводить вызов функции add дополнительными выводами на экран.
# Вот что получилось:
# def decorator(func):
#     def wrapper():
#         print('---Start calculation---')
#         result = func()
#         print(f'---Finish calculation. Result is {result}---')
#         return result
#     return wrapper
#
# @decorator
# def add(a, b):
#     return a + b
# По его задумке декоратор должен сопровождать вызов декорируемой функции сообщениями
# ---Start calculation---
#
# и
#
# ---Finish calculation. Result is {result}---
# Но во время тестирования функции add Кузьма столкнулся с ошибкой
# takes 0 positional arguments but 2 were given
# Помогите исправить его декоратор так, чтобы все заработало.

def decorator(func):
    def wrapper(*args, **kwargs):
        print('---Start calculation---')
        result = func(*args, **kwargs)
        print(f'---Finish calculation. Result is {result}---')
        return result
    return wrapper


@decorator
def add(a, b):
    return a + b

# Теперь убедитесь, что декоратор Кузьмы из предыдущего задания успешно работает и с другими функциями, вне зависимости от количества аргументов и их типов.
# Для решения задачи вам необходимо написать только определение функции-декоратора decorator.

def decorator(func):
    def wrapper(*args, **kwargs):
        print('---Start calculation---')
        result = func(*args, **kwargs)
        print(f'---Finish calculation. Result is {result}---')
        return result
    return wrapper

# Напишите декоратор repeater, который трижды вызывает декорированную функцию
# Ваша задача написать только определение функции декоратора repeater

def repeater(func):
    def wrapper(*args, **kwargs):
        for _ in range(3):
            func(*args, **kwargs)
    return wrapper

# Напишите декоратор double_it, который возвращает удвоенный результат вызова декорированной функции
# Ваша задача написать только определение функции декоратора double_it

def double_it(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs) * 2
    return wrapper

# Ваша задача написать логику работы декоратора uppercase_elements, который умеет работать с функциями, возвращающими коллекции элементов.
# Задача декоратора uppercase_elements преобразовать каждый строковый элемент коллекции к заглавному регистру.
# В случае, если оригинальная функция возвращает словарь, то элементом считаем только строковые ключи словаря.
# Элементы, не являющиеся строкой, не должны изменяться декоратором uppercase_elements
# Гарантируется, что коллекции, возвращаемые оригинальной функцией, не являются вложенными

def uppercase_elements(func):
    def wrapper(*args, **kwargs):
        res = func(*args, **kwargs)
        if not isinstance(res, dict):
            return [i.upper() if isinstance(i, str) else i for i in res]
        return {k.upper() if isinstance(k, str) else k: v for k, v in res.items()}
    return wrapper

# Перед вами реализация двух функций-декораторов  first_validator и second_validator. Также имеется функция sum_values.
# Вам необходимо сперва проанализировать имеющийся код и разобраться, как он работает.
# После этого вашей задачей является:
#    ✔️ наложить два декоратора на функцию sum_values в правильной последовательности;
#    ✔️ вызвать задекорированную функцию sum_values подобрав аргументы так, чтобы совпал вывод результата.
# Код самих функций менять не нужно.

def first_validator(func):
    def my_wrapper(*args, **kwargs):
        print("Начинаем важную проверку")
        if len(args) == 3:
            func(*args, **kwargs)
        else:
            print("Важная проверка не пройдена")
            return None
        print("Заканчиваем важную проверку")

    return my_wrapper


def second_validator(func):
    def my_wrapper(*args, **kwargs):
        print("Начинаем самую важную проверку")
        if kwargs.get('name') == 'Boris':
            func(*args)
        else:
            print("Самая важная проверка не пройдена")
            return None
        print("Заканчиваем самую важную проверку")

    return my_wrapper


@second_validator
@first_validator
def sum_values(*args):
    print(f'Получили результат равный {sum(args)}')


sum_values(1, 1, 75, name='Boris')

# Напишите декоратор validate_all_args_str, который проверяет на корректность (валидирует) переданные позиционные аргументы.
# Корректным он считает любое строковое значение, стоящее в позиционном аргументе; ключевые аргументы при проверке игнорируются.
# Если было передано хотя бы одно не строковое значение в позиционный аргумент, функция-декоратор validate_all_args_str должна:
#  - вывести на экран фразу «Все аргументы должны быть строками»
#  - вернуть None и не запускать оригинальную  функцию
# Если же все аргументы корректны, validate_all_args_str запускает оригинальную функцию со всеми переданными значениями.

def validate_all_args_str(func):
    def wrapper(*args, **kwargs):
        for arg in args:
            if not isinstance(arg, str):
                print('Все аргументы должны быть строками')
                return
        return func(*args, **kwargs)
    return wrapper

# Напишите декоратор validate_all_kwargs_int_pos, который проверяет на корректность переданные именованные аргументы.
# Корректным будет считаться именованный аргумент, значение которого является целым положительным числом.
# Позиционные аргументы игнорируются во время проверки декоратора validate_all_kwargs_int_pos.
# Если было передано хотя бы одно некорректное значение в именованный аргумент, функция-декоратор validate_all_kwargs_int_pos должна:
#  - вывести на экран фразу «Все именованные аргументы должны быть положительными числами»;
#  - вернуть None и не запускать оригинальную  функцию.
# Если же все аргументы корректны, validate_all_kwargs_int_pos запускает оригинальную функцию со всеми переданными значениями.
# Также для проверки вам необходимо скопировать из предыдущего шага реализацию декоратора validate_all_args_str,
# потому что в проверках будет использоваться валидация сразу и на *args, и на **kwargs.

def validate_all_kwargs_int_pos(func):
    def wrapper(*args, **kwargs):
        if all(isinstance(kwarg, int) and kwarg > 0 for kwarg in kwargs.values()):
            return func(*args, **kwargs)
        print('Все именованные аргументы должны быть положительными числами')
        return
    return wrapper

# Ваша задача создать два декоратора:
#     1️⃣ filter_even, который фильтрует только позиционные аргументы.
#        Среди всех переданных значений он оставляет только четные числа, False и коллекции, длина которых четная
#     2️⃣ delete_short, который фильтрует только именованные аргументы.
#        Среди всех переданных значений он оставляет только те, имена которых более четырех символов

def filter_even(func):
    def wrapper(*args, **kwargs):
        args = [
            arg
            for arg in args
            if arg is False
            or (isinstance(arg, (str, list, tuple, dict)) and len(arg) % 2 == 0)
            or (isinstance(arg, int) and int(arg) % 2 == 0)
        ]
        return func(*args, **kwargs)

    return wrapper


def delete_short(func):
    def wrapper(*args, **kwargs):
        kwargs = {k: v for k, v in kwargs.items() if len(k) > 4}
        return func(*args, **kwargs)

    return wrapper

# Отредактируйте код так, чтобы сохранялись оригинальное имя и док строка декорируемой функции
# Сделайте это без использования функции wraps.

def upper(func):
    def inner(*args, **kwargs):
        """
        Внутренняя функция декоратора
        """
        return func(*args, **kwargs).upper()
    
    inner.__name__ = func.__name__
    inner.__doc__ = func.__doc__
    inner.__annotations__ = func.__annotations__
    
    return inner


@upper
def concatenate(*args):
    """
    Возвращает конкатенацию переданных строк
    """
    return ', '.join(args)

print(concatenate.__name__)
print(concatenate.__doc__.strip())

# Напишите декоратор limit_query, который ограничивает вызов оригинальной функции так, чтобы она могла вызываться не больше трех раз.
# Когда декорируемая функция исчерпает лимит вызовов, необходимо выводить на экран фразу «Лимит вызовов закончен, все 3 попытки израсходованы»
# Если лимит исчерпан, оригинальная функция не должна быть вызвана, декоратор возвращает None

def limit_query(func):
    count = 0
    def wrapper(*args, **kwargs):
        nonlocal count
        count += 1
        if count > 3:
            print('Лимит вызовов закончен, все 3 попытки израсходованы')
            return
        else:
            return func(*args, **kwargs)
    
    wrapper.__name__ = func.__name__
    return wrapper


# Напишите декоратор no_side_effects_decorator, который защищает от побочных действий функций

from copy import deepcopy
from functools import wraps


def no_side_effects_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        new_args = deepcopy(args)
        return func(*new_args, **kwargs)
    return wrapper

# Напишите декоратор add_args, который добавляет к переданным аргументам еще два значения: строку «begin» в начало аргументов, строку «end» в конец.
# Также декоратор должен сохранить первоначальное имя декорируемой функции и ее строку документации

from functools import wraps


def add_args(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        args = ('begin',) + args + ('end',)
        return func(*args, **kwargs)
    return wrapper

# Реализуйте декоратор explicit_args, который не позволяет запускать оригинальную функцию, если были переданы позиционные аргументы.
# Декоратор explicit_args должен выводить фразу:
# Вы не можете передать позиционные аргументы. Используйте именованный способ передачи значений
# и предотвращать запуск оригинальной функции

from functools import wraps


def explicit_args(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        if args:
            print('Вы не можете передать позиционные аргументы. Используйте именованный способ передачи значений')
            return
        return func(**kwargs)
    return wrapper

# Реализуйте декоратор reverse, который сделает так, чтобы декорированная функция принимала все свои позиционные аргументы в обратном порядке.
# Именованные аргументы должны игнорироваться декоратором reverse. Также нужно сохранить информацию о декорируемой функции.

from functools import wraps


def reverse(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        return func(*args[::-1])
    return wrapper

# Monkey patch -  это прием в программировании, который используется для динамического изменения поведения фрагмента кода во время выполнения.
# Ваша задача написать декоратор monkey_patching, который заменяет значения всех переданных аргументов при вызове оригинальной функции следующим образом:
#     ➕   значение каждого позиционного аргумента заменяется на строку «Monkey»
#     ➕   значение каждого именованного аргумента заменяется на строку «patching»

from functools import wraps


def monkey_patching(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        args = [str(arg).replace(str(arg), 'Monkey') for arg in args]
        kwargs = {k: str(v).replace(str(v), 'patching') for k, v in kwargs.items()}
        return func(*args, **kwargs)
    return wrapper

# Реализуйте декоратор counting_calls, который будет подсчитывать количество вызовов оригинальной функции.
# После декорирования при помощи counting_calls у функции должен появиться атрибут call_count, который отслеживает текущее количество вызовов.

from functools import wraps


def counting_calls(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        wrapper.call_count += 1
        return func(*args, **kwargs)
    wrapper.call_count = 0
    return wrapper

# Напишите декоратор check_count_args, который проверяет количество переданных аргументов. Проверка заключается в следующем:
#  - в оригинальную функцию должно быть передано только два аргумента и неважно позиционно или по ключу.
#    Если это условие выполняется, возвращаем результат вызова оригинальной функции
#  - Если передано меньшее количество, декоратор должен вывести строку «Not enough arguments» и не должен запускать оригинальную функцию;
#  - Если передано более двух аргументов, то декоратор должен вывести строку «Too many arguments» и не должен запускать оригинальную функцию.
# Не забывайте сохранять имя функции и строку документации. Для решения необходимо написать только реализацию декоратора check_count_args

from functools import wraps


def check_count_args(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        if len(args) + len(kwargs) > 2:
            print('Too many arguments')
            return
        elif len(args) + len(kwargs) < 2:
            print('Not enough arguments')
            return
        return func(*args, **kwargs)
    return wrapper

# Кэширование – это способ оптимизации работы приложения, при котором повторно запрашиваемые данные сохраняются и далее используются
# для обслуживания последующих запросов. Кешом называется место, куда будут сохраняться данные после первого вызова.
# Ваша задача написать декоратор cache_result, который оптимизирует производительность за счет сохранения и извлечения результатов функций,
# устраняя избыточные вычисления для повторяющихся входных данных и улучшая скорость отклика приложения, особенно для длительных вычислений.
# Декоратор cache_result должен сохранять результат вызова оригинальной функции с учетом передаваемых аргументов.
# При повторном вызове функции с теми же аргументами, результат должен возвращаться из кеша, предварительно сопроводив выводом следующего текста на экран
# [FROM CACHE] Вызов {имя_функции} = {результат_из_кеша}
# Ваша задача написать только функцию-декоратор cache_result

from functools import wraps

cache = dict()


def cache_result(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        if cache.get(args) is None:
            cache[args] = func(*args, **kwargs)
            return func(*args, **kwargs)
        else:
            print(f'[FROM CACHE] Вызов {wrapper.__name__} = {cache.get(args)}')
            return cache.get(args)
    return wrapper

# Усовершенствуем ранее созданный декоратор counting_calls, добавив отслеживание переданных аргументов при каждом вызове.
# Для этого декоратор counting_calls должен добавить в декорируемой функции атрибут calls - список,
# в который будут сохраняться все переданные аргументы в момент вызова в виде словаря.
# Каждый словарь должен иметь два ключа: args и kwargs для сохранения соответствующих аргументов.

from functools import wraps


def counting_calls(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        wrapper.call_count += 1
        wrapper.calls.append({'args': args, 'kwargs': kwargs})
        return func(*args, **kwargs)
    wrapper.call_count = 0
    wrapper.calls = list()
    return wrapper

# Создайте декоратор multiply_result_by, который принимает аргумент N и возвращает функцию-декоратор, которая умножает результат декорированной функции на N

from functools import wraps


def multiply_result_by(n):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs) * n
        return wrapper
    return decorator

# Ваша задача переписать декоратор limit_query так, чтобы он ограничивал разрешенное количество вызовов оригинальной функции по переданному параметру limit.
# Когда декорируемая функция исчерпает лимит вызовов, необходимо выводить на экран фразу:
# «Лимит вызовов закончен, все <limit> попытки израсходованы»
# Если лимит исчерпан, оригинальная функция не должна быть вызвана, декоратор возвращает None

from functools import wraps


def limit_query(limit):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            wrapper.count += 1
            if wrapper.count > limit:
                print(f'Лимит вызовов закончен, все {limit} попытки израсходованы')
                return
            else:
                return func(*args, **kwargs)
        wrapper.count = 0
        return wrapper
    return decorator

# Ваша задача переписать декоратор monkey_patching. Ранее он заменял значения всех переданных аргументов при вызове оригинальной функции следующим образом:
#     ➕   значение каждого позиционного аргумента заменяется на строку «Monkey»
#     ➕   значение каждого именованного аргумента заменяется на строку «patching»
# Теперь необходимо завести параметры arg и kwarg, при помощи которых можно влиять на значения, которые будут проставляться в позиционные и именованные аргументы.
# Параметры arg и kwarg являются необязательными для передачи, их значения по умолчанию «Monkey» и «patching» соответственно.

from functools import wraps


def monkey_patching(arg='Monkey', kwarg='patching'):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            args = [str(a).replace(str(a), arg) for a in args]
            kwargs = {k: str(v).replace(str(v), kwarg) for k, v in kwargs.items()}
            return func(*args, **kwargs)
        return wrapper
    return decorator

# Ваша задача написать параметризированный декоратор pass_arguments, который принимает произвольное количество именованных и позиционных аргументов
# и пробрасывает их дополнительно к аргументам, которые передаются при вызове оригинальной функции

from functools import wraps


def pass_arguments(*arg, **kwarg):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            args += arg
            kwargs.update(kwarg)
            return func(*args, **kwargs)
        return wrapper
    return decorator

# Напишите декоратор convert_to, который позволяет автоматически преобразовать возвращаемое значение в указанный тип данных.
# Функция-декоратор convert_to имеет обязательный параметр type_, в который необходимо передать тип данных для дальнейшего преобразования.

from functools import wraps


def convert_to(type_):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            return type_(func(*args, **kwargs))
        return wrapper
    return decorator

# Помните декоратор validate_all_args_str, который проверял, что все переданные позиционные значения являются строками?
# А если вдруг нам потребуется создать декоратор, который будет проверять аргументы не на принадлежность к строке, а, скажем, к списку или числу?
# Тогда нам понадобится создавать отдельный декоратор на каждый тип данных. Или сделать параметризированный декоратор validate_all_args,
# который будет принимать тип данных в качестве аргумента и проверять, что все значения в args относятся к переданному типу данных.
# Ваша задача написать такой декоратор validate_all_args, который имеет параметр type_. Если все позиционные аргументы принадлежат типу type_,
# то запускается оригинальная функция; в противном случае необходимо отменить ее запуск и вывести сообщение:
# Все аргументы должны принадлежать типу {type_}

def validate_all_args(type_):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for arg in args:
                if not isinstance(arg, type_):
                    print(f'Все аргументы должны принадлежать типу {type_}')
                    return
            return func(*args, **kwargs)
        return wrapper
    return decorator

# Ваша задача написать параметризированный декоратор compose,
# который принимает произвольное количество функций и применяет их последовательно к результату декорируемой функции

from functools import wraps


def compose(*funcs):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            res = func(*args, **kwargs)
            for f in funcs:
                res = f(res)
            return res
        return wrapper
    return decorator

# Ваша задача написать параметризированный декоратор add_attrs,
# который принимает произвольное количество именованных аргументов и на их основании добавляет новые атрибуты для оригинальной функции

from functools import wraps


def add_attrs(**attrs):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for k, v in attrs.items():
                setattr(wrapper, k, v)
            return func(*args, **kwargs)
        return wrapper
    return decorator