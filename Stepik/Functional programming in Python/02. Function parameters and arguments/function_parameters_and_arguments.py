# Перепишите функцию powers из предыдущего урока так, чтобы она вместо кортежа возвращала список

def powers(num):
    square = num**2
    cube = num**3
    return [num, square, cube]

# Перед вами имеется практически готовый код, который позволяет определять достиг ли гражданин совершеннолетия или нет.
# Всю ответственность за проверку взяла на себя функция is_adult, она принимает возраст человека и должна вернуть ответ на вопрос,
# является ли он совершеннолетним, при условии что совершеннолетие наступает с 18 лет.
# Сейчас тело функции is_adult является пустым и ваша задача его написать.

def is_adult(age):
    return age > 17


a = int(input())
if is_adult(a):
    print('Ух какой большой')
else:
    print('Подрасти еще, сынок')

# Напишите функцию is_leap, которая проверяет является ли переданный год високосным или нет.
# Високосным является год, номер которого делится на 4, но не делится на 100, или же номер которого делится на 400.
# Напишите только определение функции is_leap

def is_leap(year):
    if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:
        return True
    return False

# Определите функцию is_palindrome, которая принимает строку и отвечает на вопрос, является ли она палиндромом или нет
# Палиндромами считаются слова, которые читаются одинаково слева направо и справа налево, как например слово «радар»
# При проверке не нужно учитывать регистр букв. Это значит, что слова «радар» и «Радар» считаются одинаковыми.
# Также во входной строке могут встречаться пробелы, их необходимо исключить из проверки. Остальные знаки пунктуации, такие как запятые, точки, дефисы и т.д., во входных данных отсутствуют.

def is_palindrome(s):
    return [j.lower() for i in s.split() for j in i] == [j.lower() for i in s.split()[::-1] for j in i[::-1]]

# Напишите функцию count_leap_years, которая принимает два года y1 и y2, причем y1 <= y2, и возвращает количество високосных лет в промежутке от y1 включительно до  y2 не включительно.
# При реализации функции count_leap_years используйте ранее созданную функцию is_leap.
# Напишите только определения необходимых функций.

def is_leap(year):
    return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0


def count_leap_years(year1, year2):
    return sum([1 for i in range(year1, year2) if is_leap(i)])

# Напишите функцию get_leap_years, которая принимает два года y1 и y2, причем y1 <= y2, и возвращает список, состоящий из високосных лет в промежутке от y1 включительно до  y2 не включительно.
# Года должны располагаться в нем в хронологическом порядке. При реализации функции get_leap_years используйте ранее созданную функцию is_leap.
# Напишите только определения необходимых функций.

def is_leap(year):
    return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0


def get_leap_years(year1, year2):
    return [i for i in range(year1, year2) if is_leap(i)]

# Определите функцию create_palindrome, которая принимает строку и возвращает результат в зависимости от следующих условий:
# - Если переданная строка уже является палиндромом вне зависимости от регистра букв, вернуть ее, преобразовав все символы к нижнему регистру, иначе идем к следующему пункту
# - Создать палиндром по следующему формату {str}_i_{reverse_str}, где str - переданная строка, а reverse_str ее перевернутое значение.
# Верните вновь созданный палиндром в качестве ответа, преобразовав все символы к нижнему регистру

def create_palindrome(s):
    s = s.replace(' ', '').lower()
    if s == s[::-1]:
        return s
    return f'{s}_i_{s[::-1]}'

# Напишите функцию is_strings_equal, которая принимает две строки в качестве аргументов и сравнивает их между собой.
# Строки считаются равными, если они имеют одинаковую длину и одинаковые символы в равном количестве вне зависимости от их расположения.
# Функция is_strings_equal должна вернуть True, если строки равны, в противном случае - False.

def is_strings_equal(s1, s2):
    return sorted(s1) == sorted(s2)

# «Dunder» происходит от «double underscore», что переводится как двойное подчеркивание.
# В python существуют специальные методы, которые позволяют объектам хорошо взаимодействовать со многими встроенными функциями языка.
# Такие методы называют магическими или dunder-методами, потому что их имена начинаются и заканчиваются на __.
# Примерами таких методов являются __str__, __repr__, __bool__ и т.д.
# Подробнее о самих магических методах мы будем разговаривать в курсе «ООП: Объектно-ориентированное программирование»
# Сейчас ваша задача — написать функцию is_dunder, которая по названию метода помогает определить, подходит ли оно под «dunder» название или нет.
# Само имя метода (без учета двух нижних подчеркиваний в начале и в конце) должно состоять только из букв и иметь длину не меньше двух символов.
# Результатом функции is_dunder должно быть значение True, если переданное значение подходит под наименование dunder-метода, False в противном случае.

def is_dunder(s):
    return len(s.split('__')[1]) >= 2 and s.split('__')[1].isalpha()

# Напишите функцию words_length, которая по входному списку слов создает список целых чисел,
# составленный из длины соответствующих слов и возвращает его в качестве результата.

def words_length(words):
    return [len(word) for word in words]

# Напишите функцию filter_long_words, которая принимает список слов и целое число N и возвращает список слов, длина которых больше чем число N

def filter_long_words(words, n):
    return [word for word in words if len(word) > n]

# Напишите функцию is_member, которая принимает некое значение value и список значений lst.
# Функция is_member должна вернуть True, если значение value присутствует в списке lst, и False в противном случае.
# Гарантируется, что список lst не будет вложенным

def is_member(value, lst):
    return value in lst

# Определите функцию overlapping, которая принимает два списка и возвращает True, если у них есть хотя бы один общий элемент, в противном случае — False.
# ВЫ можете решать задачу удобным для вас способом, но попробуйте реализовать с использованием функции is_member из предыдущего шага.

def is_member(value, lst):
    return value in lst

def overlapping(lst1, lst2):
    return any(is_member(i, lst1) for i in lst2)

# Напишите функцию find_longest_word_len, которая принимает список слов и возвращает длину самого длинного из них.

def find_longest_word_len(words):
    return max([len(word) for word in words])

# Напишите функцию register_check, которая проверяет сколько человек успешно прошло регистрацию на мероприятие.
# Функция принимает словарь в качестве параметра, состоящий из имен людей(ключи) и результатов регистрации(значения ключа).
# Если человек успешно прошел регистрацию, то в словаре напротив его имени хранится значение «yes», иначе «no».
# Функция register_check должна возвращать количество только тех людей, кто успешно зарегистрировался.

def register_check(people):
    return len({k:v for k, v in people.items() if v == 'yes'})

# Напишите функцию create_tuples, которая принимает два списка одинаковой длины и объединяет их в список кортежей.
# Элемент кортежа получается путем соединения элемента первого и второго списков, стоящих на одинаковых позициях

def create_tuples(lst1, lst2):
    return [(i, j) for i, j in zip(lst1, lst2)]

# В HTML используются специальные теги для определения заголовков в веб-странице.
# Всего существует шесть тегов заголовков HTML:
# <h1> - заголовок первого уровня;
# <h2> - заголовок второго уровня;
# <h3> - заголовок третьего уровня;
# <h4> - заголовок четвертого уровня;
# <h5> - заголовок пятого уровня;
# <h6> - заголовок шестого уровня.
# Разница между заголовками только в размере, на картинке можно наглядно это увидеть.
# Ваша задача — создать функцию make_header, которая принимает два параметра:
# - text - строка, которую нужно обернуть в тег заголовка;
# - level - целое число, обозначающее уровень заголовка.
# Функция make_header должна возвращать переданную строку, обернутую в тег заголовка определенного уровня.
# Ваша задача — написать только определение функции make_header

def make_header(text, level):
    return f'<h{level}>{text}</h{level}>'