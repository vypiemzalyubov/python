# Перепишите функцию powers из предыдущего урока так, чтобы она вместо кортежа возвращала список

def powers(num):
    square = num**2
    cube = num**3
    return [num, square, cube]

# Перед вами имеется практически готовый код, который позволяет определять достиг ли гражданин совершеннолетия или нет.
# Всю ответственность за проверку взяла на себя функция is_adult, она принимает возраст человека и должна вернуть ответ на вопрос,
# является ли он совершеннолетним, при условии что совершеннолетие наступает с 18 лет.
# Сейчас тело функции is_adult является пустым и ваша задача его написать.

def is_adult(age):
    return age > 17


a = int(input())
if is_adult(a):
    print('Ух какой большой')
else:
    print('Подрасти еще, сынок')

# Напишите функцию is_leap, которая проверяет является ли переданный год високосным или нет.
# Високосным является год, номер которого делится на 4, но не делится на 100, или же номер которого делится на 400.
# Напишите только определение функции is_leap

def is_leap(year):
    if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:
        return True
    return False

# Определите функцию is_palindrome, которая принимает строку и отвечает на вопрос, является ли она палиндромом или нет
# Палиндромами считаются слова, которые читаются одинаково слева направо и справа налево, как например слово «радар»
# При проверке не нужно учитывать регистр букв. Это значит, что слова «радар» и «Радар» считаются одинаковыми.
# Также во входной строке могут встречаться пробелы, их необходимо исключить из проверки. Остальные знаки пунктуации, такие как запятые, точки, дефисы и т.д., во входных данных отсутствуют.

def is_palindrome(s):
    return [j.lower() for i in s.split() for j in i] == [j.lower() for i in s.split()[::-1] for j in i[::-1]]

# Напишите функцию count_leap_years, которая принимает два года y1 и y2, причем y1 <= y2, и возвращает количество високосных лет в промежутке от y1 включительно до  y2 не включительно.
# При реализации функции count_leap_years используйте ранее созданную функцию is_leap.
# Напишите только определения необходимых функций.

def is_leap(year):
    return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0


def count_leap_years(year1, year2):
    return sum([1 for i in range(year1, year2) if is_leap(i)])

# Напишите функцию get_leap_years, которая принимает два года y1 и y2, причем y1 <= y2, и возвращает список, состоящий из високосных лет в промежутке от y1 включительно до  y2 не включительно.
# Года должны располагаться в нем в хронологическом порядке. При реализации функции get_leap_years используйте ранее созданную функцию is_leap.
# Напишите только определения необходимых функций.

def is_leap(year):
    return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0


def get_leap_years(year1, year2):
    return [i for i in range(year1, year2) if is_leap(i)]

# Определите функцию create_palindrome, которая принимает строку и возвращает результат в зависимости от следующих условий:
# - Если переданная строка уже является палиндромом вне зависимости от регистра букв, вернуть ее, преобразовав все символы к нижнему регистру, иначе идем к следующему пункту
# - Создать палиндром по следующему формату {str}_i_{reverse_str}, где str - переданная строка, а reverse_str ее перевернутое значение.
# Верните вновь созданный палиндром в качестве ответа, преобразовав все символы к нижнему регистру

def create_palindrome(s):
    s = s.replace(' ', '').lower()
    if s == s[::-1]:
        return s
    return f'{s}_i_{s[::-1]}'

# Напишите функцию is_strings_equal, которая принимает две строки в качестве аргументов и сравнивает их между собой.
# Строки считаются равными, если они имеют одинаковую длину и одинаковые символы в равном количестве вне зависимости от их расположения.
# Функция is_strings_equal должна вернуть True, если строки равны, в противном случае - False.

def is_strings_equal(s1, s2):
    return sorted(s1) == sorted(s2)

# «Dunder» происходит от «double underscore», что переводится как двойное подчеркивание.
# В python существуют специальные методы, которые позволяют объектам хорошо взаимодействовать со многими встроенными функциями языка.
# Такие методы называют магическими или dunder-методами, потому что их имена начинаются и заканчиваются на __.
# Примерами таких методов являются __str__, __repr__, __bool__ и т.д.
# Подробнее о самих магических методах мы будем разговаривать в курсе «ООП: Объектно-ориентированное программирование»
# Сейчас ваша задача — написать функцию is_dunder, которая по названию метода помогает определить, подходит ли оно под «dunder» название или нет.
# Само имя метода (без учета двух нижних подчеркиваний в начале и в конце) должно состоять только из букв и иметь длину не меньше двух символов.
# Результатом функции is_dunder должно быть значение True, если переданное значение подходит под наименование dunder-метода, False в противном случае.

def is_dunder(s):
    return len(s.split('__')[1]) >= 2 and s.split('__')[1].isalpha()

# Напишите функцию words_length, которая по входному списку слов создает список целых чисел,
# составленный из длины соответствующих слов и возвращает его в качестве результата.

def words_length(words):
    return [len(word) for word in words]

# Напишите функцию filter_long_words, которая принимает список слов и целое число N и возвращает список слов, длина которых больше чем число N

def filter_long_words(words, n):
    return [word for word in words if len(word) > n]

# Напишите функцию is_member, которая принимает некое значение value и список значений lst.
# Функция is_member должна вернуть True, если значение value присутствует в списке lst, и False в противном случае.
# Гарантируется, что список lst не будет вложенным

def is_member(value, lst):
    return value in lst

# Определите функцию overlapping, которая принимает два списка и возвращает True, если у них есть хотя бы один общий элемент, в противном случае — False.
# ВЫ можете решать задачу удобным для вас способом, но попробуйте реализовать с использованием функции is_member из предыдущего шага.

def is_member(value, lst):
    return value in lst

def overlapping(lst1, lst2):
    return any(is_member(i, lst1) for i in lst2)

# Напишите функцию find_longest_word_len, которая принимает список слов и возвращает длину самого длинного из них.

def find_longest_word_len(words):
    return max([len(word) for word in words])

# Напишите функцию register_check, которая проверяет сколько человек успешно прошло регистрацию на мероприятие.
# Функция принимает словарь в качестве параметра, состоящий из имен людей(ключи) и результатов регистрации(значения ключа).
# Если человек успешно прошел регистрацию, то в словаре напротив его имени хранится значение «yes», иначе «no».
# Функция register_check должна возвращать количество только тех людей, кто успешно зарегистрировался.

def register_check(people):
    return len({k:v for k, v in people.items() if v == 'yes'})

# Напишите функцию create_tuples, которая принимает два списка одинаковой длины и объединяет их в список кортежей.
# Элемент кортежа получается путем соединения элемента первого и второго списков, стоящих на одинаковых позициях

def create_tuples(lst1, lst2):
    return [(i, j) for i, j in zip(lst1, lst2)]

# В HTML используются специальные теги для определения заголовков в веб-странице.
# Всего существует шесть тегов заголовков HTML:
# <h1> - заголовок первого уровня;
# <h2> - заголовок второго уровня;
# <h3> - заголовок третьего уровня;
# <h4> - заголовок четвертого уровня;
# <h5> - заголовок пятого уровня;
# <h6> - заголовок шестого уровня.
# Разница между заголовками только в размере, на картинке можно наглядно это увидеть.
# Ваша задача — создать функцию make_header, которая принимает два параметра:
# - text - строка, которую нужно обернуть в тег заголовка;
# - level - целое число, обозначающее уровень заголовка.
# Функция make_header должна возвращать переданную строку, обернутую в тег заголовка определенного уровня.
# Ваша задача — написать только определение функции make_header

def make_header(text, level):
    return f'<h{level}>{text}</h{level}>'

# Панграмма — это предложение, которое содержит все буквы алфавита хотя бы один раз.
# В нашем задании мы будем рассматривать в качестве алфавита буквы английского языка.
# Тогда одним из примеров панграммы будет фраза «The quick brown fox jumps over the lazy dog».
# Ваша задача здесь — написать функцию is_pangram для проверки предложения на предмет того, является ли оно панграммой или нет.
# Для проверок внутри функции вы можете пользоваться глобальной переменной alpha. Символы, которые не являются буквами, необходимо игнорировать.

alpha = 'abcdefghijklmnopqrstuvwxyz'

def is_pangram(text):
    return all([letter in text.lower() for letter in alpha])

# Rövarspråket (со шведского переводится как «язык разбойника») - шведская языковая игра.
# Она стала популярной после книг Астрид Линдгрен о Билле Бергсоне, где дети используют ее в качестве кода, как в игре, так и при раскрытии настоящих преступлений.
# Формула кодирования проста: каждая согласная удваивается, а между ними вставляется буква o. Гласные остаются нетронутыми.
# Тогда согласно этим правилам слово stubborn превратится в sostotubobboborornon
# Ваша задача написать функцию translate_to_robber_lang(), которая будет переводить текст на «язык разбойника» (по-шведски ).
# Все символы, которые не являются буквами, должны оставаться без изменения.
# Гласными будем считать буквы ['a','e', 'i', 'o', 'u']

vowels = ['a','e', 'i', 'o', 'u']

def translate_to_robber_lang(text):
    return ''.join([f'{letter}o{letter}' if letter.lower() not in vowels and letter.isalpha() else letter for letter in text])

# К нам обратились работники одного известного ресторана с просьбой написать приложение, которое позволяет автоматизировать процесс резервации столов.
# Одним из этапов процесса является определение свободных столов, чтобы затем можно было их предложить забронировать клиентам.
# Всего в ресторане имеется 9 столиков. Информация о брони хранится в глобальной переменной tables в словаре следующего формата
# tables = {
#   1: 'Andrey',
#   2: None,
#   3: None,
#   4: None,
#   5: None,
#   6: None,
#   7: None,
#   8: None,
#   9: None,
# }
# Ключи здесь - номера столов, значения - имена клиентов, если бронь имеется, иначе None.
# По текущему состоянию бронирования видно, что только столик под номером 1 занят Андреем, все остальные столики свободны.
# Значение None является признаком того, что столик никем не занят.
# Ваша задача написать две функции, которые помогут определять какие столы сейчас свободны:
#     ✔ функцию is_table_free, которая принимает номер стола и возвращает ответ на вопрос: «Свободен ли данный стол?» в виде булева значения
#     ✔ функцию get_free_tables, которая вернет список всех свободных столов.

def is_table_free(n):
    return tables[n] is None


def get_free_tables():
    return [k for k in tables.keys() if is_table_free(k)]

# Продолжаем автоматизировать работу ресторана. Следующим этапом является резервация(закрепление) свободного столика за клиентом и отмена брони.
# Структура хранения резерваций все та же в виде словаря:
# tables = {
#   1: 'Andrey',
#   2: None,
#   3: None,
#   4: None,
#   5: None,
#   6: None,
#   7: None,
#   8: None,
#   9: None,
# }
# Ваша задача написать две функции, которые помогут создавать и удалять бронирование:
#     ✔ функцию reserve_table, которая принимает номер стола и имя клиента, проверяет свободен ли указанный столик и если за ним никто не прикреплен,
#       вносятся данные клиента. Больше данная функция ничего не делает. Для реализации этой функции можете воспользоваться функцией is_table_free
#       из задания «Автоматизируем ресторан: вакантные столы»
#     ✔ функцию delete_reservation, которая очищает запись о бронировании.

def is_table_free(n):
    return tables[n] is None


def reserve_table(number, name):
    tables[number] = name if is_table_free(number) else tables[number]


def delete_reservation(number):
    tables[number] = None

# Через некоторое время менеджеры ресторана поняли, что помимо имени клиента, они бы еще хотели хранить его принадлежность к статусу VIP клиента.
# Соответственно, они бы хотели изменить структуру хранения резерваций на следующую:
# tables = {
#     1: {'name': 'Andrey', 'is_vip': True},
#     2: None,
#     3: None,
#     4: None,
#     5: {'name': 'Vasiliy', 'is_vip': False},
#     6: None,
#     7: None,
#     8: None,
#     9: None,
# }
# Здесь мы видим, что информация о клиенте хранится во вложенном словаре, у которого имеются два ключа name и is_vip.
# Исходя из новой структуры данных, ваша задача теперь сделать рефакторинг кода функции reserve_table.
# Теперь она должна принимать не два аргумента, а три: номер стола, имя клиента и статус VIP.
# Делать проверку свободен ли стол и если она пройдена, сохранять данные в описанной выше структуре
# Для успешного прохождения тестов скопируйте также реализацию функции delete_reservation из задания «Резервация столов»
# и все ее зависимости от других функций, если они были

def is_table_free(n):
    return tables[n] is None


def reserve_table(number, name, status):
    tables[number] = {'name': name, 'is_vip': status} if is_table_free(number) else tables[number]


def delete_reservation(number):
    tables[number] = None