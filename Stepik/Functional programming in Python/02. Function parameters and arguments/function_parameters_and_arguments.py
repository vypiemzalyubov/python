# Перепишите функцию powers из предыдущего урока так, чтобы она вместо кортежа возвращала список

def powers(num):
    square = num**2
    cube = num**3
    return [num, square, cube]

# Перед вами имеется практически готовый код, который позволяет определять достиг ли гражданин совершеннолетия или нет.
# Всю ответственность за проверку взяла на себя функция is_adult, она принимает возраст человека и должна вернуть ответ на вопрос,
# является ли он совершеннолетним, при условии что совершеннолетие наступает с 18 лет.
# Сейчас тело функции is_adult является пустым и ваша задача его написать.

def is_adult(age):
    return age > 17


a = int(input())
if is_adult(a):
    print('Ух какой большой')
else:
    print('Подрасти еще, сынок')

# Напишите функцию is_leap, которая проверяет является ли переданный год високосным или нет.
# Високосным является год, номер которого делится на 4, но не делится на 100, или же номер которого делится на 400.
# Напишите только определение функции is_leap

def is_leap(year):
    if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:
        return True
    return False

# Определите функцию is_palindrome, которая принимает строку и отвечает на вопрос, является ли она палиндромом или нет
# Палиндромами считаются слова, которые читаются одинаково слева направо и справа налево, как например слово «радар»
# При проверке не нужно учитывать регистр букв. Это значит, что слова «радар» и «Радар» считаются одинаковыми.
# Также во входной строке могут встречаться пробелы, их необходимо исключить из проверки. Остальные знаки пунктуации, такие как запятые, точки, дефисы и т.д., во входных данных отсутствуют.

def is_palindrome(s):
    return [j.lower() for i in s.split() for j in i] == [j.lower() for i in s.split()[::-1] for j in i[::-1]]

# Напишите функцию count_leap_years, которая принимает два года y1 и y2, причем y1 <= y2, и возвращает количество високосных лет в промежутке от y1 включительно до  y2 не включительно.
# При реализации функции count_leap_years используйте ранее созданную функцию is_leap.
# Напишите только определения необходимых функций.

def is_leap(year):
    return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0


def count_leap_years(year1, year2):
    return sum([1 for i in range(year1, year2) if is_leap(i)])

# Напишите функцию get_leap_years, которая принимает два года y1 и y2, причем y1 <= y2, и возвращает список, состоящий из високосных лет в промежутке от y1 включительно до  y2 не включительно.
# Года должны располагаться в нем в хронологическом порядке. При реализации функции get_leap_years используйте ранее созданную функцию is_leap.
# Напишите только определения необходимых функций.

def is_leap(year):
    return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0


def get_leap_years(year1, year2):
    return [i for i in range(year1, year2) if is_leap(i)]

# Определите функцию create_palindrome, которая принимает строку и возвращает результат в зависимости от следующих условий:
# - Если переданная строка уже является палиндромом вне зависимости от регистра букв, вернуть ее, преобразовав все символы к нижнему регистру, иначе идем к следующему пункту
# - Создать палиндром по следующему формату {str}_i_{reverse_str}, где str - переданная строка, а reverse_str ее перевернутое значение.
# Верните вновь созданный палиндром в качестве ответа, преобразовав все символы к нижнему регистру

def create_palindrome(s):
    s = s.replace(' ', '').lower()
    if s == s[::-1]:
        return s
    return f'{s}_i_{s[::-1]}'

# Напишите функцию is_strings_equal, которая принимает две строки в качестве аргументов и сравнивает их между собой.
# Строки считаются равными, если они имеют одинаковую длину и одинаковые символы в равном количестве вне зависимости от их расположения.
# Функция is_strings_equal должна вернуть True, если строки равны, в противном случае - False.

def is_strings_equal(s1, s2):
    return sorted(s1) == sorted(s2)

# «Dunder» происходит от «double underscore», что переводится как двойное подчеркивание.
# В python существуют специальные методы, которые позволяют объектам хорошо взаимодействовать со многими встроенными функциями языка.
# Такие методы называют магическими или dunder-методами, потому что их имена начинаются и заканчиваются на __.
# Примерами таких методов являются __str__, __repr__, __bool__ и т.д.
# Подробнее о самих магических методах мы будем разговаривать в курсе «ООП: Объектно-ориентированное программирование»
# Сейчас ваша задача — написать функцию is_dunder, которая по названию метода помогает определить, подходит ли оно под «dunder» название или нет.
# Само имя метода (без учета двух нижних подчеркиваний в начале и в конце) должно состоять только из букв и иметь длину не меньше двух символов.
# Результатом функции is_dunder должно быть значение True, если переданное значение подходит под наименование dunder-метода, False в противном случае.

def is_dunder(s):
    return len(s.split('__')[1]) >= 2 and s.split('__')[1].isalpha()

# Напишите функцию words_length, которая по входному списку слов создает список целых чисел,
# составленный из длины соответствующих слов и возвращает его в качестве результата.

def words_length(words):
    return [len(word) for word in words]

# Напишите функцию filter_long_words, которая принимает список слов и целое число N и возвращает список слов, длина которых больше чем число N

def filter_long_words(words, n):
    return [word for word in words if len(word) > n]

# Напишите функцию is_member, которая принимает некое значение value и список значений lst.
# Функция is_member должна вернуть True, если значение value присутствует в списке lst, и False в противном случае.
# Гарантируется, что список lst не будет вложенным

def is_member(value, lst):
    return value in lst

# Определите функцию overlapping, которая принимает два списка и возвращает True, если у них есть хотя бы один общий элемент, в противном случае — False.
# ВЫ можете решать задачу удобным для вас способом, но попробуйте реализовать с использованием функции is_member из предыдущего шага.

def is_member(value, lst):
    return value in lst

def overlapping(lst1, lst2):
    return any(is_member(i, lst1) for i in lst2)

# Напишите функцию find_longest_word_len, которая принимает список слов и возвращает длину самого длинного из них.

def find_longest_word_len(words):
    return max([len(word) for word in words])

# Напишите функцию register_check, которая проверяет сколько человек успешно прошло регистрацию на мероприятие.
# Функция принимает словарь в качестве параметра, состоящий из имен людей(ключи) и результатов регистрации(значения ключа).
# Если человек успешно прошел регистрацию, то в словаре напротив его имени хранится значение «yes», иначе «no».
# Функция register_check должна возвращать количество только тех людей, кто успешно зарегистрировался.

def register_check(people):
    return len({k:v for k, v in people.items() if v == 'yes'})

# Напишите функцию create_tuples, которая принимает два списка одинаковой длины и объединяет их в список кортежей.
# Элемент кортежа получается путем соединения элемента первого и второго списков, стоящих на одинаковых позициях

def create_tuples(lst1, lst2):
    return [(i, j) for i, j in zip(lst1, lst2)]

# В HTML используются специальные теги для определения заголовков в веб-странице.
# Всего существует шесть тегов заголовков HTML:
# <h1> - заголовок первого уровня;
# <h2> - заголовок второго уровня;
# <h3> - заголовок третьего уровня;
# <h4> - заголовок четвертого уровня;
# <h5> - заголовок пятого уровня;
# <h6> - заголовок шестого уровня.
# Разница между заголовками только в размере, на картинке можно наглядно это увидеть.
# Ваша задача — создать функцию make_header, которая принимает два параметра:
# - text - строка, которую нужно обернуть в тег заголовка;
# - level - целое число, обозначающее уровень заголовка.
# Функция make_header должна возвращать переданную строку, обернутую в тег заголовка определенного уровня.
# Ваша задача — написать только определение функции make_header

def make_header(text, level):
    return f'<h{level}>{text}</h{level}>'

# Панграмма — это предложение, которое содержит все буквы алфавита хотя бы один раз.
# В нашем задании мы будем рассматривать в качестве алфавита буквы английского языка.
# Тогда одним из примеров панграммы будет фраза «The quick brown fox jumps over the lazy dog».
# Ваша задача здесь — написать функцию is_pangram для проверки предложения на предмет того, является ли оно панграммой или нет.
# Для проверок внутри функции вы можете пользоваться глобальной переменной alpha. Символы, которые не являются буквами, необходимо игнорировать.

alpha = 'abcdefghijklmnopqrstuvwxyz'

def is_pangram(text):
    return all([letter in text.lower() for letter in alpha])

# Rövarspråket (со шведского переводится как «язык разбойника») - шведская языковая игра.
# Она стала популярной после книг Астрид Линдгрен о Билле Бергсоне, где дети используют ее в качестве кода, как в игре, так и при раскрытии настоящих преступлений.
# Формула кодирования проста: каждая согласная удваивается, а между ними вставляется буква o. Гласные остаются нетронутыми.
# Тогда согласно этим правилам слово stubborn превратится в sostotubobboborornon
# Ваша задача написать функцию translate_to_robber_lang(), которая будет переводить текст на «язык разбойника» (по-шведски ).
# Все символы, которые не являются буквами, должны оставаться без изменения.
# Гласными будем считать буквы ['a','e', 'i', 'o', 'u']

vowels = ['a','e', 'i', 'o', 'u']

def translate_to_robber_lang(text):
    return ''.join([f'{letter}o{letter}' if letter.lower() not in vowels and letter.isalpha() else letter for letter in text])

# К нам обратились работники одного известного ресторана с просьбой написать приложение, которое позволяет автоматизировать процесс резервации столов.
# Одним из этапов процесса является определение свободных столов, чтобы затем можно было их предложить забронировать клиентам.
# Всего в ресторане имеется 9 столиков. Информация о брони хранится в глобальной переменной tables в словаре следующего формата
# tables = {
#   1: 'Andrey',
#   2: None,
#   3: None,
#   4: None,
#   5: None,
#   6: None,
#   7: None,
#   8: None,
#   9: None,
# }
# Ключи здесь - номера столов, значения - имена клиентов, если бронь имеется, иначе None.
# По текущему состоянию бронирования видно, что только столик под номером 1 занят Андреем, все остальные столики свободны.
# Значение None является признаком того, что столик никем не занят.
# Ваша задача написать две функции, которые помогут определять какие столы сейчас свободны:
#     ✔ функцию is_table_free, которая принимает номер стола и возвращает ответ на вопрос: «Свободен ли данный стол?» в виде булева значения
#     ✔ функцию get_free_tables, которая вернет список всех свободных столов.

def is_table_free(n):
    return tables[n] is None


def get_free_tables():
    return [k for k in tables.keys() if is_table_free(k)]

# Продолжаем автоматизировать работу ресторана. Следующим этапом является резервация(закрепление) свободного столика за клиентом и отмена брони.
# Структура хранения резерваций все та же в виде словаря:
# tables = {
#   1: 'Andrey',
#   2: None,
#   3: None,
#   4: None,
#   5: None,
#   6: None,
#   7: None,
#   8: None,
#   9: None,
# }
# Ваша задача написать две функции, которые помогут создавать и удалять бронирование:
#     ✔ функцию reserve_table, которая принимает номер стола и имя клиента, проверяет свободен ли указанный столик и если за ним никто не прикреплен,
#       вносятся данные клиента. Больше данная функция ничего не делает. Для реализации этой функции можете воспользоваться функцией is_table_free
#       из задания «Автоматизируем ресторан: вакантные столы»
#     ✔ функцию delete_reservation, которая очищает запись о бронировании.

def is_table_free(n):
    return tables[n] is None


def reserve_table(number, name):
    tables[number] = name if is_table_free(number) else tables[number]


def delete_reservation(number):
    tables[number] = None

# Через некоторое время менеджеры ресторана поняли, что помимо имени клиента, они бы еще хотели хранить его принадлежность к статусу VIP клиента.
# Соответственно, они бы хотели изменить структуру хранения резерваций на следующую:
# tables = {
#     1: {'name': 'Andrey', 'is_vip': True},
#     2: None,
#     3: None,
#     4: None,
#     5: {'name': 'Vasiliy', 'is_vip': False},
#     6: None,
#     7: None,
#     8: None,
#     9: None,
# }
# Здесь мы видим, что информация о клиенте хранится во вложенном словаре, у которого имеются два ключа name и is_vip.
# Исходя из новой структуры данных, ваша задача теперь сделать рефакторинг кода функции reserve_table.
# Теперь она должна принимать не два аргумента, а три: номер стола, имя клиента и статус VIP.
# Делать проверку свободен ли стол и если она пройдена, сохранять данные в описанной выше структуре
# Для успешного прохождения тестов скопируйте также реализацию функции delete_reservation из задания «Резервация столов»
# и все ее зависимости от других функций, если они были

def is_table_free(n):
    return tables[n] is None


def reserve_table(number, name, status):
    tables[number] = {'name': name, 'is_vip': status} if is_table_free(number) else tables[number]


def delete_reservation(number):
    tables[number] = None

# Напишите функцию replace, которая принимает три параметра:
# - обязательный строковый параметр text - текст, в котором необходимо выполнить замены;
# - обязательный строковый параметр old - строка поиска для замены;
# - необязательный строковый параметр new - значение замены для найденного значения old. По умолчанию равен пустой строке.
# Функция replace должна возвращать новую строку, в которой все символы old были заменены на new. При замене регистр букв должен учитываться

def replace(text, old, new=''):
    return text.replace(old, new)

# Напишите функцию product , которая принимает список чисел и находит их произведение.
# Также данная функция может принимать необязательный параметр start , который отвечает за начальное значение произведения (по умолчанию равно 1)

def product(lst, start=1):
    return start * __import__('math').prod(lst)

# Ваша задача написать функцию add_item, которая добавляет в корзину (глобальная переменная shopping_list) товар и его количество.
# Функция add_item обязательно должна принимать имя товара и необязательно - его количество (по умолчанию оно равно 1)

shopping_list = {}

def add_item(name, count=1):
    shopping_list[name] = shopping_list.get(name, 0) + count

# Напишите функцию show_list, которая выводит список товаров из корзины (глобальная переменная shopping_list).
# У функции show_list есть необязательный логический параметр include_quantities, по умолчанию принимает значение True.
# Если include_quantities имеет значение True, вы должны выводить имя товара и его количество в следующем формате:
# {количество}x{имя_товара}, иначе необходимо вывести только имя.
# Напишите только реализацию функции show_list

def show_list(include_quantities=True):
    if include_quantities:
        for k, v in shopping_list.items():
            print(f'{v}x{k}')
    else:
        for k in shopping_list:
            print(k)

# Исправьте функции так, чтобы добавление одной оценки студенту не влияло на оценки других учеников

def create_student(name, age, marks=None):
    if marks is None:
        marks = []
    return {
        'name': name,
        'age': age,
        'marks': marks  # оценки
    }


def add_mark(student, mark):
    student['marks'].append(mark)

# Мы часто сталкиваемся с математической проблемой, когда после совместного похода в ресторан необходимо посчитать сколько должен каждый человек.
# Давайте создадим функцию  calculate_per_person, которая поможет выполнить расчет.
# Будем считать, что у нас идеальная ситуация, когда между N количеством людей нужно разделить счет поровну.
# Также в счет нужно включить чаевые официанту, которые по умолчанию составляют 10%.
# Итого получаем, что функция calculate_per_person может принимать следующие аргументы
# - обязательно счет за ресторан
# - обязательно количество людей
# - необязательно процент чаевых официанту, по умолчанию 10%
# Функция calculate_per_person должна вернуть результат - сумму, которую должен заплатить каждый участник ужина.
# При расчете у  вас будут возникать вещественные числа, результат нужно будет округлять функцией round до второго разряда после запятой

def calculate_per_person(bill, n, tips=10):
    return round(bill / n + (bill / n * tips / 100), 2)

# Помните у нас была реализована функция reserve_table ? Она принимала три обязательных значения: номер стола, имя клиента и статус VIP.
# Как только менеджеры узнали про параметр со значением по умолчанию они сразу решили попросить вас переписать функцию reserve_table так,
# чтобы статус VIP клиента был по умолчанию равен False. Потому что большинство клиентов не так часто заходят в данное заведение
# и по статистике больше обычных клиентов, нежели вип-персон.

def is_table_free(n):
    return tables[n] is None


def reserve_table(number, name, status=False):
    tables[number] = {'name': name, 'is_vip': status} if is_table_free(number) else tables[number]


def delete_reservation(number):
    tables[number] = None

# Ваша задача — создать функцию create_matrix, которая имеет следующие параметры:
# - необязательный числовой параметр size - размер квадратной матрицы, по умолчанию принимает значение 3;
# - необязательный числовой параметр up_fill - значение заполнителя элементов, находящихся выше главной диагонали. По умолчанию равен 0;
# - необязательный числовой параметр down_fill - значение заполнителя элементов, находящихся ниже главной диагонали. По умолчанию равен 0.
# Функция create_matrix должна возвращать квадратную матрицу размером size х size, на диагонали которой располагаются числа от 1 до size.
# Все остальные элементы заполнены согласно параметрам up_fill и down_fill.
# Ваша задача написать только определение функции create_matrix

def create_matrix(size=3, up_fill=0, down_fill=0):
    mtrx = [[0] * size for i in range(size)]
    for i in range(size):
        for j in range(size):
            if i == j:
                mtrx[i][j] = i + 1
            elif i < j:
                mtrx[i][j] = up_fill
            else:
                mtrx[i][j] = down_fill
    return mtrx

# Помните функцию words_length, которая по входному списку слов создавала список длины соответствующих слов и возвращала его в качестве результата?
# Одна из возможных реализаций этой функции представлена ниже
# def words_length(words):
#     return [len(word) for word in words]
# Здесь функция words_length является чистой. Ваша задача переписать ее так, чтобы она начала изменять входной список:
# вместо слов должна подставляться его длина. В качестве результата новая words_length должна вернуть None

def words_length(words):
    for i in range(len(words)):
        words[i] = len(words[i])
    return

# Перепишите функцию my_func так, чтобы она стала чистой

def my_func(collection, n):
    result = collection.copy()
    for i in range(1, n + 1):
        result.append(i)
    return result

# Напишите функцию lstrip, которая принимает список lst и значение value.
# Функция lstrip должна удалить из начала списка lst все упоминания значения value, остальные элементы должны остаться без изменения,
# даже те, которые равны значению value, но не находятся в начале списка.
# Изначальный список lst должен измениться после вызова lstrip. Сама lstrip ничего не возвращает

def lstrip(lst, value):
    tmp = list(map(int, ''.join(list(map(str, lst))).lstrip(str(value))))
    lst.clear()
    for i in range(len(tmp)):
        lst.append(tmp[i])

# Напишите функцию lstrip, которая принимает список lst и значение value.
# Функция lstrip должна теперь создать новый список, который является копией lst, но без элементов в самом начале, равных значению value.
# Изначальный список, переданный в lst, не должен измениться

def lstrip(lst, value):
    return list(map(int, ''.join(list(map(str, lst))).lstrip(str(value))))

# Почините программу, чтобы функция print_values смогла отработать и вывести приветствия на экран

def print_values(one, two, three):
    print(one, two, three)


words = 'Hello', 'Aloha', 'Bonjour'
print_values(*words)

# Напишите функцию count_args, которая принимает произвольное количество аргументов.
# Данная функция должна возвращать количество переданных ей на вход аргументов
# Вам необходимо написать только определение функции count_args

def count_args(*args):
    return len(args)

# Напишите функцию multiply, которая принимает произвольное количество числовых аргументов.
# Данная функция должна находить произведение всех переданных значений и возвращать его в качестве результата
# При вызове multiply без параметров должен возвращаться результат 1.
# Вам необходимо написать только определение функции multiply

def multiply(*args):
    res = 1
    for i in args:
        res *= i
    return res

# Напишите функцию check_sum, которая принимает произвольное количество аргументов типа int.
# Данная функция должна вывести на экран фразу «not enough», если сумма всех элементов меньше 50, в противном случае нужно вывести «verification passed»
# Вам необходимо написать только определение функции check_sum

def check_sum(*args):
    print("verification passed" if sum([i for i in args]) > 49 else "not enough")

# Напишите функцию is_only_one_positive, которая принимает произвольное количество числовых аргументов и возвращает True,
# когда из всех переданных значений только одно положительное, в противном случае верните False
# Вам необходимо написать только определение функции is_only_one_positive

def is_only_one_positive(*args):
    count = 0
    for i in args:
        if i > 0:
            count+=1
    return count == 1

# Давайте теперь создадим функцию print_goods, которая печатает список покупок.
# На вход она будет принимать произвольное количество значений, а товаром мы будем считать любые непустые строки.
# Следовательно, все числа, списки, словари и другие нестроковые объекты вам нужно будет проигнорировать.
# Функция print_goods должна печатать список товаров в виде: «<Порядковый номер товара>. <Название товара>».
# На примерах ниже вы можете посмотреть как должна работать функция print_goods
# print_goods('apple', 'banana', 'orange')
# # Программа должна вывести следующее:
# 1. apple
# 2. banana
# 3. orange
# print_goods(1, True, 'Грушечка', '', 'Pineapple')
# # Программа должна вывести следующее:
# 1. Грушечка
# 2. Pineapple
# В случае, если среди переданных значений не встретится ни одного товара, необходимо распечатать фразу «Нет товаров»
# print_goods([], {}, 1, 2)
# # Программа должна вывести следующее:
# Нет товаров
# Вам необходимо написать только определение функции print_goods

def print_goods(*args):
    count = 0
    
    for i in args:
        if isinstance(i, str) and len(i) > 0:
            count += 1
            print(f'{count}. {i}')
            
    if count == 0:
        print("Нет товаров")

# Студент-программист поспешил и неправильно написал программу. Теперь он имеет дело с ошибкой
# TypeError: print_args() missing 3 required positional arguments: 'b', 'c', and 'd'
# Помогите ему исправить вызов функции так, чтобы print_args смогла отработать и вывести числа на экран

def print_args(a, b, c, d):
    print(a, b, c, d)

dct = {'a': 100, 'b': 200, 'c': 300, 'd': 400}
print_args(**dct)

# Напишите функцию concatenate(), которая принимает произвольное число именованных аргументов и объединяет их в одну большую строку без разделителей.
# Вам необходимо написать только определение функции concatenate
# Обратите внимание, что передаваемые значения могут быть различных типов данных

def concatenate(**kwargs):
    return ''.join([str(v) for v in kwargs.values()])

# Напишите функцию create_actor, которая принимает произвольное количество именованных аргументов и возвращает словарь с характеристиками актера.
# Если функции create_actor не передавать никаких аргументов, то она должна возвращать базовый словарь с ключами name, surname, age. Вот так он выглядит:
# create_actor() -> {
#         'name': 'Райан',
#         'surname': 'Рейнольдс',
#         'age': 47,
#     }
# Если передавать именованные параметры, которые отсутствуют в базовом словаре, они дополняются к этому словарю
# create_actor(height=190, movies=['Дедпул', 'Главный герой']) => {
#     'name': 'Райан',
#     'surname': 'Рейнольдс',
#     'age': 47,
#     'height': 190,
#     'movies': ['Дедпул', 'Главный герой']
# }
# Если передавать именованные параметры, которые совпадают с ключами базового словаря, то значения в словаре должны заменяться переданными значениями:
# create_actor(name='Jack', age=20) -> {
#         'name': 'Jack',
#         'surname': 'Рейнольдс',
#         'age': 20,
#     }
# Вам необходимо написать только определение функции create_actor

def create_actor(**kwargs):
    dct = {
        'name': 'Райан',
        'surname': 'Рейнольдс',
        'age': 47,
    }
    dct.update(**kwargs)
    return dct

# Напишите функцию info_kwargs, которая принимает произвольное количество именованных аргументов.
# Функция info_kwargs должна распечатать именованные аргументы (каждый на новой строке) в виде пар «ключ = значение», где ключи должны следовать в алфавитном порядке.
# Вам необходимо написать только определение функции info_kwargs

def info_kwargs(**kwargs):
    for k, v in sorted(kwargs.items()):
        print(f'{k} = {v}')