# Напишите генератор-функцию gen_odd, которая принимает натуральное число n и генерирует последовательность нечетных чисел от 1 до n включительно

def gen_odd(n):
    for i in range(1, n + 1):
        if i % 2:
            yield i

# В вашем распоряжении имеется глобальная переменная DICTIONARY, представляющая собой словарь, где ключами являются английские буквы,
# а значениями - слова, начинающиеся с буквы ключа. Начальное заполнение DICTIONARY имеет следующий вид:
# DICTIONARY = {
#     'a': 'apple',
#     'b': 'banana',
#     'c': 'cat',
#     'd': 'dog',
#     ...
# }
# Ваша задача — написать генератор-функцию alphabet, которая генерирует два значения, представляющие собой ключ и значение словаря.
# Генератор-функция alphabet должна выдавать значения в том же порядке, в котором были созданы ключи в словаре DICTIONARY.
# Сама переменная DICTIONARY вам в редакторе кода не видна, но вы можете обращаться к ней внутри сопрограммы alphabet.

DICTIONARY = {
    'a': 'apple',
    'b': 'banana',
    'c': 'cat',
    'd': 'dog',
}

def alphabet():
    yield from DICTIONARY.items()

# Ваша задача создать функцию-генератор my_range_gen, которая имеет один параметр n.
# Функция my_range_gen должна генерировать по порядку все числа от 0 до n не включительно.
# В общем, быть копией встроенной функции range, вызванной от одного аргумента.
# Ваша задача написать только определение функции-генератора my_range_gen

def my_range_gen(n):
    yield from range(n)

# Ваша задача создать функцию-генератор gen_squares, которая принимает аргумент n и генерирует квадраты чисел от 1 до n включительно.
# Ниже несколько вариантов использования. Ваша задача написать только определение функции gen_squares

def gen_squares(n):
    for i in range(1, n + 1):
        yield i ** 2

# Ваша задача создать функцию-генератор gen_arithmetic_progression, которая при вызове принимает два значения:
# - первый элемент прогрессии
# - разность элементов прогрессии
# Функция-генератор gen_arithmetic_progression должна выдавать элементы бесконечной арифметической прогрессии с учетом переданных значений
# Ваша задача написать только определение функции-генератора gen_arithmetic_progression

def gen_arithmetic_progression(x, y):
    count = 1
    total = x
    while True:
        yield x if count == 1 else total
        total += y
        count += 1

# Ваша задача создать функцию-генератор gen_fibonacci_numbers, которая принимает аргумент n и генерирует n-ое количество чисел Фибоначчи.
# Будем считать, что последовательность Фибоначчи такая: 1, 1, 2, 3, 5, 8, 13, 21, 34, ...
# Ваша задача написать только определение функции gen_fibonacci_numbers

def gen_fibonacci_numbers(n):
    a = b = 1
    for _ in range(n):
        yield a
        a, b = b, a + b

# Напишите генератор-функцию gen_factorial, которая принимает натуральное число n и генерирует факториалы чисел от 1! до n!

def gen_factorial(n):
    total = 1
    for i in range(1, n + 1):
        total *= i
        yield total

# Измените генератор-функцию gen_factorial так, чтобы он стал выдавать бесконечную последовательность факториалов

def gen_factorial():
    total = 1
    count = 1
    while True:
        total *= count
        yield total
        count += 1

# Напишите функцию-генератор my_enumerate, которая копирует работу встроенной функции enumerate.

def my_enumerate(lessons, start=0):
    yield from enumerate(lessons, start)

# Если у вас есть итерируемый объект, который слишком велик для того, чтобы полностью поместиться в памяти (например, при работе с большими файлами),
# возможность дробить его на небольшие фрагменты и затем использовать их за раз может быть очень ценной.
# С этой задачей должна справиться функция-генератор chunker. Она должна принимать итерируемый объект и выдавать фрагмент указанного размера за раз.
# Ваша задача написать функцию-генератор chunker

def chunker(obj, limit):
    result = []
    for i in obj:
        if result and len(result[-1]) < limit:
            result[-1].append(i)
        else:
            result.append([i])
    for i in result:
        if isinstance(obj, str):
            yield ''.join(i)
        else:
            yield i

# Измените функцию-генератор my_range_gen так, чтобы она могла вызываться от одного или двух аргументов.
# Если вызов происходит от одного аргумента n, то my_range_gen  генерирует все числа от 0 до n не включительно.
# Если вызов происходит от двух аргументов a и b, то my_range_gen  генерирует все числа от a включительно до b не включительно.

def my_range_gen(n, m=0):
    yield from range(n) if m == 0 else range(n, m)

# Теперь ваша задача создать полную копию встроенного объекта range. Он может быть вызван от одного, двух или трех аргументов.
# Если вызов происходит от одного аргумента n, то my_range_gen  генерирует все числа от 0 до n не включительно.
# Если вызов происходит от двух аргументов a и b, то my_range_gen  генерирует все числа от a включительно до b не включительно.
# Если вызов происходит от трех аргументов a , b и step, то my_range_gen  генерирует все числа от a включительно до b не включительно c шагом step
# (может быть отрицательное значение)
# for i in my_range_gen(4, 8, 2):
#     print(i)
# # Будет напечатано
# # 4
# # 6
# for i in my_range_gen(8, 5, -1):
#     print(i)
# # Будет напечатано
# # 8
# # 7
# # 6
# Предусмотрите вариант запуска my_range_gen со значением step=0.
# При таком варианте вызова, функция не должна генерировать ни одной последовательности и закончить свою работу.
# for i in my_range_gen(4, 8, 0):
#     print(i) # Ничего не печатает
# Такое же поведение должно быть, если переданы нелогичные значения start, stop и step (см. примеры)
# for i in my_range_gen(20, 10, 3):
#     print(i)
# # Ничего не печатает, потому что нельзя пройти от 20 до 10 с шагом 3
# for i in my_range_gen(1, 10, -2):
#     print(i)
# # Ничего не печатает, потому что нельзя пройти от 1 до 10 с шагом -2
# Ваша задача написать только определение функции my_range_gen
# И да, функцией range пользоваться нельзя; можете, конечно, попробовать, но у вас ничего не получится

def my_range_gen(*args):
    if len(args) == 1:
        start = 0
        end = args[0]
        step = 1
    elif len(args) == 2:
        start = args[0]
        end = args[1]
        step = 1
        if (step > 0 and start >= end) or (step < 0 and start <= end):
            return
    elif len(args) == 3:
        start = args[0]
        end = args[1]
        step = args[2]
        if step == 0:
            return
    else:
        return
    
    current = start
    while (step > 0 and current < end) or (step < 0 and current > end):
        yield current
        current += step

# Ниже представлен код, который вам нужно будет дописать.
# В переменную from_10_to_20 при помощи генератора-выражения сохраните последовательность от 10 до 20 включительно.
# Затем при помощи функции next выведите первые три элемента. И остается вывести оставшиеся элементы в цикле

from_10_to_20 = (i for i in range(10, 21))

print(next(from_10_to_20))
print(next(from_10_to_20))
print(next(from_10_to_20))

for value in from_10_to_20:
    print(value)

# Перед вами список words.
# Необходимо сохранить в переменной lens генератор-выражение, который генерирует длины слов списка words по порядку.
# Больше от вас в этой задаче ничего не требуется.

words = ['feel', 'graduate', 'movie', 'fashionable', 'bacon', 'drop', 'produce', 'acquisition',
         'cheap', 'strength', 'master', 'perception', 'noise', 'strange', 'am']

lens = (len(i) for i in words)

for i in lens:
    print(i)

# Давайте напишем выражение-генератор, который будет генерировать кортеж состоящий из двух элементов: номера дня в году и названия дня недели.
# За начало отсчета возьмем наш «любимый» 2022 год. Он начался в субботу, потом воскресенье, понедельник, вторник, ..., пятница, суббота и далее по кругу
# Результат выражения-генератора сохраните в переменную days.
# Названия дней недели должны совпадать с этими значениями:
# ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
# Значит при первой итерации генератор должен вернуть кортеж
# (1, 'Saturday')
# При второй итерации вернется значение
# (2, 'Sunday')
# Ваша задача распечатать на удачу первые 77 дней 2022 года. Выводить на экран нужно сами кортежи и первые десять значений в выводе должны выглядеть вот так:
# (1, 'Saturday')
# (2, 'Sunday')
# (3, 'Monday')
# (4, 'Tuesday')
# (5, 'Wednesday')
# (6, 'Thursday')
# (7, 'Friday')
# (8, 'Saturday')
# (9, 'Sunday')
# (10, 'Monday')

days = (i for i in zip(range(1, 78), ['Saturday', 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']*11))

for day in days:
    print(day)

# В операционной системе Linux существует очень полезная утилита под названием grep.
# Ее название расшифровывается как «global regular expression print». Команда grep считается среди пользователей одной из наиболее популярных и востребованных.
# Она может помочь решить множество разноплановых задач: найти файл с конкретной строкой в файловой системе или, наоборот, строку в файле,
# где содержатся определенные символы. При этом с ее помощью можно не просто находить куски текста, но и с высокой эффективностью фильтровать вывод другой команды.
# Мы напишем упрощенную версию данной утилиты, которая позволяет искать шаблон строки pattern в переданном тексте.
# Для этого нужно написать корутину grep, которая сперва принимает на вход шаблон pattern и затем постоянно ожидает получить на вход строки текста.
# Задача корутины grep выводить только те переданные строки, в которых будет найден шаблон pattern без учета регистра.

def grep(pattern):
    while True:
        value = yield
        if pattern.lower() in value.lower():
            print(value)
            yield value

# В вашем распоряжении имеется глобальная переменная DICTIONARY, представляющая собой словарь, где ключами являются английские буквы,
# а значениями - слова, начинающиеся с буквы ключа. Начальное заполнение DICTIONARY имеет следующий вид:
# DICTIONARY = {
#     'a': 'apple',
#     'b': 'banana',
#     'c': 'cat',
#     'd': 'dog',
#     ...
# }
# Ваша задача — написать сопрограмму alphabet, в которую передаются буквы, а в ответ она генерирует слова, закрепленные переданной буквой из словаря DICTIONARY.
# Гарантируется, что в alphabet будут поступать значения, которые имеются в ключах словаря DICTIONARY.
# Сама переменная DICTIONARY вам в редакторе кода не видна, но вы можете обращаться к ней внутри сопрограммы alphabet.

def alphabet():
    value = yield
    while True:
        value = yield DICTIONARY.get(value)

# Ваша задача — создать сопрограмму is_palindrome, которая проверяет поступающее ей натуральное число на палиндром.
# Числа поступают в сопрограмму при помощи метода send. Сопрограмма должна порождать значение True,
# если число одинаково можно записать слева направо и справа налево, в противном случае - значение False.
# Вам необходимо написать только определение функции-сопрограммы is_palindrome.

def is_palindrome():
    value = None
    while True:
        value = yield str(value) == str(value)[::-1]

# Ваша задача — создать корутину get_average, которая накапливает среднее арифметическое переданных в нее чисел.
# Числа поступают в корутину при помощи метода send, корутина должна порождать текущее накопленное значение среднего арифметического.
# Вам необходимо написать только определение функции-корутины get_average.

def get_average():
    total = yield
    count = 0
    while True:
        count += 1
        value = yield total / count
        total += value

# Ваша задача — создать сопрограмму check_password, которая проверяет поступающий ей пароль на безопасность.
# С точки зрения безопасности будет подходить пароль, для которого одновременно выполняются следующие условия:
# - длина не менее 10 символов;
# - должна присутствовать хотя бы одна заглавная буква латинского алфавита;
# - должна присутствовать хотя бы одна цифра;
# - должен присутствовать хотя бы один служебный символ из набора !, @, #, $, %.
# Пароли в виде строки поступают в сопрограмму при помощи метода send.
# Сопрограмма должна порождать значение True, если пароль соответствует всем перечисленным условиям, в противном случае - значение False.
# Вам необходимо написать только определение функции-сопрограммы check_password.

def check_password():
    password = yield
    while True:
        value = yield checker(password)
        password = value


def checker(password):
    return (
        len(password) > 9
        and any(spec in password for spec in ["!", "@", "#", "$", "%"])
        and any(char.isupper() for char in password)
        and any(char.isdigit() for char in password)
    )