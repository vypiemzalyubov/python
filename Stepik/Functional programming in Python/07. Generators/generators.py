# Напишите генератор-функцию gen_odd, которая принимает натуральное число n и генерирует последовательность нечетных чисел от 1 до n включительно

def gen_odd(n):
    for i in range(1, n + 1):
        if i % 2:
            yield i

# В вашем распоряжении имеется глобальная переменная DICTIONARY, представляющая собой словарь, где ключами являются английские буквы,
# а значениями - слова, начинающиеся с буквы ключа. Начальное заполнение DICTIONARY имеет следующий вид:
# DICTIONARY = {
#     'a': 'apple',
#     'b': 'banana',
#     'c': 'cat',
#     'd': 'dog',
#     ...
# }
# Ваша задача — написать генератор-функцию alphabet, которая генерирует два значения, представляющие собой ключ и значение словаря.
# Генератор-функция alphabet должна выдавать значения в том же порядке, в котором были созданы ключи в словаре DICTIONARY.
# Сама переменная DICTIONARY вам в редакторе кода не видна, но вы можете обращаться к ней внутри сопрограммы alphabet.

DICTIONARY = {
    'a': 'apple',
    'b': 'banana',
    'c': 'cat',
    'd': 'dog',
}

def alphabet():
    yield from DICTIONARY.items()

# Ваша задача создать функцию-генератор my_range_gen, которая имеет один параметр n.
# Функция my_range_gen должна генерировать по порядку все числа от 0 до n не включительно.
# В общем, быть копией встроенной функции range, вызванной от одного аргумента.
# Ваша задача написать только определение функции-генератора my_range_gen

def my_range_gen(n):
    yield from range(n)

# Ваша задача создать функцию-генератор gen_squares, которая принимает аргумент n и генерирует квадраты чисел от 1 до n включительно.
# Ниже несколько вариантов использования. Ваша задача написать только определение функции gen_squares

def gen_squares(n):
    for i in range(1, n + 1):
        yield i ** 2

# Ваша задача создать функцию-генератор gen_arithmetic_progression, которая при вызове принимает два значения:
# - первый элемент прогрессии
# - разность элементов прогрессии
# Функция-генератор gen_arithmetic_progression должна выдавать элементы бесконечной арифметической прогрессии с учетом переданных значений
# Ваша задача написать только определение функции-генератора gen_arithmetic_progression

def gen_arithmetic_progression(x, y):
    count = 1
    total = x
    while True:
        yield x if count == 1 else total
        total += y
        count += 1

# Ваша задача создать функцию-генератор gen_fibonacci_numbers, которая принимает аргумент n и генерирует n-ое количество чисел Фибоначчи.
# Будем считать, что последовательность Фибоначчи такая: 1, 1, 2, 3, 5, 8, 13, 21, 34, ...
# Ваша задача написать только определение функции gen_fibonacci_numbers

def gen_fibonacci_numbers(n):
    a = b = 1
    for _ in range(n):
        yield a
        a, b = b, a + b

# Напишите генератор-функцию gen_factorial, которая принимает натуральное число n и генерирует факториалы чисел от 1! до n!

def gen_factorial(n):
    total = 1
    for i in range(1, n + 1):
        total *= i
        yield total

# Измените генератор-функцию gen_factorial так, чтобы он стал выдавать бесконечную последовательность факториалов

def gen_factorial():
    total = 1
    count = 1
    while True:
        total *= count
        yield total
        count += 1

# Напишите функцию-генератор my_enumerate, которая копирует работу встроенной функции enumerate.

def my_enumerate(lessons, start=0):
    yield from enumerate(lessons, start)

# Если у вас есть итерируемый объект, который слишком велик для того, чтобы полностью поместиться в памяти (например, при работе с большими файлами),
# возможность дробить его на небольшие фрагменты и затем использовать их за раз может быть очень ценной.
# С этой задачей должна справиться функция-генератор chunker. Она должна принимать итерируемый объект и выдавать фрагмент указанного размера за раз.
# Ваша задача написать функцию-генератор chunker

def chunker(obj, limit):
    result = []
    for i in obj:
        if result and len(result[-1]) < limit:
            result[-1].append(i)
        else:
            result.append([i])
    for i in result:
        if isinstance(obj, str):
            yield ''.join(i)
        else:
            yield i

# Измените функцию-генератор my_range_gen так, чтобы она могла вызываться от одного или двух аргументов.
# Если вызов происходит от одного аргумента n, то my_range_gen  генерирует все числа от 0 до n не включительно.
# Если вызов происходит от двух аргументов a и b, то my_range_gen  генерирует все числа от a включительно до b не включительно.

def my_range_gen(n, m=0):
    yield from range(n) if m == 0 else range(n, m)