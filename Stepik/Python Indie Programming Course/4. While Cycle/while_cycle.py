# 177. Напишите программу, которая распечатает все натуральные числа от 1000 до 2000 включительно.
#      Каждое число следует выводить на отдельной строчке как в примере ниже
#      1000
#      1001
#      1002
#      ...
#      1998
#      1999
#      2000

x = 1000
while x <= 2000: print(x); x += 1

# 178. Напишите программу, которая распечатает все натуральные числа кратные 5 от 195 до 6785 включительно в порядке убывания.
#      Каждое число следует выводить на отдельной строчке как в примере ниже
#      6785
#      6780
#      6775
#      ...
#      205
#      200
#      195

x = 6785
while x >= 195:
    print(x)
    x -= 5

# 179. Мишка Лимак хочет стать самым большим медведем, ну, или хотя бы стать больше своего старшего брата Боба.
#      Сейчас вес Лимака равен a, а вес Боба равен b. Гарантируется, что вес Лимака меньше или равен весу Боба.
#      Лимак ест много, и его вес утраивается каждый год, а вес Боба удваивается каждый год.
#      Через сколько целых лет Лимак станет строго больше (т. е. будет весить строго больше) Боба?
#      В единственной строке находятся два целых числа a и b (1 ≤ a ≤ b ≤ 10) — веса Лимака и Боба соответственно.
#      Выведите одно целое число — через сколько целых лет Лимак станет строго больше Боба.

(x, y), c = map(int, input().split()), 0
while x <= y:
    c, x, y = c + 1, x * 3, y * 2
print(c)

# 180. Японцы считают цифру «4» очень несчастливой, они даже исключают ее из нумерации этажей. Давайте и мы, от греха подальше, избавимся от этой цифры в списке numbers. 
#      Ваша задача удалить все упоминания цифры «4» в списке numbers и затем вывести список

numbers = [2, 3, 7, 9, 5, 0, 6, 3, 6, 0, 1, 7, 9, 4, 4, 4, 2, 2, 6, 9, 1, 7, 0, 3, 8, 1, 0, 3, 8, 0, 
           8, 4, 0, 2, 3, 6, 6, 1, 5, 8, 7, 2, 3, 8, 7, 7, 1, 2, 2, 8, 4, 3, 4, 8, 0, 7, 9, 8, 3, 7, 
           7, 7, 7, 5, 1, 7, 4, 5, 0, 8, 0, 9, 2, 4, 7, 6, 6, 5, 9, 7, 1, 7, 8, 8, 3, 4, 9, 7, 6, 4, 
           2, 0, 0, 0, 9, 4, 0, 9, 4, 4, 4, 5, 5, 4, 2, 5, 9, 4, 8, 1, 5, 7, 1, 0, 2, 6, 8, 7, 2, 7, 
           9, 3, 6, 4, 7, 5, 0, 7, 2, 0, 8, 2, 9, 8, 6, 4, 4, 7, 5, 5, 9, 4, 9, 5, 6, 9, 1, 1, 3, 1, 
           5, 2, 1, 7, 0, 0, 7, 8, 1, 3, 0, 0, 4, 4, 3, 3, 6, 7, 8, 6, 1, 2, 0, 2, 0, 9, 9, 0, 5, 2, 
           4, 1, 7, 4, 9, 9, 4, 9, 6, 9, 2, 7, 1, 2, 4, 5, 4, 0, 9, 0]
while 4 in numbers:
    numbers.remove(4)
print(*numbers)

# 181. На вход программе поступает слово. Вам необходимо воспроизвести процесс, в котором каждый раз у этого слово будет пропадать первая и последняя буква. 
#      Этот процесс необходимо закончить, когда в слове останется только одна буква или слово  станет пустой строкой. При этом результат каждого этапа нужно выводить

s = list(input())
while s:
    try:
        print(*s, sep='')
        s.pop(0)
        s.pop()
    except IndexError as e:
        print(*s, sep='')

# 182. Выведите все точные квадраты натуральных чисел, не превосходящие входного натурального числа N.
#      На вход поступает натуральное число N
#      Необходимо вывести  все точные квадраты натуральных чисел, не превосходящие данного числа N

n, l = int(input()), []
x = n
while n:
    if n * n <= x:
        l.append(n * n)
    n -= 1
print(*l[::-1], sep='\n')

# 183. В первый день спортсмен пробежал X километров. В каждый последующий день он увеличивал пробег на 15% от предыдущего дня. 
#      Вам необходимо определить номер дня, в который пробег спортсмена составил не менее Y километров. Само число Y будет поступать на вход программе.
#      Программа получает на вход два натуральных числа X и Y
#      Выведите целое число – номер дня, в который спортсмен пробежал не менее Y километров.

(x, y), d = map(int, input().split()), 1
while x <= y:
    d += 1
    x += x * 0.15
print(d)

# 184. У Васи есть n пар носков. Утром каждого дня, собираясь в школу, Вася должен надеть пару носков. 
#      Вечером, прийдя со школы, Вася снимает надетые носки и выбрасывает их. Каждый m-й день (в дни с номерами m, 2m, 3m, ...) мама покупает Васе одну пару носков. 
#      Она делает это поздно вечером, поэтому Вася может надеть новые носки не раньше следующего дня. На сколько подряд идущих дней Васе хватит носков?
#      В единственной строке записано два целых числа n и m (1 ≤ n ≤ 100; 2 ≤ m ≤ 100), разделенные пробелом.
#      Выведите единственное целое число — ответ на задачу.

(n, m), d = map(int, input().split()), 0
while n:
    d += 1
    n -= 1
    if d % m == 0: n += 1
print(d)

# 185. Программист Василий любит романтику — поэтому на этот Новый Год он решил освещать свою комнату свечами.
#      У Василия есть a свечей. Когда Василий зажигает новую свечу, сначала она горит ровно один час, а затем тухнет. 
#      Василий — сообразительный малый, поэтому из b потухших свечей он умеет получать одну новую свечу. В последствии эту новую свечу (так же как и другие новые свечи) можно зажечь.
#      Теперь Василию интересно, на сколько часов освещения хватит его свечек, если он будет действовать оптимальным образом. Помогите ему найти это число.
#      В единственной строке заданы два целых числа a и b (1 ≤ a ≤ 1000; 2 ≤ b ≤ 1000).
#      Выведите единственное целое число — количество часов, которое Василий сможет освещать комнату.

(lambda a, b: print(a + (a - 1) // (b - 1)))(*map(int, input().split()))

# 186. В архитектуре компьютера важную роль играют числа, являющиеся степенями двойки: 1, 2, 4, 8 и так далее. 
#      Напишите программу, которая проверяет, является ли введённое натуральное число степенью двойки. Если да, то выводится сама эта степень; если нет, выводится «НЕТ»

x, c = int(input()), 0
while 2 ** c < x:
    c += 1
print(c if 2 ** c == x else 'НЕТ')

# 187. Возьмём число. Умножим его на его же первую цифру. Результат умножим на первую цифру результата. И так далее. Например, начнём с 8:
#      8→8∗8=64
#      64→6∗64=384
#      384→3∗384=1152
#      1152→1∗1152=1152
#      Очевидно, когда первая цифра очередного числа в такой последовательности становится равной 1, числа перестают изменяться. Но это происходит не при всех начальных числах.
#      Напишем программу, которая будет хотя бы приблизительно определять судьбу введённого числа n.
#      Начиная с числа n, умножайте имеющееся число на его первую цифру, пока у получившегося числа первая цифра не станет равной 1, либо пока оно не превысит миллиарда. 
#      В качестве ответа выведите результат.

x = int(input())
while str(x)[0] != '1' and x <= 1000000000:
    x *= int(str(x)[0])
print(x)

# 188. Пользователь вводит целые числа по одному в строке, последовательность оканчивается числом 0. 
#      Все, что вводится после 0 не относится к последовательности. Напишите программу, которая выводит сумму всех членов данной последовательности.

c = 0
while (x := int(input())) != 0:
    c += x
print(c)

# 189. На каждой отдельной строчке пользователь вводит друг за другом пароли в виде строки символов. 
#      Валидными паролями будем считать строки, у которых длина варьируется от 5 до 9 символов включительно. 
#      Как только вы встретите первый невалидный пароль, ваша программа должна закончить считывать пароли и вывести последний введенный валидный пароль.
#      Гарантируется, что первый пароль всегда валидный.

l = []
while 5 <= len((p := input())) < 10:
        l.append(p)
print(l[-1])

# 190. У нас в наличии рюкзак, вместимость которого составляет n литров, и наша задача забить его до предела максимально возможно. 
#      Нам поступают вещи, объем которых измеряется также в литрах, и мы должны их складывать в наш рюкзак без возможности пропуска. 
#      Как только суммарный объем новой добавляемой вещи превысит вместимость рюкзака, ваша программа должна вывести слово "Довольно!" и затем на отдельных строчках суммарный объем вещей, 
#      которые мы смогли упаковать в рюкзак, и их количество.
#      Входные данные: Число n – вместимость рюкзака. Далее идут произвольное количество строк – объем очередного предмета.
#      Выходные данные: Строка "Довольно!" и затем два числа – суммарный объем упакованных товаров и их количество. Каждое значение выводится в отдельной строке.

n, sum, count = int(input()), 0, 0
while sum + (x := int(input())) <= n:
    sum += x
    count += 1
print(f'Довольно!\n{sum}\n{count}')

# 191. В последний день уходящего 2016 года Лимак собирается принять участие в соревновании по спортивному программированию. 
#      Соревнование начнётся в 20:00 и будет продолжаться четыре часа, то есть ровно до полуночи. Участникам будет предложено n задач, упорядоченных по возрастанию сложности, 
#      то есть задача 1 будет самой лёгкой, а задача номер n — самой сложной. Лимак знает, что ему потребуется 5·i минут на решение i-й задачи.
#      Друзья Лимака планирую устроить роскошную новогоднюю вечеринку и Лимак хочет прибыть в полночь или ранее. 
#      Он знает, что ему требуется ровно k минут чтобы добрать до места проведения вечеринки от своего дома, где он собирается участвовать в соревновании.
#      Сколько максимум задач может успеть решить Лимак, так чтобы не опоздать на новогоднюю вечеринку?
#      В первой строке входных данных записаны два целых числа n и k (1 ≤ n ≤ 10, 1 ≤ k ≤ 240) — количество задач в соревновании и количество минут, 
#      за которое Лимак доберётся от дома до места проведения вечеринки.
#      Выведите одно целое число, равное максимальному количеству задач, которое может решить Лимак, так чтобы прибыть на новогоднюю вечеринку ровно в полночь или раньше.

(n, k), t = map(int, input().split()), 0
while k + 5 * t < 240 and n != 0:
    t += 1
    n -= 1
    k += 5 * t
print(t)

# 192. Ване на день рождения подарили n кубиков. Он с друзьями решил построить из них пирамиду. Ваня хочет построить пирамиду следующим образом: 
#      на верхушке пирамиды должен находиться 1 кубик, на втором уровне — 1 + 2 = 3 кубика, на третьем — 1 + 2 + 3 = 6 кубиков, и так далее. 
#      Таким образом, на i-м уровне пирамиды должно располагаться 1 + 2 + ... + (i - 1) + i кубиков.
#      Ваня хочет узнать, пирамиду какой максимальной высоты он может создать с использованием имеющихся кубиков.
#      В первой строке записано целое число n (1 ≤ n ≤ 104) — количество кубиков, подаренных Ване.
#      Выведите единственной строкой максимально возможную высоту пирамиды.

n = int(input())
c = x = 0  
while n > c + x:
    c += 1
    x += c
    n -= x
print(c)

# 193. В вашем распоряжении имеется два отсортированных списка по неубыванию элементов, состоящих из n и m элементов.
#      Ваша задача слить их в один отсортированный список размером  n + m
#      Программа получает на вход два числа n и m - количество элементов первого списка и второго списков.
#      Затем с новой строки поступают элементы первого отсортированного списка, а со следующей строки - второго списка.
#      Выходные данные: Слить два списка в один в порядке неубывания и вывести элементы полученного списка
#      P.S: пользоваться встроенной сортировкой запрещено.

n, m = map(int,input().split())
union = list(map(int,input().split())) + list(map(int,input().split()))
result = []
while len(union) > 0:
    result.append(min(union))
    union.remove(min(union))
print(*result)

# 194. По случаю 100500-летия Берляндского государственного университета совсем скоро состоится бал! 
#      Уже n юношей и m девушек во всю репетируют вальс, менуэт, полонез и кадриль.
#      Известно, что на бал будут приглашены несколько пар юноша-девушка, причем уровень умений танцевать партнеров в каждой паре должен отличаться не более чем на единицу.
#      Для каждого юноши известен уровень его умения танцевать. Аналогично, для каждой девушки известен уровень ее умения танцевать. 
#      Напишите программу, которая определит наибольшее количество пар, которое можно образовать из n юношей и m девушек.
#      Входные данные: В первой строке записано целое число n (1 ≤ n ≤ 100) — количество юношей. 
#                      Вторая строка содержит последовательность a1, a2, ..., an (1 ≤ ai ≤ 100), где ai — умение танцевать i-го юноши.
#                      Аналогично, третья строка содержит целое m (1 ≤ m ≤ 100) – количество девушек. 
#                      В четвертой строке содержится последовательность b1, b2, ..., bm (1 ≤ bj ≤ 100), где bj — умение танцевать j-й девушки.
#      Выходные данные: Выведите единственное число — искомое максимальное возможное количество пар.

n, skill_n = int(input()), list(map(int, input().split()))
m, skill_m = int(input()), list(map(int, input().split()))
i = j = c = 0
skill_n.sort(), skill_m.sort()
while i < n and j < m:
    if abs(skill_n[i] - skill_m[j]) <= 1: c += 1; i += 1; j += 1
    elif skill_n[i] < skill_m[j]: i += 1
    else: j += 1
print(c)

# 195. Программа принимает на вход одно натуральное число и выводит его цифры в столбик в обратном порядке.

x = int(input())
while x > 0: print(x % 10); x //= 10

# 196. Программа принимает на вход одно натуральное число и выводит на экран сумму цифр данного числа.

x, s = int(input()), 0
while x > 0: s += x % 10; x //= 10
print(s)

# 197. Программа принимает на вход одно натуральное число и выводит на экран произведение цифр данного числа.

x, s = int(input()), 1
while x > 0: s *= x % 10; x //= 10
print(s)

# 198. Программа принимает на вход одно натуральное число и выводит на экран минимальную и максимальную цифры данного числа в отдельных строчках.

x = int(input())
maximum, minimum = 0, 9
while x > 0: 
    last = x % 10
    if last >= maximum: maximum = last    
    if last <= minimum: minimum = last
    x //= 10    
print(minimum, maximum, sep='\n')

# 199. Программа принимает на вход одно натуральное число. Ваша задачи найти сколько раз встречается цифра 7 в этом числе.

x, c = int(input()), 0
while x > 0:
    if x % 10 == 7: c += 1
    x //= 10
print(c)

# 200. Программа принимает на вход одно натуральное число и выводит его цифры в двоичной системе в столбик в обратном порядке.

x = int(input())
while x > 0: print(x % 2); x //= 2

# 201. Дано натуральное число N. Определить, является ли оно простым. Натуральное число N называется простым, если у него есть только два делителя: единица и само число N. 
#      В качестве ответа выведите "Yes", если число простое,  "No" - в противном случае.

n, i, l = int(input()), 1, []
while i ** 2 <= n:
    if n % i == 0:
        l.append(i)
        if i != n // i:
            l.append(n // i)
    i += 1        
print('Yes' if len(l) == 2 else 'No')

# 202. Программа получает на вход натуральное число N. Нужно найти сумму его делителей.

n, i, s = int(input()), 1, 0
while i <= n * 0.5:
    if n % i == 0: s += i
    i += 1
print(s + n)

# 203. Даны два натуральных числа A и B. Требуется найти их наибольший общий делитель (НОД) методом вычитания.

a, b = map(int, input().split())
while a != b:
    if a > b: a -= b
    else: b -= a
print(a)

# 204. Та же самая задача, необходимо найти НОД двух чисел, только теперь нужно модернизировать свой код при помощи нахождения остатка от деления.

a, b = map(int, input().split())
while b > 0:
    a, b = b, a % b
print(a)

# 205. Даны два натуральных числа A и B. Требуется найти их наименьшее общее кратное (НОК).

a, b = map(int, input().split())
c = a * b
while b > 0:
    a, b = b, a % b
print(int(c / a) if a > b else int(c / b))

# 206. Программа получает на вход натуральное число n > 1. Выведите минимальный делитель этого числа, отличный от единицы.

n, x = int(input()), 2
while n % x: x += 1
print(x)

# 207. Давайте переберем все числа от а до b включительно и будем их выводить на экран, при этом нужно выполнить следующие условия:
#      - пропускать (не выводить) числа, которые делятся на 2 или на 3
#      - если встречаете число, кратное 777, необходимо принудительно закончить цикл, само это число не выводить
#      Формат ввода: Вводится два натуральных числа a и b в отдельных строках. Гарантируется, что a<b.
#      Формат вывода: Вывести все числа на интервале от a до b включительно согласно условиям в пунктах 1 и 2

a, b = int(input()), int(input())
while a <= b:
    if a % 777 == 0:
        break
    if a % 2 and a % 3:
        print(a)
    a += 1

# 208. Сиракузская последовательность, или последовательность Коллатца, строится так: возьмём натуральное число n; если оно чётное, то заменим его числом n/2; 
#      если же оно нечётное, то заменим его числом 3n+1. Получившееся число — следующее в сиракузской последовательности после числа n. 
#      Затем заменяем получившееся число по тому же правилу, и так далее.
#      Обычно, если проделать такую замену достаточно много раз, мы приходим к числу 1 (за которым следует снова 1). Например: 8 → 4 → 2 → 1 или 10 → 5 → 16 → 8 → 4 → 2 → 1.
#      Определите, сколько шагов потребуется сиракузской последовательности, стартующей с заданного числа, чтобы прийти к 1.
#      Если вы обнаружите число, сиракузская последовательность от которого не приходит к 1, то... вы, скорее всего, ошиблись. 
#      Но если нет, то поздравляем: вы прославитесь, ведь вопрос о том, всегда ли сиракузская последовательность приходит к 1 (независимо от начального числа), давно будоражит умы математиков.
#      Формат ввода: Вводится одно натуральное число n.
#      Формат вывода: Выводится одно число — количество шагов, необходимое стартующей от n сиракузской последовательности, чтобы впервые дойти до 1.

n, c = int(input()), 0
while n != 1:
    c += 1
    n = 3 * n + 1 if n % 2 else n / 2
print(c)

# 209. Вам на вход поступает слово и ваша задача в цикле while обойти все его буквы и распечатать их в формате фразы: «Текущая буква: <letter>».
#      Как только вы встретите строчные английские буквы «e» или «a» нужно вывести фразу «Ага! Нашлась», перестать печатать буквы и принудительно выйти из цикла.
#      В случае, если в слове не оказалось букв «e» или «a» необходимо вывести фразу «Распечатали все буквы».

s = list(input())
while s:
    if s[0] in 'ea':
        print('Ага! Нашлась')
        break
    print(f'Текущая буква: {s[0]}')
    del s[0]
else:
    print('Распечатали все буквы')