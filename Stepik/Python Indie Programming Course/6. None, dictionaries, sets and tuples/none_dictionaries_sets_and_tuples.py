# 285. Создайте две переменные empty и empty_too, сохраните в них значение None.
#      При помощи оператора is выведите на первой строке результат их сравнения на равенство и затем на второй строке результат их сравнения на неравенсто.

print((empty := None) is (empty_too := None), empty is not empty_too, sep='\n')

# 286. Создайте список i_love_none из 50 элементов None и распечатайте его.

print(i_love_none := [None for _ in range(50)])

# 287. Сохраните в переменной my_tuple кортеж состоящий из 4 любых элементов. Распечатывать ничего не нужно, просто создайте кортеж.

my_tuple = (1,) * 4

# 288. Сохраните в переменной lonely кортеж из одного элемента: 777. Распечатайте на экран lonely.

print((lonely := (777,)))

# 289. Допишите программу ниже, чтобы она вывела через пробел в одной строке значения самого маленького и самого большого элементов кортежа my_tuple.

my_tuple = (-214, 181, -139, 448, -664, -66, 213, 832, 717, -462, -924, -706, -85, -244, -222, -340, -482, -518, -781, 759, -593, 905, -354, -377, 
            -141, -742, 383, -381, 109, -639, -480, -810, -686, 892, -612, 696, 993, 791, 631, -493, -218, -829, -275, 619, -628, -241, -565, -835, 
            -69, 747, 711, -252, -811, -407, -153, 904, 933, -254, 307, -493, -419, -109, -543, 155, -127, 613, -452, -459, 856, 562, 333, -66, -77, 
            -598, -779, -278, 867, 321, -20, -415, -357, 735, -906, -14, -370, 453, -630, -736, -830, -917, 32, 422, -895, 198, 284, 472, -986, -964, -73, 29)
print(min(my_tuple), max(my_tuple))

# 290. Допишите программу ниже, чтобы она вывела среднее арифметическое всех элементов кортежа my_tuple.

my_tuple = (-214, 181, -139, 448, -664, -66, 213, 832, 717, -462, -924, -706, -85, -244, -222, -340, -482, -518, -781, 759, -593, 905, -354, -377, 
            -141, -742, 383, -381, 109, -639, -480, -810, -686, 892, -612, 696, 993, 791, 631, -493, -218, -829, -275, 619, -628, -241, -565, -835, 
            -69, 747, 711, -252, -811, -407, -153, 904, 933, -254, 307, -493, -419, -109, -543, 155, -127, 613, -452, -459, 856, 562, 333, -66, -77, 
            -598, -779, -278, 867, 321, -20, -415, -357, 735, -906, -14, -370, 453, -630, -736, -830, -917, 32, 422, -895, 198, 284, 472, -986, -964, -73, 29)
print(sum(my_tuple) / len(my_tuple))

# 291. При помощи операций сцепления и дублирования сохраните в переменной result следующий кортеж: 
#      (1, 1, 1, 'R', 'R', 'R', 'R', 'R', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 2, 2, 2, 2, 2)
#      Он состоит из:
#      - трех единиц
#      - пяти букв R
#      - восьми букв A
#      - пяти цифр 2
#      Для удобства можете пользоваться переменными a b c d. В качестве ответа выведите содержимое переменной result.

a = (1,) * 3
b = ('R',) * 5
c = ('A',) * 8
d = (2,) * 5
print(a + b + c + d)

# 292. Сформировать кортеж, содержащий натуральные числа в интервале [a; b] и вывести его на экран.
#      Формат ввода: Вводится два натуральных числа a и b в отдельных строках. Гарантируется, что a<b.
#      Формат вывода: Вывести кортеж, содержащий натуральные числа в интервале [a; b].

print(tuple([*range(int(input()), int(input()) + 1)]))

# 293. Сформировать кортеж, содержащий нечетные натуральные числа в интервале [n;n**2] и вывести его на экран.
#      Формат ввода: Вводится натуральное число n.
#      Формат вывода: Вывести кортеж, содержащий нечетные натуральные числа в интервале [n;n**2].

print((lambda n: tuple(i for i in range(n, n ** 2 + 1) if i % 2))(int(input())))

# 294. Перед вами кортеж my_tuple. Выведите сперва на отдельной строке элемент, хранящийся под индексом 44, а затем на следующей строке - девятое с конца значение.

my_tuple = (32, 45, 32, 60, 43, 19, 39, 75, 50, 12, 53, 13, 28, 70, 68, 5, 64, 55, 30, 47, 23, 20, 17, 36, 45, 
            31, 46, 50, 33, 45, 9, 41, 12, 57, 40, 43, 47, 51, 56, 54, 40, 30, 37, 23, 43, 66, 64, 27, 44, 75, 
            51, 2, 19, 72, 30, 8, 29, 43, 7, 73, 34, 65, 54, 50, 43, 6, 50, 45, 49, 30, 39, 50, 41, 70, 38, 16, 
            31, 51, 72, 45, 58, 39, 50, 56, 24, 30, 9, 53, 27, 31, 68, 56, 26, 39, 34, 50, 10, 12, 3, 27)
print(my_tuple[44], my_tuple[-9], sep='\n')

# 295. Перед вами кортеж my_tuple. При помощи среза сохраните:
#      - в переменную slice_5_10 значения с 5-го индекса по 10-й включительно
#      - в переменную slice_from_20 значения с 20-го индекса и по конец кортежа
#      - в переменную slice_to_35 значения с начала кортежа по 35-й индекс не включительно
#      Распечатайте данные переменные на отдельных строках в порядке их перечисления.

my_tuple = (32, 45, 32, 60, 43, 19, 39, 75, 50, 12, 53, 13, 28, 70, 68, 5, 64, 55, 30, 47, 23, 20, 17, 36, 45, 
            31, 46, 50, 33, 45, 9, 41, 12, 57, 40, 43, 47, 51, 56, 54, 40, 30, 37, 23, 43, 66, 64, 27, 44, 75, 
            51, 2, 19, 72, 30, 8, 29, 43, 7, 73, 34, 65, 54, 50, 43, 6, 50, 45, 49, 30, 39, 50, 41, 70, 38, 16, 
            31, 51, 72, 45, 58, 39, 50, 56, 24, 30, 9, 53, 27, 31, 68, 56, 26, 39, 34, 50, 10, 12, 3, 27)
slice_5_10 = my_tuple[5:11]
slice_from_20 = my_tuple[20:]
slice_to_35 = my_tuple[:35]
print(slice_5_10)
print(slice_from_20)
print(slice_to_35)

# 296. При помощи среза разверните/переверните кортеж my_tuple и распечатайте на экран полученное значение.
#      Развернуть(reverse) кортеж или любую другую упорядоченную коллекцию это значит расположить элементы в обратном порядке от последнего до первого.

my_tuple = (32, 45, 32, 60, 43, 19, 39, 75, 50, 12, 53, 13, 28, 70, 68, 5, 64, 55, 30, 47, 23, 20, 17, 36, 45, 
            31, 46, 50, 33, 45, 9, 41, 12, 57, 40, 43, 47, 51, 56, 54, 40, 30, 37, 23, 43, 66, 64, 27, 44, 75, 
            51, 2, 19, 72, 30, 8, 29, 43, 7, 73, 34, 65, 54, 50, 43, 6, 50, 45, 49, 30, 39, 50, 41, 70, 38, 16, 
            31, 51, 72, 45, 58, 39, 50, 56, 24, 30, 9, 53, 27, 31, 68, 56, 26, 39, 34, 50, 10, 12, 3, 27)
print(my_tuple[::-1])

# 297. Нужно посчитать и вывести на экран сколько раз встречается значение 50 в кортеже my_tuple.

my_tuple = (32, 45, 32, 60, 43, 19, 39, 75, 50, 12, 53, 13, 28, 70, 68, 5, 64, 55, 30, 47, 23, 20, 17, 36, 45, 
            31, 46, 50, 33, 45, 9, 41, 12, 57, 40, 43, 47, 51, 56, 54, 40, 30, 37, 23, 43, 66, 64, 27, 44, 75, 
            51, 2, 19, 72, 30, 8, 29, 43, 7, 73, 34, 65, 54, 50, 43, 6, 50, 45, 49, 30, 39, 50, 41, 70, 38, 16, 
            31, 51, 72, 45, 58, 39, 50, 56, 24, 30, 9, 53, 27, 31, 68, 56, 26, 39, 34, 50, 10, 12, 3, 27)
print(my_tuple.count(50))

# 298. Перед вами кортеж words_tuple. При помощи цикла for обойдите слова, хранящиеся в кортеже words_tuple, и для каждого элемента выведите строку вида:
#      Длина слова {word} = {len_word}
#      Например, для кортежа words_tuple=('hi', 'world') ответ был бы таким:
#      Длина слова hi = 2
#      Длина слова world = 5

words_tuple = ('quaint', 'leftovers', 'thesis', 'density', 'retired', 'weak', 'tolerate',
               'sensitivity', 'primary', 'definition', 'determine', 'bring', 'monstrous',
               'hurl', 'timetable', 'month', 'advocate', 'provoke', 'stress', 'omission')
[print(f'Длина слова {word} = {len(word)}') for word in words_tuple]

# 299. Допишите программу ниже, чтобы она вывела среднее арифметическое всех нечетных значений, хранящихся в кортеже my_tuple.

my_tuple = (-214, 181, -139, 448, -664, -66, 213, 832, 717, -462, -924, -706, -85, -244, -222, -340, -482, -518, -781, 759, -593, 905, -354, -377, -141, 
            -742, 383, -381, 109, -639, -480, -810, -686, 892, -612, 696, 993, 791, 631, -493, -218, -829, -275, 619, -628, -241, -565, -835, -69, 747, 
            711, -252, -811, -407, -153, 904, 933, -254, 307, -493, -419, -109, -543, 155, -127, 613, -452, -459, 856, 562, 333, -66, -77, -598, -779, 
            -278, 867, 321, -20, -415, -357, 735, -906, -14, -370, 453, -630, -736, -830, -917, 32, 422, -895, 198, 284, 472, -986, -964, -73, 29)
print(sum([i for i in my_tuple if i % 2]) / len([i for i in my_tuple if i % 2]))

# 300. Создайте пустой словарь и сохраните его в переменную my_dict, затем выведите на экран эту переменную.

print(my_dict := {})

# 301. Создайте словарь, у которого должны быть следующие пары ключ-значения:
#      Ключ	                Значение
#      name - строка	 Vasya - строка
#      surname - строка	 Petrov - строка
#      age - строка	     25 - целое число
#      Данный словарь необходимо сохранить в переменную person и затем вывести эту переменную на экран.

print(person := dict(name='Vasya', surname='Petrov', age=25))

# 302. Перед вами имеется словарь sweet. В отдельных строках распечатайте сперва значение ключа name, потом calories и напоследок id.

sweet = {
    "id": "0001",
    "type": "donut",
    "name": "Cake",
    "ppu": 0.55,
    "calories": 125,
}
print(sweet["name"], sweet["calories"], sweet["id"], sep='\n')

# 303. В вашем распоряжении имеется словарь days, в котором в качестве ключей хранится номера месяца, 
#      а в качестве значения - количество дней в соответствующем месяце (будем исключать високосные года и полагать, что в феврале всегда 28 дней)
#      Ваша программа получает на вход номер месяца, гарантируется что это будет число в пределах от 1 до 12. Ваша задача по введеному номеру месяца вывести количество дней.

days = {
    1: 31,
    2: 28,
    3: 31,
    4: 30,
    5: 31,
    6: 30,
    7: 31,
    8: 31,
    9: 30,
    10: 31,
    11: 30,
    12: 31
}
print(days[int(input())])

# 304. Перед вами имеется словарь sweet. Ваша задача:
#      - создать строковый ключ weight с целым значением 230
#      - создать строковый ключ have_topping c булевым значением True
#      - изменить значение ключа name на строку SuperCake
#      - изменить значение ключа calories на целое число 350
#      В качестве ответа распечатайте в конце словарь sweet.

sweet = {
    "id": "0001",
    "type": "donut",
    "name": "Cake",
    "ppu": 0.55,
    "calories": 125,
}
sweet["weight"], sweet["have_topping"], sweet["name"], sweet["calories"] = 230, True, "SuperCake", 350
print(sweet)

# 305. Перед вами имеется словарь sweet. Удалите из него ключи ppu и type. Затем выведите словарь sweet в качестве ответа.

sweet = {
    "id": "0001",
    "type": "donut",
    "name": "Cake",
    "ppu": 0.55,
    "calories": 125,
}
del sweet["ppu"], sweet["type"]
print(sweet)

# 306. На вход программе поступает целое число n. Вам необходимо создать словарь, который будет включать в себя ключи от 1 до n, 
#      а значениями соответствующего ключа будет значение ключа в квадрате. В качестве ответа выведите полученный словарь.

print({i: i ** 2 for i in range(1, int(input()) + 1)})

# 307. Напишите программу, которая печатает словарь alphabet, где ключи  - строчные английские символы, а значения - порядковые номера букв в алфавите начиная с 1.
#      Начало вашего словаря должны быть таким {"a": 1, "b": 2 ... }. В качестве ответа распечатайте полученный словарь alphabet.

from string import ascii_lowercase
alphabet = {ascii_lowercase[i-1]: i for i in range(1, 27)}
print(alphabet)

# 308. Найдите «длину» словаря account.

account = {
  "id": 5681,
  "uid": "45f17b56-bcad-4933-8c73-a37aaa6863b9",
  "account_number": "6733198878",
  "iban": "GB79PNXF20678598570754",
  "bank_name": "AAC CAPITAL PARTNERS LIMITED",
  "routing_number": "007398728",
  "swift_bic": "AACCGB21"
}
print(len(account))

# 309. Перед вами располагается словарь address. Давайте проверим наличие следующих ключей:
#      - zip_code
#      - longitude
#      - post_code
#      - street_name
#      - number_house
#      Программа должна проверить наличие ключей и вывести True, если ключ имеется,  или False, если ключ отсутствует.
#      Проверки ключей должны выполняться в отдельной строчке в порядке перечисления ключей в задании.

address = {
  "id": 7973,
  "uid": "42f2ce1d-90ab-4345-9595-0d9f42e6c085",
  "city": "East Monteland",
  "street_name": "Gusikowski Land",
  "street_address": "3230 Daugherty Centers",
  "secondary_address": "Apt. 562",
  "building_number": "58671",
  "mail_box": "PO Box 5313",
  "community": "Paradise Square",
  "zip_code": "58611",
  "zip": "01667",
  "postcode": "00563",
  "time_zone": "America/New_York",
  "street_suffix": "Burg",
  "city_suffix": "mouth",
  "city_prefix": "West",
  "state": "Wisconsin",
  "state_abbr": "NY",
  "country": "Mali",
  "country_code": "MH",
  "latitude": -56.97457993706476,
  "longitude": -104.29509072140858,
  "full_address": "Apt. 982 4820 Leena Rest, Lake Giannaville, MN 09265-3715"
}
[print(key in address) for key in ('zip_code', 'longitude', 'post_code', 'street_name', 'number_house')]

# 310. У нас есть словарь currencies, в котором хранятся валюты и их курсы. В словаре представлены далеко не все валюты.
#      Ваша программа принимает на вход название валюты, проверяет присутствует ли данная валюта в словаре.
#      Если валюта присутствует необходимо вывести ее курс, если отсутствует - строку Нет данных по <валюта>.

currencies = {
    'Argentine Peso': 118362.205708,
    'Australian Dollar': 1586.232315,
    'Bahraini Dinar': 423.780164,
    'Botswana Pula': 13168.450636,
    'Brazilian Real': 5954.781483,
    'British Pound': 834.954104,
    'Bruneian Dollar': 1520.451015,
    'Bulgarian Lev': 1955.83,
    'Canadian Dollar': 1430.54405,
    'Chilean Peso': 898463.818465,
    'Chinese Yuan Renminbi': 7171.445692,
    'Colombian Peso': 4447741.922165,
    'Croatian Kuna': 7527.744707,
    'Czech Koruna': 24313.797041,
    'Danish Krone': 7440.613895,
    'Emirati Dirham': 4139.182587,
    'Hong Kong Dollar': 8786.255952,
    'Hungarian Forint': 355958.035747,
    'Icelandic Krona': 143603.932438,
    'Indian Rupee': 84241.767127,
    'Indonesian Rupiah': 16187150.010697,
    'Iranian Rial': 47534006.535121,
    'Israeli Shekel': 3569.191411,
    'Japanese Yen': 129149.364679,
    'Kazakhstani Tenge': 489292.515538,
    'Kuwaiti Dinar': 340.959682,
    'Libyan Dinar': 5196.539901,
    'Malaysian Ringgit': 4717.485104,
    'Mauritian Rupee': 49212.933037,
    'Mexican Peso': 23130.471272,
    'Nepalese Rupee': 134850.008728,
    'New Zealand Dollar': 1703.649473,
    'Norwegian Krone': 9953.078431,
    'Omani Rial': 433.360301,
    'Pakistani Rupee': 198900.635421,
    'Philippine Peso': 57574.278782,
    'Polish Zloty': 4579.273862,
    'Qatari Riyal': 4102.552652,
    'Romanian New Leu': 4946.638369,
    'Russian Ruble': 86197.012666,
    'Saudi Arabian Riyal': 4226.530892,
    'Singapore Dollar': 1520.451015,
    'South African Rand': 17159.831129,
    'South Korean Won': 1355490.097163,
    'Sri Lankan Rupee': 228245.645722,
    'Swedish Krona': 10439.125427,
    'Swiss Franc': 1037.792217,
    'Taiwan New Dollar': 31334.286611,
    'Thai Baht': 37436.518169,
    'Trinidadian Dollar': 7636.35428,
    'Turkish Lira': 15078.75981,
    'US Dollar': 1127.074905,
    'Venezuelan Bolivar': 511082584.868731
}
print(currencies[c] if (c := input()) in currencies else f'Нет данных по {c}')

# 311. Перед вами словарь account.Ваша задача сохранить в переменную keys список из всех ключей словаря account при помощи функции list.
#      В качестве ответа выведите переменную keys.

account = {
  "id": 3136,
  "uid": "1359acc6-f07a-4a2a-984e-3fb809982948",
  "account_number": "0847799459",
  "iban": "GB90XTND56373623909314",
  "bank_name": "ABN AMRO HOARE GOVETT CORPORATE FINANCE LTD.",
  "routing_number": "126602476",
  "swift_bic": "BCYPGB2LHGB"
}
print(keys := list(account))

# 312. Перед вами два словаря d1 и d2. Ваша задача выполнить слияние этих словарей в переменную capitals и затем вывести ее на экран.

d1 = {'India': 'Delhi',
      'Canada': 'Ottawa',
      'United States': 'Washington D. C.'}

d2 = {'France': 'Paris',
      'Malaysia': 'Kuala Lumpur'}
print(capitals := d1 | d2)

# 313. Есть два словаря, нужно в словарь d2 вмержить словарь d1 при помощи метода update. В качестве ответа выведите словарь d2.

d1 = {'a': 100, 'b': 200, 'c': 333}
d2 = {'x': 300, 'y': 200, 'z': 777}
d2.update(d1)
print(d2)

# 314. В скором времени в Берляндии откроется новая почтовая служба "Берляндеск". Администрация сайта хочет запустить свой проект как можно быстрее, 
#      поэтому они попросили Вас о помощи. Вам предлагается реализовать прототип системы регистрации сайта. Система должна работать по следующему принципу. 
#      Каждый раз, когда новый пользователь хочет зарегистрироваться, он посылает системе запрос name со своим именем. 
#      Если данное имя не содержится в базе данных системы, то оно заносится туда и пользователю возвращается ответ OK, подтверждающий успешную регистрацию. 
#      Если же на сайте уже присутствует пользователь с именем name, то система формирует новое имя и выдает его пользователю в качестве подсказки, 
#      при этом подсказка также добавляется в базу данных. Новое имя формируется по следующему правилу. 
#      К name последовательно приписываются числа, начиная с единицы (name1, name2, ...), и среди них находят такое наименьшее i, что namei не содержится в базе данных сайта.
#      Входные данные: В первой строке входных данных задано число n (1 ≤ n ≤ 105). Следующие n строк содержат запросы к системе. 
#      Каждый запрос представляет собой непустую строку длиной не более 32 символов, состоящую только из строчных букв латинского алфавита.
#      Выходные данные: В выходных данных должно содержаться n строк — ответы системы на запросы: OK в случае успешной регистрации, 
#      или подсказку с новым именем, если запрашиваемое уже занято.

n = int(input())
d = {}
for i in range(n):
    s = input()
    if s in d:
        d[s] += 1
        d[f"{s}{d[s]}"] = 0
        print(f"{s}{d[s]}")
    else:
        d[s] = 0
        print(f'OK')

# 315. Переменные countries соединяют ряд стран с тремя крупнейшими городами каждой страны. 
#      Программе на вход будет поступать название города в переменную city. И ваша задача найти какой стране принадлежит введенный город. 
#      Если страна успешно найдена, необходимо вывести сообщение:
#      INFO: <City> is a city in <Country>
#      в противном случае
#      ERROR: Country for {City} not found
#      Учитывайте, что регистр букв имеет значение.

countries = {
    "Sweden": ["Stockholm", "Göteborg", "Malmö"],
    "Norway": ["Oslo", "Bergen", "Trondheim"],
    "England": ["London", "Birmingham", "Manchester"],
    "Germany": ["Berlin", "Hamburg", "Munich"],
    "France": ["Paris", "Marseille", "Toulouse"]
}
city = input()
for k, v in countries.items():
    if city in v:
        print(f'INFO: {city} is a city in {k}')
        break
else:
    print(f'ERROR: Country for {city} not found')
    
# 316. Перед вами словарь user. При помощи метода pop переименуйте в нем следующие ключи:
#      - ключ password в ключ secret
#      - ключ last_name в ключ surname
#      Выводить ничего не нужно, только изменить ключи словаря.

user = {
    "id": 4170,
    "uid": "5e941db5-9e0f-4f94-9fc5-734110c6be14",
    "password": "SyUpfo1ljm",
    "first_name": "Teresa",
    "last_name": "Wehner",
    "username": "teresa.wehner",
    "email": "teresa.wehner@email.com",
    "gender": "Non-binary",
    "phone_number": "+674 424.561.2776",
    "social_insurance_number": "637316241",
    "date_of_birth": "1993-08-17"
}
user['secret'] = user.pop('password')
user['surname'] = user.pop('last_name')

# 317. Напишите код для преобразования списка из целых чисел произвольной длины в словарь, вложенность которого зависит от длины списка.
#      Например, если перед вами был бы такой список [100, 55, 77, 55, 89], то он должен превратиться в такой словарь {100: {55: {77: {55: 89}}}}.
#      На вход программе поступают числа для списка в одну строку, гарантируется, что в списке будет как минимум два элемента. Ваша задача вывести полученный словарь.

l = [int(i) for i in input().split()]
d = l.pop()
while l:
    d = {l.pop(): d}
print(d)

# 318. Перед вами словарь workers. Ваша задача поднять зарплату Бреду до 8500 и затем вывести измененный словарь workers.

workers = {
    'employer1': {'name': 'Jhon', 'salary': 7500},
    'employer2': {'name': 'Emma', 'salary': 8000},
    'employer3': {'name': 'Brad', 'salary': 500}
}
workers['employer3']['salary'] = 8500
print(workers)

# 319. Мы уже с вами подсчитывали сколько раз встречается число в списке при помощи метода подсчета. Там мы использовали список для хранения найденного количества.
#      Теперь ваша задача научиться использовать словарь для подсчета количества. Вашей программе поступает на вход строка, вам необходимо подсчитать сколько раз 
#      встретилась каждая буква в этой строке без учета регистра, при этом цифры и символы пунктуации нужно пропустить. 
#      Ответ нужно сохранить в словаре, в котором ключ - буква, а значение - количество раз, сколько эта буква встретилась в строке. В качестве ответа нужно вывести словарь.

s, d = input().lower(), {}
for char in s:
    if char.isalpha(): d[char] = d.get(char, 0) + 1
print(d)

# 320. Cтрока S1 называется анаграммой строки S2, если она получается из S2 перестановкой символов.
#      Программа получает на вход две строки S1 и S2. Если строка S1 является анаграммой строки S2 нужно вывести YES, в противном случае - NO.

s1, s2 = input(), input()
d1 = {a: s1.count(a) for a in s1}
d2 = {b: s2.count(b) for b in s2}
print('YES' if d1 == d2 else 'NO')

# 321. Вам дан английский текст. Закодируйте его с помощью азбуки Морзе.Каждая буква заменяется на последовательность точек и тире. 
#      В качестве тире используйте обычный дефис: «-», а в качестве точки — точку «.». Например, буква «g» превратится в трёхсимвольную строку «--.». 
#      Ниже в переменной morze для вашего удобства хранится словарь соответствия английских букв коду Морзе. 
#      Формат ввода: Весь текст записан в единственной строке. Текст состоит из английских букв и пробелов, других символов в тексте нет. В тексте не может быть двух или более пробелов подряд.
#      Формат вывода: Выведите каждое слово исходного текста, закодированное азбукой Морзе, на отдельной строке. Количество строк в ответе должно совпадать с количеством слов в исходном тексте. 
#      Между закодированными буквами нужно ставить ровно один пробел. Например, слово «Help» превратится в «.... . .-.. .--.». Обратите внимание, что строчные и заглавные буквы кодируются одинаково.

morze = {'a': '•—', 'b': '—•••', 'c': '—•—•', 'd': '—••',
         'e': '•', 'f': '••—•', 'g': '——•', 'h': '••••',
         'i': '••', 'j': '•———', 'k': '—•—', 'l': '•—••',
         'm': '——', 'n': '—•', 'o': '———', 'p': '•——•',
         'q': '——•—', 'r': '•—•', 's': '•••', 't': '—',
         'u': '••—', 'v': '•••—', 'w': '•——', 'x': '—••—',
         'y': '—•——', 'z': '——••'}
for i in input().lower().split():
    for j in i:
        print(morze[j], end=' ')
    print() 

# 322. На основании переменной persons, в которой хранится список кортежей, в каждом кортеже хранится имя, зарплата, пол и паспорт человека.
#      Ваша задача создать словарь, где ключами будут имена, а значениями словарь из трех ключей: salary, gender и passport.
#      К примеру, если у вас есть изначально следующий список:
#      [
#       ('Bob Moore', 330000, 'M', '1635777202'),
#       ('Gina Moore', 12500, 'F', '1639999999'),
#      ]
#      то из него должен получится следующий словарь:
#      {
#         'Bob Moore': {
#             'salary': 330000,
#             'gender': 'M',
#             'passport': '1635777202'
#         },
#         'Gina Moore': {
#             'salary': 12500,
#             'gender': 'F',
#             'passport': '1639999999'
#         }
#      }
#      Сохраните результирующий словарь в переменную data, больше от вас ничего не требуется, просто нужно сформировать словарь указанной структуры. Повторюсь, выводить на экран ничего не нужно.

persons= [
    ('Allison Hill', 334053, 'M', '1635644202'),
    ('Megan Mcclain', 191161, 'F', '2101101595'),
    ('Brandon Hall', 731262, 'M', '6054749119'), 
    ('Michelle Miles', 539898, 'M', '1355368461'),
    ('Donald Booth', 895667, 'M', '7736670978'), 
    ('Gina Moore', 900581, 'F', '7018476624'),
    ('James Howard', 460663, 'F', '5461900982'), 
    ('Monica Herrera', 496922, 'M', '2955495768'),
    ('Sandra Montgomery', 479201, 'M', '5111859731'), 
    ('Amber Perez', 403445, 'M', '0602870126')
]
data = {}
for i in persons:
    data[i[0]] = {'salary': i[1], 'gender': i[2], 'passport': i[3]}
    
# 323. В этой задаче вам предстоит достать определенные данные из словаря data. Он уже будет определен и заполнен данными, 
#      поэтому никакого ввода значений в этой программе делать не нужно, просто обращаетесь к переменной data.
#      У словаря data следующая структура ключей, хорошо рассмотрите ее:
#      {
#        "my_friends": {
#           "count": ...,
#           "people": [
#           {
#             "first_name": value,
#             "id": value,
#             "last_name": value,
#           },
#           {
#             "first_name": value,
#             "id": value,
#             "last_name": value,
#           }, 
#             ......
#          ]
#        }
#      }
#      Ваша задача получить значения ключа first_name у всех элементов и вывести их в алфавитном порядке, каждое имя с новой строки.

data = {
    "my_friends": {
        "count": 10,
        "people": [{
            "first_name": "Kurt",
            "id": 621547005,
            "last_name": "Cobain",
            "bdate": "31.8.2005"
        }, {
            "first_name": "Виолетта",
            "id": 484200150,
            "last_name": "Кастилио",
        }, {
            "first_name": "Иринка",
            "id": 21886133,
            "last_name": "Бушуева",
            "bdate": "28.8.1942"
        }, {
            "first_name": "Данил",
            "id": 282456573,
            "last_name": "Греков",
            "bdate": "4.7.2002"
        }, {
            "first_name": "Валентин",
            "id": 184902932,
            "last_name": "Долматов",
            "bdate": "25.5"
        }, {
            "first_name": "Евгений",
            "id": 620469646,
            "last_name": "Шапорин",
            "bdate": "6.12.1982"
        }, {
            "first_name": "Ангелина",
            "id": 622328862,
            "last_name": "Краснова",
            "bdate": "4.11.1995"
        }, {
            "first_name": "Иван",
            "id": 576015198,
            "last_name": "Вирин",
            "bdate": "2.2.1915"
        }, {
            "first_name": "Паша",
            "id": 386922406,
            "last_name": "Воронов",
            "bdate": "27.9"
        }, {
            "first_name": "Ольга",
            "id": 622170942,
            "last_name": "Савченкова",
            "bdate": "20.12"
        }]
    }
}
l = [*sorted(i["first_name"] for i in data["my_friends"]["people"])]
print(*(name for name in l), sep='\n')

# 324. Перед вами словарь user. Напишите программу для создания нового словаря, которая извлекает указанные ключи из приведенного ниже словаря.
#      Сами значения ключей, которые нужно извлечь, поступают на вход программе в виде одной строки разделенные пробелом. 
#      В качестве ответа выведите на экран полученный словарь.

user = {
    "id": 4170,
    "uid": "5e941db5-9e0f-4f94-9fc5-734110c6be14",
    "password": "SyUpfo1ljm",
    "first_name": "Teresa",
    "last_name": "Wehner",
    "username": "teresa.wehner",
    "email": "teresa.wehner@email.com",
    "gender": "Non-binary",
    "phone_number": "+674 424.561.2776",
    "social_insurance_number": "637316241",
    "date_of_birth": "1993-08-17",
    "employment": {
        "title": "Central Hospitality Liaison",
        "key_skill": "Organisation"
    },
    "subscription": {
        "plan": "Essential",
        "status": "Idle",
        "payment_method": "Debit card",
        "term": "Annual"
    }
}
print({i: user[i] for i in input().split()})

# 325. В вашем распоряжении имеется вложенный список people, в котором хранятся имена и телефоны. Ваша задача создать словарь при помощи генератора словарей, 
#      в котором в качестве ключей будут храниться номера телефонов, а значениями будут имена владельцев. Обязательно сохраните этот словарь в переменной phone_book.
#      Выводить ничего не нужно, только правильно заполните словарь в переменной phone_book.

people = [
    ['Amy Smith', '694.322.8133x22426'],
    ['Brian Shaw', '593.662.5217x338'],
    ['Christian Sharp', '118.197.8810'],
    ['Sean Schmidt', '9722527521'],
    ['Thomas Long', '163.814.9938'],
    ['Joshua Willis', '+1-978-530-6971x601'],
    ['Ann Hoffman', '434.104.4302'],
    ['John Leonard', '(956)182-8435'],
    ['Daniel Ross', '870-365-8303x416'],
    ['Jacqueline Moon', '+1-757-865-4488x652'],
    ['Gregory Baker', '705-576-1122'],
    ['Michael Spencer', '(922)816-0599x7007'],
    ['Austin Vazquez', '399-813-8599'],
    ['Chad Delgado', '979.908.8506x886'],
    ['Jonathan Gilbert', '9577853541']
]
phone_book = {i[1]: i[0] for i in people}

# 326. Декартово произведение двух множеств — множество, элементами которого являются все возможные упорядоченные пары элементов исходных множеств. 
#      Под множествами в этой задачи мы будем считать списки, один из них будет содержать цвета маек, а другой размеры одежды. 
#      Если объяснять более простым языком, то  декартово произведение это когда вы каждый элемент из одного множества группируете с каждым элементом другого множества. 
#      Например, если бы у вас имелись такие списки:
#      colors = ['red', 'green']
#      sizes = ['S', 'M', 'L']
#      то их декартово произведение выглядело бы так:
#      [('red', 'S'), ('red', 'M'), ('red', 'L'), ('green', 'S'), ('green', 'M'), ('green', 'L')].
#      Здесь мы берем каждый цвет и сочетаем его с каждым размером. Общее количество элементов в данном декартовом множестве рассчитывается по формуле:
#      len(colors) * len(sizes)
#      Ваша задача создать список кортежей на основании переменных colors и sizes. 
#      Обратите внимание на порядок элементов в ответе, сперва мы берем первый цвет и для него перебираем все возможные размеры. Порядок формирования в этом задании важен.
#      В качестве ответа выведите на экран полученный список кортежей.

colors = ['White', 'Blue', 'Yellow', 'Purple', 'Black', 'Green']
sizes = ['S', 'M', 'L', 'XL', 'XLL']
print([(j, i) for j in colors for i in sizes])

# 327. В вашем распоряжении есть двумерный список vector. Ваша задача при помощи генератора-списка сделать на основании vector линейный (одномерный) список и вывести его.

vector = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12], [13, 14, 15], [16, 17, 18]]
print([j for i in vector for j in i])

# 328. Создайте пустое множество и сохраните его в переменную my_set, затем выведите на экран эту переменную.

print(my_set := set())

# 329. Перед вами располагается список my_list. Ваша задача в переменную my_set сохранить множество уникальных элементов, хранящихся в списке my_list. 
#      И в качестве ответа необходимо вывести среднее арифметическое всех элементов найденного множества my_set.

my_list = [56, 59, 53, 75, 62, 61, 75, 65, 59, 62, 64, 53,
           54, 62, 69, 53, 55, 62, 54, 66, 55, 57, 58, 75,
           72, 55, 51, 56, 71, 66, 57, 56, 59, 73, 68, 57,
           50, 54, 62, 68, 59, 64, 59, 59, 71, 68, 57, 54, 53, 72]
print(sum(my_set := set(my_list))/len(my_set))

# 330. В наши дни очень много парней ставят себе фотографии красивых девушек на аватарки на форумах. Из-за этого очень часто сложно определить пол пользователя на форуме. 
#      В прошлом году наш герой пообщался в чате на форуме с одной красоткой (как он думал). После этого наш герой и предполагаемая красотка стали общаться
#      еще чаще и в конце концов стали парой в сети. Но вчера наш герой захотел увидеть свою красотку в реальной жизни и, каково же было его удивление, 
#      когда красоткой оказался здоровенный мужчина! Наш герой очень расстроился и теперь он, наверное, никогда больше не сможет полюбить. 
#      Сейчас к нему пришла в голову идея, как по имени пользователя определить его пол.
#      Вот его метод: если количество различных символов в имени пользователя нечетное, тогда пользователь мужского пола, иначе — женского. 
#      Вам дана строка, обозначающая имя пользователя, помогите нашему герою определить по ней пол пользователя по описанному методу.
#      Входные данные: В первой строке записана непустая строка, состоящая только из строчных букв латинского алфавита — имя пользователя. Эта строка состоит из не более чем 100 букв.
#      Выходные данные: Если пользователь оказался женского пола по методу нашего героя, выведите «CHAT WITH HER!» (без кавычек), иначе, выведите «IGNORE HIM!» (без кавычек).

print('IGNORE HIM!' if len(s := set(input())) % 2 else 'CHAT WITH HER!')

# 331. Конь Валера собрался с друзьями на вечеринку. Он давно следит за тенденциями моды и поэтому знает, что сейчас очень популярно носить все подковы разного цвета. 
#      С прошлого года у Валеры остались четыре подковы, но, возможно, некоторые из них имеют одинаковый цвет. В этом случае, чтобы не ударить в грязь лицом перед 
#      своими стильными товарищами, ему нужно сходить в магазин и купить дополнительно несколько каких-нибудь подков. К счастью в магазине продаются подковы всех возможных цветов, 
#      и у Валеры имеется достаточно денег, чтобы купить любые четыре. Однако в целях экономии он хотел бы потратить как можно меньше денег, поэтому вам нужно помочь Валере и определить, 
#      какое минимальное количество подков нужно купить, чтобы он смог надеть на вечеринку четыре подковы различного цвета.
#      Входные данные: В первой строке через пробел записаны четыре целых числа s1, s2, s3, s4 (1 ≤ s1, s2, s3, s4 ≤ 109) — цвета подков, имеющихся у Валеры.
#      Считайте, что все возможные цвета пронумерованы целыми числами.
#      Выходные данные: Выведите единственное целое число — минимальное количество подков, которое нужно купить.

print(len(n := input().split()) - len(set(n)))

# 332. Слово или предложение на некотором языке называется панграммой, если в нем встречаются все символы алфавита этого языка хотя бы один раз. 
#      Панграммы часто используют в типографии для демонстрации шрифтов или тестирования средств вывода различных устройств.
#      Вам дана строка, состоящая из маленьких и больших латинских букв. Проверьте, является ли эта строка панграммой. 
#      Считается, что строка содержит букву латинского алфавита, если эта буква встречается в верхнем или нижнем регистре.
#      Входные данные: Программа получает на вход строку, содержащую исключительно строчные и заглавные латинские буквы.
#      Выходные данные: Выведите «YES», если строка является панграммой, и «NO» в противном случае.

print('NO' if 26 - len(set(input().lower())) else 'YES')

# 333. Кажется, еще совсем недавно наступил новый 2013 год. А знали ли Вы забавный факт о том, что 2013 год является первым годом после далекого 1987 года, в котором все цифры различны?
#      Теперь же Вам предлагается решить следующую задачу: задан номер года, найдите наименьший номер года, который строго больше заданного и в котором все цифры различны.
#      Входные данные: В единственной строке задано целое число year — номер года. Гарантируется, что входное значение всегда лежит в пределах 1000 ≤ year ≤ 9000.
#      Выходные данные: Выведите единственное целое число — минимальный номер года, который строго больше year, в котором все цифры различны. 
#      Гарантируется, что ответ существует и является четырехзначным числом, то есть не выходит за рамки значения 9999.

for year in range(int(input()) + 1, 10000):
    match len(set(str(year))):
        case 4: print(year); break

# 334. Недавно у Антона появилось множество, состоящее из маленьких латинских букв. Он аккуратно выписал все буквы, которые в него входят в одну строку через запятую. 
#      Для красоты он так же добавил в начало этой строки открывающуюся фигурную скобку, а в конец — закрывающуюся. К сожалению, Антон иногда забывал, что уже записал некоторую букву, 
#      и выписывал ее снова. Он просит вас посчитать общее число различных букв в его множестве.
#      Входные данные: В первой и единственной строке задано описание множества букв. Длина строки не превышает 1000. Гарантируется, что строка начинается с открывающейся фигурной скобки, 
#      а заканчивается закрывающейся. Между ними через запятую перечислены маленькие латинские буквы. После каждой запятой следует пробел.
#      Выходные данные: Выведите единственное число — количество различных букв в множестве Антона. 

print(len(set(input().replace('{', '').replace('}', '').replace(',', '').replace(' ', ''))))

# 335. Перед вами располагается два множества  set_a и set_b. Ваша задача вывести на экран количество элементов, которое содержится в результате пересечения множеств set_a и set_b.

set_a = {31, 37, 39, 41, 47, 58, 60, 62, 70, 75,
         76, 77, 78, 79, 80, 81, 85, 86, 88, 90, 93, 96, 98, 99}
set_b = {0, 1, 8, 16, 17, 18, 22, 24, 29, 31,
         33, 34, 36, 42, 46, 47, 51, 53, 62, 64, 65, 66, 67}
print(len(set_a & set_b))

# 336. Перед вами располагается два множества  set_a и set_b. Ваша задача вывести на экран количество элементов, которое содержится в результате объединения множеств set_a и set_b.

set_a = {31, 37, 39, 41, 47, 58, 60, 62, 70, 75,
         76, 77, 78, 79, 80, 81, 85, 86, 88, 90, 93, 96, 98, 99}
set_b = {0, 1, 8, 16, 17, 18, 22, 24, 29, 31,
         33, 34, 36, 42, 46, 47, 51, 53, 62, 64, 65, 66, 67}
print(len(set_a | set_b))

# 337. Перед вами располагается два множества  set_a и set_b. Ваша задача вывести на экран два числа в отдельных строках:
#      - сперва количество элементов, которое содержится в результате операции set_a - set_b 
#      - затем количество элементов, которое содержится в результате операции set_b - set_a

set_a = {31, 37, 39, 41, 47, 58, 60, 62, 70, 75,
         76, 77, 78, 79, 80, 81, 85, 86, 88, 90, 93, 96, 98, 99}
set_b = {0, 1, 8, 16, 17, 18, 22, 24, 29, 31,
         33, 34, 36, 42, 46, 47, 51, 53, 62, 64, 65, 66, 67}
print(len(set_a - set_b), len(set_b - set_a), sep='\n')

# 338. Перед вами располагается два множества  set_a и set_b. 
#      Ваша задача вывести на экран количество элементов, которое содержится в результате операции симметрическая разность множеств set_a и set_b.

set_a = {31, 37, 39, 41, 47, 58, 60, 62, 70, 75,
         76, 77, 78, 79, 80, 81, 85, 86, 88, 90, 93, 96, 98, 99}
set_b = {0, 1, 8, 16, 17, 18, 22, 24, 29, 31,
         33, 34, 36, 42, 46, 47, 51, 53, 62, 64, 65, 66, 67}
print(len(set_a ^ set_b))

# 339. Перед вами располагается список words, состоящий из 55 слов, которые могут повторяться. Ваша задача вывести на экран количество уникальных слов, длина которых больше 6.
#      Под уникальностью здесь подразумевается то, что в случае возникновения дублирующих слов, в подсчете вы не должны учитывать дубли.

words = ['mention', 'soup', 'pneumonia', 'tradition', 'concert', 'tease', 'generation',
         'winter', 'national', 'jacket', 'winter', 'wrestle', 'proposal', 'error', 
         'pneumonia', 'concert', 'value', 'value', 'disclose', 'glasses', 'tank',
         'national', 'soup', 'feel', 'few', 'concert', 'wrestle', 'proposal', 'soup',
         'sail', 'brown', 'service', 'proposal', 'winter', 'jacket', 'mention', 'tradition',
         'value', 'feel', 'bear', 'few', 'value', 'winter', 'proposal', 'government', 
         'control', 'value', 'few', 'generation', 'service', 'national',
         'tradition', 'government', 'mention', 'proposal']
print(sum([1 for word in set(words) if len(word) > 6]))

# 340. Вашей программе будут поступать на вход N списков, содержащих целые числа. Для каждого введенного списка определите, сколько в нем встречается различных чисел.
#      Входные данные: Сперва поступает натуральное число N - количество списков. В следующих N строк вводятся значения каждого списка, разделенные через пробел.
#      Выходные данные: Вывести на отдельной строке количество различных чисел каждого введенного списка в том же порядке, в котором вводились списки.

[print(len(set(input().split()))) for _ in range(int(input()))]

# 341. Перед вами располагается множество  my_set. Ваша задача добавить в него 4 строковых элемента: 
#      - concert
#      - brown
#      - jacket
#      - value
#      Выводить ничего не нужно, только добавьте элементы выше.

my_set = {'government', 'control', 'winter', 'few', 'generation',
          'service', 'national', 'tradition', 'government'}
my_set.update(('concert', 'brown', 'jacket', 'value'))

# 342. Перед вами располагается множество  my_set. Ваша задача удалить из него 3 строковых элемента: 
#      - government
#      - national
#      - tease
#      Выводить ничего не нужно, только удалить элементы выше.

my_set = {
    'mention', 'soup', 'pneumonia', 'tradition', 'concert', 'tease', 'generation',
    'winter', 'national', 'jacket', 'winter', 'wrestle', 'proposal', 'error',
    'pneumonia', 'concert', 'value', 'value', 'disclose', 'glasses', 'tank',
    'national', 'soup', 'feel', 'few', 'concert', 'wrestle', 'proposal', 'soup',
    'sail', 'brown', 'service', 'proposal', 'winter', 'jacket', 'mention',
    'tradition', 'value', 'feel', 'bear', 'few', 'value', 'winter', 'proposal',
    'government', 'control', 'value', 'few', 'generation', 'service', 'national',
    'tradition', 'government', 'mention', 'proposal'
}
[my_set.remove(i) for i in ('government', 'national', 'tease')]

# 343. Перед вами вновь представлено множество  my_set. Ваша задача вновь провести удаление элементов, указанных ниже: 
#      - noble
#      - offend
#      - error
#      - eagle
#      - sail
#      Отличие этой задачи от предыдущей в том, что некоторых элементов в множестве нет. Не упадите с ошибкой при удалении. Выводить ничего не нужно, только удалить элементы выше.

my_set = {
    'mention', 'soup', 'pneumonia', 'tradition', 'concert', 'tease', 'generation',
    'winter', 'national', 'jacket', 'winter', 'wrestle', 'proposal', 'preference',
    'fascinate', 'earthflax', 'meadow', 'bitter', 'march', 'feel', 'wind', 'location',
    'need', 'adviser', 'error', 'pneumonia', 'concert', 'value', 'value', 'disclose',
    'glasses', 'tank', 'national', 'soup', 'feel', 'few', 'concert', 'wrestle',
    'proposal', 'soup', 'sail', 'brown', 'service', 'proposal', 'winter', 'jacket',
    'mention', 'tradition', 'value', 'feel', 'bear', 'few', 'value', 'winter', 'proposal',
    'government', 'control', 'value', 'few', 'generation', 'service', 'national', 'tradition',
    'government', 'mention', 'proposal', 'sunrise', 'refund', 'formulate', 'despise', 'hobby',
    'noble', 'parameter', 'update', 'serious', 'potential', 'entry', 'week',
    'tenant', 'debut', 'dentist', 'explode', 'default', 'slam'
}
[my_set.discard(i) for i in ('noble', 'offend', 'error', 'eagle', 'sail')]

# 344. Вашей программе будут поступать на вход N списков, содержащих целые числа. Ваша задача определить сколько всего встречалось различных чисел во всех этих списках.
#      Входные данные: Сперва поступает натуральное число N - количество списков. В следующих N строк вводятся значения каждого списка, разделенные через пробел.
#      Выходные данные: Вывести одно число - количество различных чисел во всех этих списках.

st = set()
[st.update(input().split()) for _ in range(int(input()))]
print(len(st))

# 345. Ваша программа получает на вход последовательность фраз, указанных через запятую.
#      Для каждой фразы выведите слово ДА (в отдельной строке), если эта фраза ранее встречалось в последовательности или НЕТ, если не встречалось.
#      Символы во фразах нужно рассматривать без учета регистра, это значит что фраза Hasta la vista BAby эквивалента фразе hasta La Vista baby.

st = set()
for i in input().lower().split(','):
    if i not in st: st.add(i); print('НЕТ')
    else: print('ДА')

# 346. Даны два списка чисел. Выведите все числа, которые входят как в первый, так и во второй список в порядке возрастания.

print(*sorted(set(map(int, input().split())).intersection(set(map(int, input().split())))))

# 347. Даны два списка чисел. Выведите все числа в порядке возрастания, которые входят в первый список, но при этом отсутствуют во втором.

print(*sorted(set(input().split()).difference(set(input().split())), key=int))

# 348. Напишите программу, которая выводит все цифры, встречающиеся в символьной строке больше одного раза.
#      Входные данные: Входная строка может содержать цифры, пробелы и латинские буквы.
#      Выходные данные: Программа должна вывести в одну строчку в порядке возрастания все цифры, встречающиеся во входной строке больше одного раза. Если таких цифр нет, нужно вывести слово 'NO'.

l = [i for i in input() if i.isdigit()]
st = set(l)
[l.remove(i) for i in st]
print(*sorted(set(l)) if l else ['NO'])

# 349. Напишите программу, которая удаляет из строки все повторяющиеся символы, при этом регистр букв необходимо учитывать.
#      Входные данные: Программа получает на вход строку, состоящую из заглавных и строчных символов, цифр и знаков препинания.
#      Выходные данные: Программа должна вывести исходную строку, из которой удалены все повторяющиеся символы.

s = input()
st = set(s)
for i in s:
    if i in st:
        st.remove(i)
        print(i, end='')

# 350. Создайте пустой объект frozenset и сохраните его в переменную my_frozen, затем выведите на экран эту переменную.

print(my_frozen := frozenset())

# 351. В переменную my_frozen, сохраните объект frozenset , содержащий 77 элементов. Сами элементы это последовательность из 77-ми следующих чисел: 7, 77, 777, 7777, 77777, 777777, ..... 
#      В конце этой последовательности стоит число из 77-ми цифр 7, на предпоследнем месте - число из 76-ти цифр 7.
#      Выводить ничего не нужно, только создать переменную my_frozen и правильно ее заполнить.

my_frozen = frozenset([int(i * '7') for i in range(1, 78)])