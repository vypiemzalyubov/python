# 285. Создайте две переменные empty и empty_too, сохраните в них значение None.
#      При помощи оператора is выведите на первой строке результат их сравнения на равенство и затем на второй строке результат их сравнения на неравенсто.

print((empty := None) is (empty_too := None), empty is not empty_too, sep='\n')

# 286. Создайте список i_love_none из 50 элементов None и распечатайте его.

print(i_love_none := [None for _ in range(50)])

# 287. Сохраните в переменной my_tuple кортеж состоящий из 4 любых элементов. Распечатывать ничего не нужно, просто создайте кортеж.

my_tuple = (1,) * 4

# 288. Сохраните в переменной lonely кортеж из одного элемента: 777. Распечатайте на экран lonely.

print((lonely := (777,)))

# 289. Допишите программу ниже, чтобы она вывела через пробел в одной строке значения самого маленького и самого большого элементов кортежа my_tuple.

my_tuple = (-214, 181, -139, 448, -664, -66, 213, 832, 717, -462, -924, -706, -85, -244, -222, -340, -482, -518, -781, 759, -593, 905, -354, -377, 
            -141, -742, 383, -381, 109, -639, -480, -810, -686, 892, -612, 696, 993, 791, 631, -493, -218, -829, -275, 619, -628, -241, -565, -835, 
            -69, 747, 711, -252, -811, -407, -153, 904, 933, -254, 307, -493, -419, -109, -543, 155, -127, 613, -452, -459, 856, 562, 333, -66, -77, 
            -598, -779, -278, 867, 321, -20, -415, -357, 735, -906, -14, -370, 453, -630, -736, -830, -917, 32, 422, -895, 198, 284, 472, -986, -964, -73, 29)
print(min(my_tuple), max(my_tuple))

# 290. Допишите программу ниже, чтобы она вывела среднее арифметическое всех элементов кортежа my_tuple.

my_tuple = (-214, 181, -139, 448, -664, -66, 213, 832, 717, -462, -924, -706, -85, -244, -222, -340, -482, -518, -781, 759, -593, 905, -354, -377, 
            -141, -742, 383, -381, 109, -639, -480, -810, -686, 892, -612, 696, 993, 791, 631, -493, -218, -829, -275, 619, -628, -241, -565, -835, 
            -69, 747, 711, -252, -811, -407, -153, 904, 933, -254, 307, -493, -419, -109, -543, 155, -127, 613, -452, -459, 856, 562, 333, -66, -77, 
            -598, -779, -278, 867, 321, -20, -415, -357, 735, -906, -14, -370, 453, -630, -736, -830, -917, 32, 422, -895, 198, 284, 472, -986, -964, -73, 29)
print(sum(my_tuple) / len(my_tuple))

# 291. При помощи операций сцепления и дублирования сохраните в переменной result следующий кортеж: 
#      (1, 1, 1, 'R', 'R', 'R', 'R', 'R', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 2, 2, 2, 2, 2)
#      Он состоит из:
#      - трех единиц
#      - пяти букв R
#      - восьми букв A
#      - пяти цифр 2
#      Для удобства можете пользоваться переменными a b c d. В качестве ответа выведите содержимое переменной result.

a = (1,) * 3
b = ('R',) * 5
c = ('A',) * 8
d = (2,) * 5
print(a + b + c + d)

# 292. Сформировать кортеж, содержащий натуральные числа в интервале [a; b] и вывести его на экран.
#      Формат ввода: Вводится два натуральных числа a и b в отдельных строках. Гарантируется, что a<b.
#      Формат вывода: Вывести кортеж, содержащий натуральные числа в интервале [a; b].

print(tuple([*range(int(input()), int(input()) + 1)]))

# 293. Сформировать кортеж, содержащий нечетные натуральные числа в интервале [n;n**2] и вывести его на экран.
#      Формат ввода: Вводится натуральное число n.
#      Формат вывода: Вывести кортеж, содержащий нечетные натуральные числа в интервале [n;n**2].

print((lambda n: tuple(i for i in range(n, n ** 2 + 1) if i % 2))(int(input())))

# 294. Перед вами кортеж my_tuple. Выведите сперва на отдельной строке элемент, хранящийся под индексом 44, а затем на следующей строке - девятое с конца значение.

my_tuple = (32, 45, 32, 60, 43, 19, 39, 75, 50, 12, 53, 13, 28, 70, 68, 5, 64, 55, 30, 47, 23, 20, 17, 36, 45, 
            31, 46, 50, 33, 45, 9, 41, 12, 57, 40, 43, 47, 51, 56, 54, 40, 30, 37, 23, 43, 66, 64, 27, 44, 75, 
            51, 2, 19, 72, 30, 8, 29, 43, 7, 73, 34, 65, 54, 50, 43, 6, 50, 45, 49, 30, 39, 50, 41, 70, 38, 16, 
            31, 51, 72, 45, 58, 39, 50, 56, 24, 30, 9, 53, 27, 31, 68, 56, 26, 39, 34, 50, 10, 12, 3, 27)
print(my_tuple[44], my_tuple[-9], sep='\n')

# 295. Перед вами кортеж my_tuple. При помощи среза сохраните:
#      - в переменную slice_5_10 значения с 5-го индекса по 10-й включительно
#      - в переменную slice_from_20 значения с 20-го индекса и по конец кортежа
#      - в переменную slice_to_35 значения с начала кортежа по 35-й индекс не включительно
#      Распечатайте данные переменные на отдельных строках в порядке их перечисления.

my_tuple = (32, 45, 32, 60, 43, 19, 39, 75, 50, 12, 53, 13, 28, 70, 68, 5, 64, 55, 30, 47, 23, 20, 17, 36, 45, 
            31, 46, 50, 33, 45, 9, 41, 12, 57, 40, 43, 47, 51, 56, 54, 40, 30, 37, 23, 43, 66, 64, 27, 44, 75, 
            51, 2, 19, 72, 30, 8, 29, 43, 7, 73, 34, 65, 54, 50, 43, 6, 50, 45, 49, 30, 39, 50, 41, 70, 38, 16, 
            31, 51, 72, 45, 58, 39, 50, 56, 24, 30, 9, 53, 27, 31, 68, 56, 26, 39, 34, 50, 10, 12, 3, 27)
slice_5_10 = my_tuple[5:11]
slice_from_20 = my_tuple[20:]
slice_to_35 = my_tuple[:35]
print(slice_5_10)
print(slice_from_20)
print(slice_to_35)

# 296. При помощи среза разверните/переверните кортеж my_tuple и распечатайте на экран полученное значение.
#      Развернуть(reverse) кортеж или любую другую упорядоченную коллекцию это значит расположить элементы в обратном порядке от последнего до первого.

my_tuple = (32, 45, 32, 60, 43, 19, 39, 75, 50, 12, 53, 13, 28, 70, 68, 5, 64, 55, 30, 47, 23, 20, 17, 36, 45, 
            31, 46, 50, 33, 45, 9, 41, 12, 57, 40, 43, 47, 51, 56, 54, 40, 30, 37, 23, 43, 66, 64, 27, 44, 75, 
            51, 2, 19, 72, 30, 8, 29, 43, 7, 73, 34, 65, 54, 50, 43, 6, 50, 45, 49, 30, 39, 50, 41, 70, 38, 16, 
            31, 51, 72, 45, 58, 39, 50, 56, 24, 30, 9, 53, 27, 31, 68, 56, 26, 39, 34, 50, 10, 12, 3, 27)
print(my_tuple[::-1])

# 297. Нужно посчитать и вывести на экран сколько раз встречается значение 50 в кортеже my_tuple.

my_tuple = (32, 45, 32, 60, 43, 19, 39, 75, 50, 12, 53, 13, 28, 70, 68, 5, 64, 55, 30, 47, 23, 20, 17, 36, 45, 
            31, 46, 50, 33, 45, 9, 41, 12, 57, 40, 43, 47, 51, 56, 54, 40, 30, 37, 23, 43, 66, 64, 27, 44, 75, 
            51, 2, 19, 72, 30, 8, 29, 43, 7, 73, 34, 65, 54, 50, 43, 6, 50, 45, 49, 30, 39, 50, 41, 70, 38, 16, 
            31, 51, 72, 45, 58, 39, 50, 56, 24, 30, 9, 53, 27, 31, 68, 56, 26, 39, 34, 50, 10, 12, 3, 27)
print(my_tuple.count(50))

# 298. Перед вами кортеж words_tuple. При помощи цикла for обойдите слова, хранящиеся в кортеже words_tuple, и для каждого элемента выведите строку вида:
#      Длина слова {word} = {len_word}
#      Например, для кортежа words_tuple=('hi', 'world') ответ был бы таким:
#      Длина слова hi = 2
#      Длина слова world = 5

words_tuple = ('quaint', 'leftovers', 'thesis', 'density', 'retired', 'weak', 'tolerate',
               'sensitivity', 'primary', 'definition', 'determine', 'bring', 'monstrous',
               'hurl', 'timetable', 'month', 'advocate', 'provoke', 'stress', 'omission')
[print(f'Длина слова {word} = {len(word)}') for word in words_tuple]

# 299. Допишите программу ниже, чтобы она вывела среднее арифметическое всех нечетных значений, хранящихся в кортеже my_tuple.

my_tuple = (-214, 181, -139, 448, -664, -66, 213, 832, 717, -462, -924, -706, -85, -244, -222, -340, -482, -518, -781, 759, -593, 905, -354, -377, -141, 
            -742, 383, -381, 109, -639, -480, -810, -686, 892, -612, 696, 993, 791, 631, -493, -218, -829, -275, 619, -628, -241, -565, -835, -69, 747, 
            711, -252, -811, -407, -153, 904, 933, -254, 307, -493, -419, -109, -543, 155, -127, 613, -452, -459, 856, 562, 333, -66, -77, -598, -779, 
            -278, 867, 321, -20, -415, -357, 735, -906, -14, -370, 453, -630, -736, -830, -917, 32, 422, -895, 198, 284, 472, -986, -964, -73, 29)
print(sum([i for i in my_tuple if i % 2]) / len([i for i in my_tuple if i % 2]))

# 300. Создайте пустой словарь и сохраните его в переменную my_dict, затем выведите на экран эту переменную.

print(my_dict := {})

# 301. Создайте словарь, у которого должны быть следующие пары ключ-значения:
#      Ключ	                Значение
#      name - строка	 Vasya - строка
#      surname - строка	 Petrov - строка
#      age - строка	     25 - целое число
#      Данный словарь необходимо сохранить в переменную person и затем вывести эту переменную на экран.

print(person := dict(name='Vasya', surname='Petrov', age=25))

# 302. Перед вами имеется словарь sweet. В отдельных строках распечатайте сперва значение ключа name, потом calories и напоследок id.

sweet = {
    "id": "0001",
    "type": "donut",
    "name": "Cake",
    "ppu": 0.55,
    "calories": 125,
}
print(sweet["name"], sweet["calories"], sweet["id"], sep='\n')

# 303. В вашем распоряжении имеется словарь days, в котором в качестве ключей хранится номера месяца, 
#      а в качестве значения - количество дней в соответствующем месяце (будем исключать високосные года и полагать, что в феврале всегда 28 дней)
#      Ваша программа получает на вход номер месяца, гарантируется что это будет число в пределах от 1 до 12. Ваша задача по введеному номеру месяца вывести количество дней.

days = {
    1: 31,
    2: 28,
    3: 31,
    4: 30,
    5: 31,
    6: 30,
    7: 31,
    8: 31,
    9: 30,
    10: 31,
    11: 30,
    12: 31
}
print(days[int(input())])

# 304. Перед вами имеется словарь sweet. Ваша задача:
#      - создать строковый ключ weight с целым значением 230
#      - создать строковый ключ have_topping c булевым значением True
#      - изменить значение ключа name на строку SuperCake
#      - изменить значение ключа calories на целое число 350
#      В качестве ответа распечатайте в конце словарь sweet.

sweet = {
    "id": "0001",
    "type": "donut",
    "name": "Cake",
    "ppu": 0.55,
    "calories": 125,
}
sweet["weight"], sweet["have_topping"], sweet["name"], sweet["calories"] = 230, True, "SuperCake", 350
print(sweet)

# 305. Перед вами имеется словарь sweet. Удалите из него ключи ppu и type. Затем выведите словарь sweet в качестве ответа.

sweet = {
    "id": "0001",
    "type": "donut",
    "name": "Cake",
    "ppu": 0.55,
    "calories": 125,
}
del sweet["ppu"], sweet["type"]
print(sweet)

# 306. На вход программе поступает целое число n. Вам необходимо создать словарь, который будет включать в себя ключи от 1 до n, 
#      а значениями соответствующего ключа будет значение ключа в квадрате. В качестве ответа выведите полученный словарь.

print({i: i ** 2 for i in range(1, int(input()) + 1)})

# 307. Напишите программу, которая печатает словарь alphabet, где ключи  - строчные английские символы, а значения - порядковые номера букв в алфавите начиная с 1.
#      Начало вашего словаря должны быть таким {"a": 1, "b": 2 ... }. В качестве ответа распечатайте полученный словарь alphabet.

from string import ascii_lowercase
alphabet = {ascii_lowercase[i-1]: i for i in range(1, 27)}
print(alphabet)

# 308. Найдите «длину» словаря account.

account = {
  "id": 5681,
  "uid": "45f17b56-bcad-4933-8c73-a37aaa6863b9",
  "account_number": "6733198878",
  "iban": "GB79PNXF20678598570754",
  "bank_name": "AAC CAPITAL PARTNERS LIMITED",
  "routing_number": "007398728",
  "swift_bic": "AACCGB21"
}
print(len(account))

# 309. Перед вами располагается словарь address. Давайте проверим наличие следующих ключей:
#      - zip_code
#      - longitude
#      - post_code
#      - street_name
#      - number_house
#      Программа должна проверить наличие ключей и вывести True, если ключ имеется,  или False, если ключ отсутствует.
#      Проверки ключей должны выполняться в отдельной строчке в порядке перечисления ключей в задании.

address = {
  "id": 7973,
  "uid": "42f2ce1d-90ab-4345-9595-0d9f42e6c085",
  "city": "East Monteland",
  "street_name": "Gusikowski Land",
  "street_address": "3230 Daugherty Centers",
  "secondary_address": "Apt. 562",
  "building_number": "58671",
  "mail_box": "PO Box 5313",
  "community": "Paradise Square",
  "zip_code": "58611",
  "zip": "01667",
  "postcode": "00563",
  "time_zone": "America/New_York",
  "street_suffix": "Burg",
  "city_suffix": "mouth",
  "city_prefix": "West",
  "state": "Wisconsin",
  "state_abbr": "NY",
  "country": "Mali",
  "country_code": "MH",
  "latitude": -56.97457993706476,
  "longitude": -104.29509072140858,
  "full_address": "Apt. 982 4820 Leena Rest, Lake Giannaville, MN 09265-3715"
}
[print(key in address) for key in ('zip_code', 'longitude', 'post_code', 'street_name', 'number_house')]

# 310. У нас есть словарь currencies, в котором хранятся валюты и их курсы. В словаре представлены далеко не все валюты.
#      Ваша программа принимает на вход название валюты, проверяет присутствует ли данная валюта в словаре.
#      Если валюта присутствует необходимо вывести ее курс, если отсутствует - строку Нет данных по <валюта>.

currencies = {
    'Argentine Peso': 118362.205708,
    'Australian Dollar': 1586.232315,
    'Bahraini Dinar': 423.780164,
    'Botswana Pula': 13168.450636,
    'Brazilian Real': 5954.781483,
    'British Pound': 834.954104,
    'Bruneian Dollar': 1520.451015,
    'Bulgarian Lev': 1955.83,
    'Canadian Dollar': 1430.54405,
    'Chilean Peso': 898463.818465,
    'Chinese Yuan Renminbi': 7171.445692,
    'Colombian Peso': 4447741.922165,
    'Croatian Kuna': 7527.744707,
    'Czech Koruna': 24313.797041,
    'Danish Krone': 7440.613895,
    'Emirati Dirham': 4139.182587,
    'Hong Kong Dollar': 8786.255952,
    'Hungarian Forint': 355958.035747,
    'Icelandic Krona': 143603.932438,
    'Indian Rupee': 84241.767127,
    'Indonesian Rupiah': 16187150.010697,
    'Iranian Rial': 47534006.535121,
    'Israeli Shekel': 3569.191411,
    'Japanese Yen': 129149.364679,
    'Kazakhstani Tenge': 489292.515538,
    'Kuwaiti Dinar': 340.959682,
    'Libyan Dinar': 5196.539901,
    'Malaysian Ringgit': 4717.485104,
    'Mauritian Rupee': 49212.933037,
    'Mexican Peso': 23130.471272,
    'Nepalese Rupee': 134850.008728,
    'New Zealand Dollar': 1703.649473,
    'Norwegian Krone': 9953.078431,
    'Omani Rial': 433.360301,
    'Pakistani Rupee': 198900.635421,
    'Philippine Peso': 57574.278782,
    'Polish Zloty': 4579.273862,
    'Qatari Riyal': 4102.552652,
    'Romanian New Leu': 4946.638369,
    'Russian Ruble': 86197.012666,
    'Saudi Arabian Riyal': 4226.530892,
    'Singapore Dollar': 1520.451015,
    'South African Rand': 17159.831129,
    'South Korean Won': 1355490.097163,
    'Sri Lankan Rupee': 228245.645722,
    'Swedish Krona': 10439.125427,
    'Swiss Franc': 1037.792217,
    'Taiwan New Dollar': 31334.286611,
    'Thai Baht': 37436.518169,
    'Trinidadian Dollar': 7636.35428,
    'Turkish Lira': 15078.75981,
    'US Dollar': 1127.074905,
    'Venezuelan Bolivar': 511082584.868731
}
print(currencies[c] if (c := input()) in currencies else f'Нет данных по {c}')

# 311. Перед вами словарь account.Ваша задача сохранить в переменную keys список из всех ключей словаря account при помощи функции list.
#      В качестве ответа выведите переменную keys.

account = {
  "id": 3136,
  "uid": "1359acc6-f07a-4a2a-984e-3fb809982948",
  "account_number": "0847799459",
  "iban": "GB90XTND56373623909314",
  "bank_name": "ABN AMRO HOARE GOVETT CORPORATE FINANCE LTD.",
  "routing_number": "126602476",
  "swift_bic": "BCYPGB2LHGB"
}
print(keys := list(account))

# 312. Перед вами два словаря d1 и d2. Ваша задача выполнить слияние этих словарей в переменную capitals и затем вывести ее на экран.

d1 = {'India': 'Delhi',
      'Canada': 'Ottawa',
      'United States': 'Washington D. C.'}

d2 = {'France': 'Paris',
      'Malaysia': 'Kuala Lumpur'}
print(capitals := d1 | d2)

# 313. Есть два словаря, нужно в словарь d2 вмержить словарь d1 при помощи метода update. В качестве ответа выведите словарь d2.

d1 = {'a': 100, 'b': 200, 'c': 333}
d2 = {'x': 300, 'y': 200, 'z': 777}
d2.update(d1)
print(d2)

# 314. В скором времени в Берляндии откроется новая почтовая служба "Берляндеск". Администрация сайта хочет запустить свой проект как можно быстрее, 
#      поэтому они попросили Вас о помощи. Вам предлагается реализовать прототип системы регистрации сайта. Система должна работать по следующему принципу. 
#      Каждый раз, когда новый пользователь хочет зарегистрироваться, он посылает системе запрос name со своим именем. 
#      Если данное имя не содержится в базе данных системы, то оно заносится туда и пользователю возвращается ответ OK, подтверждающий успешную регистрацию. 
#      Если же на сайте уже присутствует пользователь с именем name, то система формирует новое имя и выдает его пользователю в качестве подсказки, 
#      при этом подсказка также добавляется в базу данных. Новое имя формируется по следующему правилу. 
#      К name последовательно приписываются числа, начиная с единицы (name1, name2, ...), и среди них находят такое наименьшее i, что namei не содержится в базе данных сайта.
#      Входные данные: В первой строке входных данных задано число n (1 ≤ n ≤ 105). Следующие n строк содержат запросы к системе. 
#      Каждый запрос представляет собой непустую строку длиной не более 32 символов, состоящую только из строчных букв латинского алфавита.
#      Выходные данные: В выходных данных должно содержаться n строк — ответы системы на запросы: OK в случае успешной регистрации, 
#      или подсказку с новым именем, если запрашиваемое уже занято.

n = int(input())
d = {}
for i in range(n):
    s = input()
    if s in d:
        d[s] += 1
        d[f"{s}{d[s]}"] = 0
        print(f"{s}{d[s]}")
    else:
        d[s] = 0
        print(f'OK')

# 315. Переменные countries соединяют ряд стран с тремя крупнейшими городами каждой страны. 
#      Программе на вход будет поступать название города в переменную city. И ваша задача найти какой стране принадлежит введенный город. 
#      Если страна успешно найдена, необходимо вывести сообщение:
#      INFO: <City> is a city in <Country>
#      в противном случае
#      ERROR: Country for {City} not found
#      Учитывайте, что регистр букв имеет значение.

countries = {
    "Sweden": ["Stockholm", "Göteborg", "Malmö"],
    "Norway": ["Oslo", "Bergen", "Trondheim"],
    "England": ["London", "Birmingham", "Manchester"],
    "Germany": ["Berlin", "Hamburg", "Munich"],
    "France": ["Paris", "Marseille", "Toulouse"]
}
city = input()
for k, v in countries.items():
    if city in v:
        print(f'INFO: {city} is a city in {k}')
        break
else:
    print(f'ERROR: Country for {city} not found')
    
# 316. Перед вами словарь user. При помощи метода pop переименуйте в нем следующие ключи:
#      - ключ password в ключ secret
#      - ключ last_name в ключ surname
#      Выводить ничего не нужно, только изменить ключи словаря.

user = {
    "id": 4170,
    "uid": "5e941db5-9e0f-4f94-9fc5-734110c6be14",
    "password": "SyUpfo1ljm",
    "first_name": "Teresa",
    "last_name": "Wehner",
    "username": "teresa.wehner",
    "email": "teresa.wehner@email.com",
    "gender": "Non-binary",
    "phone_number": "+674 424.561.2776",
    "social_insurance_number": "637316241",
    "date_of_birth": "1993-08-17"
}
user['secret'] = user.pop('password')
user['surname'] = user.pop('last_name')

# 317. Напишите код для преобразования списка из целых чисел произвольной длины в словарь, вложенность которого зависит от длины списка.
#      Например, если перед вами был бы такой список [100, 55, 77, 55, 89], то он должен превратиться в такой словарь {100: {55: {77: {55: 89}}}}.
#      На вход программе поступают числа для списка в одну строку, гарантируется, что в списке будет как минимум два элемента. Ваша задача вывести полученный словарь.

l = [int(i) for i in input().split()]
d = l.pop()
while l:
    d = {l.pop(): d}
print(d)