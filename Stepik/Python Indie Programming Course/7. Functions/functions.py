# 355. Давайте начнем с легкого примера. Создадим функцию с именем keanu_reeves, которая выводит сообщение "YOU'RE BREATHTAKING".and
#      Ваша задача написать только определение функции keanu_reeves.

def keanu_reeves():
    print("YOU'RE BREATHTAKING")

# 356. Всеми любимая программа «hello world». Создайте функцию с именем say_hello_world , которая принимает на вход имя человека в виде строки и печатает фразу «{name} говорит hello world!»
#      Ваша задача написать только определение функции say_hello_world.

def say_hello_world(name):
    print(f'{name} говорит hello world!')

# 357. Напишите функцию summa_n, которая принимает одно целое положительное t число и находит сумму всех чисел от 1 до t включительно. Программа должна распечатать сообщение:
#      "Я знаю, что сумма чисел от 1 до {t} равна {S}", где в качестве t и S вам необходимо подставить значения (см. тестовые данные).
#      Ваша задача написать только определение функции summa_n, вызывать ее не нужно.

def summa_n(t):
    s = sum(range(1, t + 1))
    print(f'Я знаю, что сумма чисел от 1 до {t} равна {s}')

# 358. Напишите функцию exponentiation, которая принимает на вход целое число и выводит на экран через пробел квадрат и куб этого числа. 
#      Вам необходимо написать только определение функции exponentiation.

def exponentiation(x):
    print(f'{x ** 2} {x ** 3}')

# 359. Напишите функцию sum_num для суммирования всех цифр строки. 
#      Функция должна принимать строку, суммировать все ее символы, которые являются цифрами, и в качестве ответа выводить найденную сумму.
#      Вам необходимо написать только определение функции sum_num.

def sum_num(s):
    print(sum(int(i) for i in s if i.isdigit()))

# 360. Напишите функцию get_body_mass_index, которая принимает массу тела человека в кг и рост в см и рассчитывает индекс массы тела человека по формуле:
#      index = масса / рост ** 2
#      Рост указывается в формуле в метрах, а не в сантиметрах.
#      Функция и должна вывести на экран информацию о массе человека, отталкиваясь от найденного индекса:
#      - если индекс < 18.5 программа должна вывести Недостаточная масса тела
#      - если 18.5 <= индекс <= 25 программа должна вывести Норма
#      - если индекс > 25 программа должна вывести Избыточная масса тела
#      Вам необходимо написать только определение функции get_body_mass_index.

def get_body_mass_index(weight, height):
    index = weight / ((height / 100)) ** 2
    print('Недостаточная масса тела' if index < 18.5 else 'Избыточная масса тела' if index > 25 else 'Норма')

# 361. Напишите функцию check_password, которая проверяет переданный ей пароль на сложность и печатает на экран результат проверки.
#      Сложным паролем будет считаться комбинация символов, в которой:
#      - Есть хотя бы 3 цифры
#      - Есть хотя бы одна заглавная буква 
#      - Есть хотя бы один символ из следующего набора "!@#$%*"
#      - Общая длина не менее 10 символов
#      Если пароль прошел все проверки, функция должна вывести на экран фразу "Perfect password", в противном случае - "Easy peasy".
#      Вам необходимо написать только определение функции check_password.

def check_password(password):
    len_digit = title_char = spec_char = 0
    for i in password:
        if i.isdigit():
            len_digit +=1
        if i.isupper():
            title_char += 1
        if i in '!@#$%*':
            spec_char += 1
    print('Perfect password' if len_digit >= 3 and title_char and spec_char and len(password) >= 10 else 'Easy peasy')
    
# 362. Создайте функцию count_letters, которая принимает на вход фразу и подсчитывает, какое количество в ней строчных(K) и заглавных (N) букв, 
#      все остальные символы игнорируются. Функция должна вывести на экран информацию о найденных буквах в определенном формате:
#      Количество заглавных символов: N
#      Количество строчных символов: K
#      Вам необходимо написать только определение функции count_letters.

def count_letters(s):
    n = k = 0
    for char in s:
        n += char.isupper()
        k += char.islower() 
    print(f'Количество заглавных символов: {n}\nКоличество строчных символов: {k}')

# 363. Напишите функцию repeat_please_n_times, которая принимает один аргумент n - натуральное число. 
#      Функция repeat_please_n_times должна n раз распечатать фразу "Just do it" в отдельной строчке.
#      Ваша задача написать только определение функции repeat_please_n_times, вызывать ее не нужно.

def repeat_please_n_times(n):
    for i in range(n):
        print('Just do it')

# 364. Напишите функцию is_between, которая принимает три аргумента и печатает True, если первое число находится между двумя вторыми включительно, и False в противном случае.
#      Ваша задача дописать только тело функции is_between.

def is_between(name, surname, middlename):
    print(b <= a <= c or c <= a <= b)

a, b, c = map(int, input().split())

is_between(a, b, c)

# 365. Напишите функцию count_letter(text, letter), которая принимает два параметра:
#      - text – текст, в котором нужно посчитать сколько раз появилась буква letter, учитывая регистр буквы;
#      - letter – буква, количество которой мы должны посчитать в text.
#      Функция count_letter должна выводить на экран найденное количество букв  letter в тексте text.
#      Ваша задача дописать только тело функции count_letter.

def count_letter(text, letter):
    print(sum([i.count(symbol) for i in text]))
    
text = input()
symbol = input()

count_letter(text, symbol)

# 366. Напишите функцию print_initials(name, surname, middlename), которая принимает три параметра:
#      - name – имя человека;
#      - surname – фамилия человека;
#      - middlename– отчество человека;
#      а затем выводит на печать фамилию и инициалы в определенном формате (первая буква фамилии должна стать заглавной, все остальные строчные; 
#      в имени и отчестве остаются только по одной букве в верхнем регистре).
#      Ваша задача дописать только тело функции print_initials.

def print_initials(name, surname, middlename):
    print(f'{surname.title()} {name.upper()[0]}.{middlename.upper()[0]}.')

name = input()
surname = input()
middlename = input()

print_initials(name, surname, middlename)

# 367. Ниже в коде представлено несколько проверок. Ваша задача исправить код так, чтобы все проверки прошли.

assert 200 > 100                             
assert [100] * 4 < [100, 100, 100, 10000]    
assert sum([1, 3, 5]) == sum([6, 3])             
assert max(3, -1, 9) != -1                   
print('Проверки пройдены')

# 368. Давайте считать человека подростком, если его возраст находится в пределах от 12 до 17 лет включительно. Напишите функцию is_person_teenager, 
#      которая помогает по возрасту определить является ли человек подростком или нет. Функция is_person_teenager принимает на вход возраст человека и возвращает True или False.
#      Нужно написать только определение функций is_person_teenager.

def is_person_teenager(age):
    return 12 <= age <= 17

# 369. Напишите функцию factorial, которая принимает на вход одно неотрицательное число, и возвращает значение факториала данного числа.
#      Нужно написать только определение функции factorial.

def factorial(n):
    fact = 1
    for i in range(1, n + 1):
        fact *= i
    return fact

n = int(input())
print(factorial(n))

# 370. Напишите функцию generate_fizz_buzz_list, которая принимает одно целое число n - размер списка. Функция generate_fizz_buzz_list должна:
#      - обойти числа от 1 до n включительно и для каждого такого числа выполнить последовательно проверки с пункта 2 по пункт 5
#      - Если число кратно и трем, и пяти, то в список заносим строку FizzBuzz 
#      - Если число кратно трем, то в список заносим строку Fizz
#      - Если число кратно пяти, то в список заносим строку Buzz
#      - Если число не кратно ни трем ни пяти, то в список заносим само это число
#      В итоге функция generate_fizz_buzz_list должна вернуть сформированный список из n элементов. Ваша задача написать только определение функции generate_fizz_buzz_list.

def generate_fizz_buzz_list(n):
    return ["FizzBuzz" if not i % 3 and not i % 5 else "Fizz" if not i % 3 else "Buzz" if not i % 5 else i for i in range(1, n + 1)]

# 371. В этой задаче вам необходимо воспользоваться уже готовой функцией gcd(a, b), которая принимает два числа и находит наибольших общий делитель для них.
#      Ваша задача при помощи функции gcd определить НОД произвольного количества чисел.
#      Входные данные: На первой строке вводится натуральное число n – количество чисел. Далее идут n строк, в каждой из которых натуральное число.
#      Выходные данные: НОД введенных чисел.

from functools import reduce

def gcd(a, b):
    while b > 0:
        a, b = b, a%b
    return a

l = [int(input()) for _  in range(int(input()))]
print(reduce(gcd, l))

# 372. Ваша задача написать функцию find_duplicate, которая принимает один аргумент - список чисел. Функция должна возвращать список из дублей, 
#      каждый дубль нужно брать только один раз в том порядке, в котором они встречаются в исходном списке. Под дублем будем подразумевать число, которое присутствовало в списке несколько раз. 
#      find_duplicate([1, 1, 1, 1, 1, 2, 2, 2, 2]) => [1, 2]
#      find_duplicate([2, 1, 1, 1, 1, 1, 2, 2, 2, 2]) => [2, 1]
#      find_duplicate([1, 2, 3, 4]) => []
#      find_duplicate([1, 2, 3, 4, 3]) => [3]
#      Ваша задача написать только определение функции find_duplicate.

def find_duplicate(lst):
    l = []
    for i in lst:
        if lst.count(i) > 1 and i not in l:
            l.append(i)
    return l

assert find_duplicate([1, 1, 1, 1, 1, 2, 2, 2, 2]) == [1, 2]
assert find_duplicate([2, 1, 1, 1, 1, 1, 2, 2, 2, 2]) == [2, 1]
assert find_duplicate([1, 2, 3, 4]) == []
assert find_duplicate([8, 7, 6, 5, 4, 3, 4, 5, 6, 7, 8]) == [8, 7, 6, 5, 4]
print('Все успешно')

# 373. Напишите функцию first_unique_char, которая принимает строку символов и возвращает целое число: позицию первого уникального символа в строке. 
#      В случае, если уникальных символов в переданной строке нет, верните -1. Регистр символов не учитывайте.
#      Ваша задача написать только определение функции first_unique_char.

def first_unique_char(s):
    for i, n in enumerate(s):
        if s.count(n) == 1:
            return i
    return -1

s = input()
print(first_unique_char(s))

# 374. Ваша задача написать функцию format_name_list, которая принимает список словарей, у каждого словаря в этом списке есть только ключ name.
#      Функция format_name_list должна вернуть строку, в которой все имена из списка разделяются запятой кроме последних двух имен, они должны быть разделены союзом "и". 
#      Если в списке нет ни одного имени, функция должна вернуть пустую строку. Ниже представлены примеры:
#      format_name_list([{'name': 'Bart'}, {'name': 'Lisa'}, {'name': 'Maggie'}]) => 'Bart, Lisa и Maggie'
#      format_name_list([{'name': 'Bart'}, {'name': 'Lisa'}]) => 'Bart и Lisa'
#      format_name_list([{'name': 'Bart'}]) => 'Bart'
#      format_name_list([]) => ''
#      Ваша задача написать только определение функции format_name_list.

def format_name_list(names: list):
    tmp = [i['name'] for i in names]
    if len(tmp) == 0:
        return ''
    elif len(tmp) == 1:
        return tmp[0]
    s = ', '.join(tmp[0:-1])
    return f'{s} и {tmp[-1]}'

assert format_name_list([{'name': 'Bart'}, {'name': 'Lisa'}, {'name': 'Maggie'}, {'name': 'Homer'}, {'name': 'Marge'}]) == 'Bart, Lisa, Maggie, Homer и Marge'
assert format_name_list([{'name': 'Bart'}, {'name': 'Lisa'}, {'name': 'Maggie'}]) == 'Bart, Lisa и Maggie'
assert format_name_list([{'name': 'Bart'}, {'name': 'Lisa'}]) == 'Bart и Lisa'
assert format_name_list([{'name': 'Bart'}]) == 'Bart'
assert format_name_list([]) == ''
assert format_name_list([{'name': 'Maggie'}, {'name': 'Lisa'}, {'name': 'Barney'}, {'name': 'Homer'}, {'name': 'Bart'}, {'name': 'Moe'}]) == 'Maggie, Lisa, Barney, Homer, Bart и Moe'
assert format_name_list([{'name': 'Marge'}, {'name': 'Maggie'}, {'name': 'Seymour'}]) == 'Marge, Maggie и Seymour'
assert format_name_list([{'name': 'Maude'}, {'name': 'Bart'}]) == 'Maude и Bart'
print('Проверки пройдены')

# 375. Ваша задача написать функцию get_domain_name, которая принимает строку url, извлекает из нее доменное имя и возвращает его в качестве строки.
#      get_domain_name("http://google.com") => "google"
#      get_domain_name("http://google.co.jp") => "google"
#      get_domain_name("www.xakep.ru") => "xakep"
#      get_domain_name("https://youtube.com") => "youtube"
#      get_domain_name("https://www.asos.com") => "asos"
#      get_domain_name("http://www.lenovo.com") => "lenovo"
#      Строка url может начинаться с протоколов http://  https:// или с www. URL, начинающиеся с протоколов http://  https://, могут также содержать www.
#      Ваша задача написать только определение функции get_domain_name.

def get_domain_name(url):
    s = url.replace('http://', '').replace('https://', '').replace('www.', '', 1)
    return s.split('.')[0]

assert get_domain_name("http://google.com") == "google"
assert get_domain_name("http://google.co.jp") == "google"
assert get_domain_name("www.xakep.ru") == "xakep"
assert get_domain_name("https://youtube.com") == "youtube"
assert get_domain_name("http://github.com/carbonfive/raygun") =='github'
assert get_domain_name("http://www.zombie-bites.com") == 'zombie-bites'
assert get_domain_name("https://www.siemens.com") == 'siemens'
assert get_domain_name("https://www.whatsapp.com") == 'whatsapp'
assert get_domain_name("https://www.mywww.com") == 'mywww'
print('Проверки пройдены')

# 376. В этой задаче вам необходимо воспользоваться уже готовой функцией factorial, которая принимает неотрицательное число, и возвращает значение факториала данного числа.
#      Ваша задача создать функцию trailing_zeros, которая принимает неотрицательное число, находит его факториал и возвращает сколько нулей на конце этого факториала.
#      trailing_zeros(6) =>  1, потому что 6! = 1 * 2 * 3 * 4 * 5 * 6 = 720
#      trailing_zeros(10) => 2, потому что 10! = 3 628 800
#      trailing_zeros(20) => 4, потому что 20! = 2 432 902 008 176 640 000
#      Нужно написать только определение функций trailing_zeros и factorial.

def factorial(n):
    fact = 1
    for num in range(2, n + 1):
        fact *= num
    return fact

def trailing_zeros(n):
    x = factorial(n)
    count = 0
    while x % 10 == 0:
        count += 1
        x //= 10
    return count 

assert trailing_zeros(0) == 0
assert trailing_zeros(6) == 1
assert trailing_zeros(30) == 7
assert trailing_zeros(12) == 2      
print('Проверки пройдены')

# 377. К азотистым основаниям относят аденин (A), гуанин (G), цитозин (C) и тимин (T), который входит в состав только ДНК. Они обладают схожими структурами и химическими свойствами. 
#      Это гетероциклические органические соединения, производные пиримидина и пурина, входящие в состав нуклеотидов. 
#      Аденин и гуанин — производные пурина, а цитозин и тимин — производные пиримидина.
#      В этой задаче вам необходимо создать функцию count_AGTC, которая принимает на вход строку - последовательность ДНК, состоящая только из символов A, G, T, C. 
#      Функция count_AGTC должна подсчитать количество каждого элемента в переданной последовательности и вернуть кортеж из найденных четырех количеств. 
#      Порядок элементов в кортеже должен быть именно таким A, G, T, C
#      count_AGTC('AGGTC') => (1, 2, 1, 1)
#      count_AGTC('AAAATTT') => (4, 0, 3, 0)
#      count_AGTC('AGTTTTT') => (1, 1, 5, 0)
#      count_AGTC('CCT') => (0, 0, 1, 2)
#      Нужно написать только определение функции count_AGTC.

def count_AGTC(dna):
    return dna.count('A'), dna.count('G'), dna.count('T'), dna.count('C')

assert count_AGTC('AGGTC') == (1, 2, 1, 1)
assert count_AGTC('AAAATTT') == (4, 0, 3, 0)
assert count_AGTC('AGTTTTT') == (1, 1, 5, 0)
assert count_AGTC('CCT') == (0, 0, 1, 2)     
print('Проверки пройдены')

# 378. Ниже имеется готовая функция add_binary, которая принимает два числа и возвращает их сумму в двоичной системе счисления.
#      Ваша задача только добавить докстроку «Возвращает сумму чисел a и b в двоичном виде».

def add_binary(a, b):
    """Возвращает сумму чисел a и b в двоичном виде"""
    binary_sum = bin(a+b)[2:]
    return binary_sum

# 379. Напишите функцию first_repeated_word , которая принимает строку, состоящую из нескольких слов, слова разделяются между собой пробелом. 
#      Функция должна найти первое повторяющееся слово и вернуть его в качестве результата. Если передана строка, в которой все слова различны, функция first_repeated_word должна вернуть None.
#      Регистр букв при сравнении нужно учитывать
#      first_repeated_word("ab ca bc ab") => "ab"
#      first_repeated_word("ab ca bc Ab cA aB bc") => "bc"
#      first_repeated_word("ab ca bc ca ab bc") => "ca"
#      first_repeated_word("ab ca bc") => None
#      Для функции first_repeated_word нужно добавить док-строку "Находит первый дубль в строке" и не забудьте проаннотировать аргументы и возврат функции.
#      Нужно написать только определение функции first_repeated_word.

def first_repeated_word(s: str, st = set()) -> str|None:
    """Находит первый дубль в строке"""
    for i in s.split():
        if i not in st: st.add(i)
        else: return i

# 380. Напишите функцию shift_letter , которая принимает два аргумента:
#      - letter одна английская буква в нижнем регистре
#      - shift целое число - значение сдвига буквы (может быть как положительным, так и отрицательным)
#      Функция shift_letter  сдвигает символ letter вперед или назад на заданное значение shift .Сдвиг может быть цикличным в пределах от a до z. Ниже примеры:
#      shift_letter('b', 2)=> 'd'
#      shift_letter('d', 1) => 'e'
#      shift_letter('z', 1) => 'a'
#      shift_letter('d', -2) => 'b'
#      shift_letter('d', 26) => 'd'
#      shift_letter('b', -3) => 'y'
#      Не забудьте проаннотировать аргументы и также добавьте doc-строку «Функция сдвигает символ letter на shift позиций».
#      Функция shift_letter должна вернуть новый символ. Вот вам в помощь ascii коды английских буквы, вам нужны только символы в нижнем регистре.
#      Нужно написать только определение функции shift_letter.

def shift_letter(letter: str, shift: int) -> str:
    '''Функция сдвигает символ letter на shift позиций'''
    char = ord(letter) + shift
    while char not in range(97, 123):
        if char < 97: char += 26
        else: char -= 26
    return chr(char)

# 381. На основании предыдущей задачи мы с вами можем реализовать знаменитый шифр Цезаря. Этот шифр брал каждую букву исходной фразы и смещал ее на значение ключа, это так раз был на сдвиг. 
#      В пределах кодирования одной фразы значение сдвига всегда постоянно. И так, ваша задача создать функцию caesar_cipher , которая принимает на вход текст и значение сдвига.
#      Внутри функции caesar_cipher  необходимо последовательно пройтись по каждому символу и преобразовать его по следующим правилам:
#      - если символ является знаком пунктуации, оставляем его как есть
#      - если это буква, то сместить ее при помощи ранее написанной функции shift_letter 
#      Закодированный текст необходимо вернуть в качестве ответа. Вот пример работы:
#      caesar_cipher('leave out all the rest', -1) => 'kdzud nts zkk sgd qdrs'
#      caesar_cipher('one more light', 3) => 'rqh pruh oljkw'
#      Аннотации, мой друг, не забываем прописывать. И еще нужно сделать док-строку для функции caesar_cipher со значением «Шифр цезаря».
#      Нужно написать только определение функций shift_letter и caesar_cipher.

def shift_letter(letter: str, shift_1: int) -> str:
    '''Функция сдвигает символ letter на shift позиций'''
    return chr((ord(letter) - 97 + shift_1) % 26 + 97)

def caesar_cipher(text: str, shift_2: int) -> str:
    """Шифр цезаря"""
    answer = ''
    for symbol in text:
        if symbol.isalpha(): answer += shift_letter(symbol, shift_2)
        else: answer += symbol
    return answer

# 382. Напишите функцию, которая принимает имя и возраст водителя. Функция должна распечатать на экран заключение, может ли данный водитель управлять транспортом
#      и определять она должна это по возрасту водителя: он должен быть больше или равен MIN_DRIVING_AGE.
#      Если водитель может управлять, выведите фразу "<name> может водить" , в противном случае "<name> еще рано садиться за руль".
#      MIN_DRIVING_AGE = 18
#      allowed_driving('tim', 17) # выведет "tim еще рано садиться за руль"
#      allowed_driving('bob', 18) # выведет "bob может водить"

MIN_DRIVING_AGE = 18

def allowed_driving(name: str, age: int) -> None:
    print(f'{name} может водить' if age >= MIN_DRIVING_AGE else f'{name} еще рано садиться за руль')

# 383. В этой задаче вам необходимо создать функцию get_word_indices, которая принимает список строк и возвращает словарь, 
#      где ключи - это уникальные слова из списка строк в нижнем регистре, а значения - это списки индексов строк, в которых эти слова встречаются.
#      assert get_word_indices(['This is a string',
#                               'test String',
#                               'test',
#                               'string']) => {'this': [0], 'is': [0], 'a': [0],
#                                             'string': [0, 1, 3], 'test': [1, 2]}
#      get_word_indices(['Look at my horse',
#                         'my horse',
#                         'is amazing']) => {'look': [0], 'at': [0], 'my': [0, 1],
#                                            'horse': [0, 1], 'is': [2], 'amazing': [2]}
#      get_word_indices([]) => {}
#      get_word_indices(['Avada Kedavra',
#                        'avada kedavra',
#                        'AVADA KEDAVRA']) => {'avada': [0, 1, 2],
#                                              'kedavra': [0, 1, 2]}
# Регистр букв не учитывается поэтому слова «String» и «STRING» считаются одинаковыми.
# Нужно написать только определение функции get_word_indices.

def get_word_indices(strings: list[str]) -> dict:
    d = {}
    for i, v in enumerate(strings):
        for j in v.lower().split():
            d[j] = d.get(j, []) + [i]
    return d

# 384. Напишите функцию replace, которая принимает три параметра:
#      - обязательный строковый параметр text - текст, в котором необходимо выполнить замены;
#      - обязательный строковый параметр old - строка поиска для замены;
#      - необязательный строковый параметр new - значение замены для найденного значения old. По умолчанию равен пустой строке.
#      Функция replace должна возвращать новую строку, в которой все символы old были заменены на new. При замене регистр букв должен учитываться.
#      replace('Нет', 'т') => 'Не'
#      replace('Bella Ciao', 'a') => 'Bell Cio'
#      replace('nobody; i myself farewell analysis', 'l', 'z') => 'nobody; i mysezf farewezz anazysis'
#      replace('commend me to my kind lord meaning', 'M', 'w') => 'commend me to my kind lord meaning'
#      Ваша задача дописать только тело функции replace.

def replace(text: str, old: str, new: str = ''):
    return text.replace(old, new)

# 385. В HTML используются специальные теги для определения заголовков в веб-странице.
#      Всего существует шесть тегов заголовков HTML:
#      <h1> - заголовок первого уровня;
#      <h2> - заголовок второго уровня;
#      <h3> - заголовок третьего уровня;
#      <h4> - заголовок четвертого уровня;
#      <h5> - заголовок пятого уровня;
#      <h6> - заголовок шестого уровня.
#      Разница между заголовками только в размере.
#      Ваша задача создать функцию make_header, которая принимает:
#      - обязательный параметр - строку, которую нужно обернуть в тег заголовка
#      - необязательный числовой параметр - уровень заголовка, по умолчанию принимает значение 1.
#      Функция make_header должна возвращать переданную строку в обернутый тег заголовка определенного уровня.
#      make_header('Нет') => '<h1>Нет</h1>'
#      make_header('Bella Ciao', 4) => '<h4>Bella Ciao</h4>'
#      make_header('Go little rock star', 6) => '<h6>Go little rock star</h6>'
#      make_header('Девальвации не будет. Твердо и четко') => '<h1>Девальвации не будет. Твердо и четко</h1>'
#      Ваша задача дописать только тело функции make_header.

def make_header(text: str, level: int = 1) -> str:
    return f'<h{level}>{text}</h{level}>'

# 386. Ваша задача создать функцию create_matrix, которая принимает:
#      - необязательный числовой параметр size - размер квадратной матрицы, по умолчанию принимает значение 3;
#      - необязательный числовой параметр up_fill - значение заполнителя элементов, находящихся выше главной диагонали. По умолчанию равен 0;
#      - необязательный числовой параметр down_fill - значение заполнителя элементов, находящихся ниже главной диагонали. По умолчанию равен 0;
#      Функция create_matrix должна возвращать квадратную матрицу размером size х size, на диагонали которой располагаются числа от 1 до size. 
#      Все остальные элементы заполнены согласно параметрам up_fill и down_fill.
#      create_matrix() => [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
#      create_matrix(4) => [[1, 0, 0, 0], [0, 2, 0, 0], [0, 0, 3, 0], [0, 0, 0, 4]]
#      create_matrix(up_fill=7) => [[1, 7, 7],
#                                  [0, 2, 7],
#                                  [0, 0, 3]]
#      create_matrix(up_fill=7, down_fill=9) => [[1, 7, 7],
#                                               [9, 2, 7],
#                                               [9, 9, 3]]
#      create_matrix(size=4, up_fill=7, down_fill=9) => [[1, 7, 7, 7],
#                                                       [9, 2, 7, 7],
#                                                       [9, 9, 3, 7],
#                                                       [9, 9, 9, 4]]
#      Ваша задача дописать только тело функции create_matrix.

def create_matrix(size: int = 3, up_fill: int = 0, down_fill: int = 0) -> list[list[int]]:
    tmp = [[i] * size for i in range(1, size + 1)]
    for i in range(size):
        for j in range(size):
            if i < j: tmp[i][j] = up_fill
            if i > j: tmp[i][j] = down_fill
    return tmp

# 386. Напишите функцию count_args, которая принимает произвольное количество аргументов. Данная функция должна возвращать количество переданных ей на вход аргументов.
#      count_args(1, 2, 3) => 3
#      count_args(1, 3) => 2
#      count_args(2) => 1
#      count_args() => 0
#      Вам необходимо написать только определение функции count_args.

def count_args(*args):
    return(len(args))

# 387. Напишите функцию check_sum, которая принимает произвольное количество аргументов типа int.
#      Данная функция должна выводить not enough, если сумма всех элементов меньше 50, в противном случае выводить verification passed.
#      Вам необходимо написать только определение функции check_sum.

def check_sum(*args: int) -> str:
    print('not enough' if sum(args) < 50 else 'verification passed')

# 388. Напишите функцию multiply, которая принимает произвольное количество числовых аргументов. 
#      Данная функция должна находить произведение всех переданных значений и возвращать его в качестве результата.
#      multiply(1, 2, 3) => 6
#      multiply(1, 3) => 3
#      multiply(2) => 2
#      multiply() => 1
#      Вам необходимо написать только определение функции multiply.

from math import prod
def multiply(*args: int) -> int:
    return prod(args)

# 389. Напишите функцию only_one_positive, которая принимает произвольное количество числовых аргументов и возвращает True, 
#      когда из всех переданных значений только одно положительное, в противном случае верните False. Вам необходимо написать только определение функции only_one_positive.
#      Ниже примеры вызова:
#      only_one_positive(1, 2) -> False
#      only_one_positive(-1, 0, -3, 5, -3) -> True
#      only_one_positive() -> False

def only_one_positive(*args: int) -> bool:
    return sum(i > 0 for i in args) == 1

# 390. Давайте теперь создадим функцию print_goods, которая печатает список покупок. На вход она будет принимать произвольное количество значений, а товаром мы будем считать любые непустые строки. 
#      То есть числа, списки, словари и другие нестроковые объекты вам нужно будет проигнорировать. Функция print_goods должна печатать список товаров в виде: 
#      <Порядковый номер товара>. <Название товара> (см. пример ниже). В случае, если в переданных значениях не встретится ни одного товара, необходимо распечатать текст "Нет товаров".
#      print_goods('apple', 'banana', 'orange')
#      # Программа должна вывести следующее:
#      1. apple 
#      2. banana
#      3. orange
#      print_goods(1, True, 'Грушечка', '', 'Pineapple') 
#      # Программа должна вывести следующее:
#      1. Грушечка
#      2. Pineapple
#      print_goods([], {}, 1, 2) 
#      # Программа должна вывести следующее:
#      Нет товаров
#      Вам необходимо написать только определение функции print_goods.

def print_goods(*args):
    tmp = []
    for i in args:
        if isinstance(i, str) and i:
            tmp.append(i)
    if tmp:
        for index, goods in enumerate(tmp, start=1):
            print(f'{index}. {goods}')
    else:
        print('Нет товаров')

# 391. Напишите функцию info_kwargs, которая принимает произвольное количество именованных аргументов.
#      Функция info_kwargs должна распечатать именованные аргументы в каждой новой строке в виде пары <Ключ> = <Значения>, причем ключи должны следовать в алфавитном порядке. 
#      Пример работы смотрите ниже:
#      info_kwargs(first_name="John", last_name="Doe", age=33) 
#      """ данный вызов печатает следующие строки
#      age = 33
#      first_name = John
#      last_name = Doe
#      """
#      Вам необходимо написать только определение функции.

def info_kwargs(**kwargs):
    [print(f'{k} = {v}') for k, v in sorted(kwargs.items())]

# 392. Напишите функцию create_actor, которая принимает произвольное количество именованных аргументов и возвращает словарь с характеристиками актера. 
#      Если функции create_actor не передавать никаких аргументов, то она должна возвращать базовый словарь с ключами name, surname, age. Вот так он выглядит:
#      create_actor() -> {
#              'name': 'Райан',
#               'surname': 'Рейнольдс',
#               'age': 46,
#           }
#      Если передавать именованные параметры, которые отсутствуют в базовом словаре, они дополняются к этому словарю:
#      create_actor(height=190, movies=['Дедпул', 'Главный герой']) => {
#               'name': 'Райан',
#               'surname': 'Рейнольдс',
#               'age': 46,
#               'height': 190,
#               'movies': ['Дедпул', 'Главный герой']
#           }
#      Если передавать именованные параметры, которые совпадают с ключами базового словаря, то значения в словаре должны заменяться переданными значениями:
#      create_actor(name='Jack', age=20) -> {
#              'name': 'Jack',
#              'surname': 'Рейнольдс',
#              'age': 20,
#           }
#      Вам необходимо написать только определение функции create_actor.

def create_actor(**kwargs) -> dict:
    d = dict(name='Райан', surname='Рейнольдс', age=46)
    if kwargs:
        d.update(kwargs)  
    return d

# 393. Определите функцию print_from, которая принимает одно натуральное число n и распечатывает на экране убывающую последовательность целых чисел от n до 1 включительно. 
#      Каждое число необходимо выводить на отдельной строке. Ваша задача только написать определение функции print_from.

def print_from(n: int) -> None:
    if n:
        print(n)
        print_from(n - 1)

# 394. Определите функцию print_to, которая принимает одно натуральное число n и распечатывает на экране последовательность целых чисел от 1 до n включительно. 
#      Каждое число необходимо выводить на отдельной строке. Ваша задача только написать определение функции print_to.

def print_to(n: int) -> None:
    if n:
        print_to(n - 1)
        print(n)

# 395. Дано натуральное число N и последовательность из N элементов. Требуется вывести эту последовательность в обратном порядке.
#      Входные данные: Программа принимает на вход натуральное число N (N ≤ 103). Во второй строке через пробел идут N целых чисел, по модулю не превосходящих 103 - элементы последовательности.
#      Выходные данные: Ваша задача вывести заданную последовательность в обратном порядке.

def rev(n: int) -> None:
    if n:
        rev(n - 1)
        print(l[-n], end=' ')
        
n = int(input())
l = list(map(int, input().split()))
rev(n)

# 396. Описать рекурсивную функцию double_fact, которая принимает на вход целое число и вычисляет значение двойного факториала по формуле.
#      double_fact(7) => 105
#      double_fact(4) => 8
#      double_fact(1) => 1
#      double_fact(10) => 3840
#      Ваша задача только написать определение функции double_fact.

def double_fact(n):
    if n < 3:
        return n
    return double_fact(n - 2) * n

# 397. Последовательностью Фибоначчи называется последовательность чисел a0, a1, ..., an, ..., где число, стоящее на n-ой позиции можно вычислить по формуле.
#      Входные данные: Программе поступает на вход целое число N (0 ≤ N ≤ 30) - порядковый номер числа Фибоначчи.
#      Выходные данные: Вам необходимо вывести на экран N-е число Фибоначчи.

def fib(n):
    if n < 2:
        return n
    return fib(n-1) + fib(n-2)

print(fib(int(input())))

# 398. Описать рекурсивную функцию tribonacci, которая принимает на вход целое число n - порядковый номер чисел Трибоначчи. 
#      Функция по параметру n должна вычислить и вернуть значение, стоящее на n-м месте в ряде чисел Трибоначчи.
#      Вот примере вызовов:
#      tribonacci(0) => 0
#      tribonacci(2) => 1
#      tribonacci(4) => 2
#      tribonacci(6) => 7
#      tribonacci(7) => > 13
#      Ваша задача только написать определение функции tribonacci.

def tribonacci(n: int) -> int:
    if n < 1:
        return 0
    if n == 2:
        return 1
    return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3)

# 399. Описать рекурсивную функцию get_combin, которая принимает на вход два целых числа  и находит C(N,K) — число сочетаний из N элементов по K — с помощью рекуррентного соотношения.
#      При этом гарантируется, что входные значения n и k будут удовлетворять следующим условиям: n > 0, 0 ≤ k ≤ n.
#      Вот примеры вызовов:
#      get_combin(5, 5) => 1
#      get_combin(5, 2) => 10
#      get_combin(3, 1) => 3
#      get_combin(7, 0) => 1
#      Ваша задача только написать определение функции get_combin.

def get_combin(n: int, k:int) -> int:
    if k == 0 or k == n:
        return 1
    return get_combin(n - 1, k) + get_combin(n - 1, k - 1)

# 400. Описать рекурсивную функцию ackermann, которая принимает на вход два целых числа  m и n находит значение, определенное следующим образом.
#      Найденное значение функция ackermann должна вернуть в качестве результата.
#      ackermann(3, 2) => 29
#      ackermann(3, 0) => 5
#      ackermann(1, 0) => 2
#      ackermann(3, 5) => 253
#      Ваша задача только написать определение функции ackermann.
#      В тестовых примерах сперва поступает на вход значение аргумента m, затем аргумента n.

def ackermann(m, n):
    if m == 0:
        return n + 1
    if m > 0 and n == 0:
        return ackermann(m - 1, 1)
    if m > 0 and n > 0:
        return ackermann(m - 1, ackermann(m, n - 1))
    
# 401. Напишите функцию list_sum_recursive, которая принимает на вход список из целых чисел и возвращает сумму элементов переданного списка. 
#      Не забывайте, что реализовать это нужно при помощи рекурсии. Ваша задача только написать определение функции list_sum_recursive.

def list_sum_recursive(l):
    if not l:
        return 0
    if len(l) == 1:
        return l[0]
    return l[0] + list_sum_recursive(l[1:])

# 402. Представьте, что у нас есть список целых чисел неограниченной вложенности. То есть наш список может состоять из списков, внутри которых также могут быть списки. 
#      Ваша задача превратить все это в линейный список при помощи функции flatten.
#      flatten([1, [2, 3, [4]], 5]) => [1, 2, 3, 4, 5]
#      flatten([1, [2, 3], [[2], 5], 6]) => [1, 2, 3, 2, 5, 6]
#      flatten([[[[9]]], [1, 2], [[8]]]) => [9, 1, 2, 8]
#      Ваша задача только написать определение функции flatten.

def flatten(l):
    if not l:
        return []
    if isinstance(l[0], list):
        return flatten(l[0]) + flatten(l[1:])
    return l[:1] + flatten(l[1:])

# 403. Перед вами имеется вложенный словарь, уровень вложенности произвольный и заранее неизвестен. Ключами словаря на любом уровне могут быть только строки, значения - только числа. 
#      Учитывая указанные выше условия, ваша задача состоит в том, чтобы преобразовать этот вложенный словарь в плоский (состоящий только из одного уровня), 
#      где ключи формируются конкатенацией вложенных ключей, соединенных знаком _.
#      Для этого необходимо определить рекурсивную функцию flatten_dict. Она должна принимать вложенный словарь и возвращать плоский.
#      Ниже приведены несколько способов решения вышеуказанной задачи.
#      nested = {'Germany': {'berlin': 7},
#                'Europe': {'italy': {'Rome': 3}},
#                 'USA': {'washington': 1, 'New York': 4}}
#      flatten_dict(nested) => {'Germany_berlin': 7,
#                               'Europe_italy_Rome': 3,
#                                'USA_washington': 1,
#                                'USA_New York': 4}
#      nested = {'Q': {'w': {'E': {'r': {'T': {'y': 123}}}}}}
#      flatten_dict(nested) => {'Q_w_E_r_T_y': 123}
#      not_nested = {'a': 100, 'b': 200}
#      flatten_dict(not_nested) => {'a': 100, 'b': 200}
#      Ваша задача только написать определение функции flatten_dict.

def flatten_dict(d: dict) -> dict:
    res = {}
    for k, v in d.items():
        if isinstance(v, int):
            res.update({k:v})
        if isinstance(v, dict):
            for key, value in flatten_dict(v).items():
                res.update({k +'_' + key: value})
    return res

# 404. Есть несколько типов сортировки, которые используют рекурсию. Одна из них называется сортировка слиянием.
#      Ваша задача реализовать этот алгоритм. Для этого нужно будет создать функцию merge_sort, которая будет принимать исходный список
#      и возвращать новый отсортированный в порядке неубывания список. Также для реализации функции merge_sort вам понадобится реализовать функцию merge_two_list. 
#      Функция merge_two_list должна принимать два отсортиванных по неубыванию списка, сливать их в один большой список также отсортированный по неубыванию 
#      (задача Слияние списков ) и возвращать его.
#      Ваша задача написать только определение функций merge_sort и merge_two_list, при этом нельзя пользоваться встроенными сортировками в Python.

def merge_two_list(a, b):
    l = []
    i = j = 0
    while i < len(a) and j < len(b):
        if a[i] < b[j]:
            l.append(a[i])
            i += 1
        else:
            l.append(b[j])
            j += 1
    if i < len(a):
        l += a[i:]
    if j < len(b):
        l += b[j:]
    return l

def merge_sort(s):
    if len(s) == 1:
        return s
    middle = len(s) // 2
    left = merge_sort(s[:middle])
    right = merge_sort(s[middle:])
    return merge_two_list(left, right)

# 405. Быстрая сортировка - еще один вид сортировки, который использует рекурсию.
#      Ваша задача реализовать этот алгоритм. Для этого нужно будет создать функцию quick_sort, 
#      которая будет принимать исходный список и возвращать новый отсортированный в порядке неубывания список.
#      Необходимо написать только определение функций quick_sort, при этом нельзя пользоваться встроенными сортировками в Python.

def quick_sort(s):
    if len(s) <= 1:
        return s
    elem = s[0]
    left = list(filter(lambda x: x < elem, s))
    center = [i for i in s if i == elem]
    right = list(filter(lambda x: x > elem, s))
    return quick_sort(left) + center + quick_sort(right)

# 406. В переменную adding_10 присвойте lambda функцию, которая принимает одно число и увеличивает его на 10. Ничего кроме создания переменной adding_10 делать не нужно.

adding_10 = lambda x: x + 10

# 407. В переменную starts_with присвойте lambda функцию, которая принимает строку и возвращает True, когда переданная строка начинается с буквы W. 
#      Во всех остальных случаях нужно возвращать False. Ничего кроме создания переменной starts_with делать не нужно.

starts_with = lambda s: s.startswith('W')

# 408. Имеется функция sale, которая возвращает цену товара со скидкой 10%.
#      def sale(x):
#           return x*0.9
#      Однако мы изучаем анонимные функции, поэтому на основе данной функции создайте анонимную функцию и присвойте её переменной sale_lambda.

sale_lambda = lambda x: x * 0.9

# 409. Хорошо постарались с прошлой задачей! Однако мы забыли, что скидка должна быть только для тех товаров, стоимость которых больше 50. Вам стоит внести это изменение в прошлый код.
#      Ваша задача только переопределить переменную sale_lambda.

sale_lambda = lambda x: x * 0.9 if x > 50 else x

# 410. Начальник дал Ване задачу возвести в квадрат два числа и сложить полученные результаты. Но Ваня очень разволновался и допустил несколько ошибок.
#      Вам, как опытному коллеге, необходимо исправить ошибки Вани, чтобы начальник не лишил его зарплаты.  Исправления нужно сделать только в пределах одной строки.
#      Вводить и выводить ничего не нужно.

sq = lambda x, y: x ** 2 + y ** 2

# 411. Напишите lambda функцию, которая принимает произвольное количество числовых аргументов и выводит их среднее арифметическое.
#      Для проверки решения присвойте вашу lambda функцию переменной average. Вводить и выводить ничего не нужно, только определить переменную average.

average = lambda *args: sum(args) / len(args)

# 412. Напишите программу, которая отсортирует список subject_marks по возрастанию оценок. Затем распечатайте предметы и оценки, каждую пару на новой строке через пробел.

subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Physics', 93),('History', 82)]
for i in sorted(subject_marks, key=lambda x: x[1]):
    print(*i)

# 413. Напишите программу, которая отсортирует список subject_marks по убыванию оценок. Затем распечатайте предметы и оценки, каждую пару на новой строке через пробел.

subject_marks = [('English', 88), ('Science', 90), ('Maths', 97),
                 ('Physics', 93), ('History', 82), ('French', 78),
                 ('Art', 58), ('Chemistry', 76), ('Programming', 91)]
[print(*_) for _ in sorted(subject_marks, key=lambda x: x[1], reverse=True)]

# 414. Напишите программу, которая отсортирует список subject_marks по убыванию оценок. Предметы, имеющие одинаковые оценки, должны быть отсортированы в алфавитном порядке.
#      Затем распечатайте предметы и оценки, каждую пару на новой строке через пробел.

subject_marks = [('English', 88), ('Science', 90), ('Maths', 88),
                 ('Physics', 93), ('History', 78), ('French', 78),
                 ('Art', 78), ('Chemistry', 88), ('Programming', 91)]
[print(*_) for _ in sorted(subject_marks, key=lambda x: (-x[1], x[0]))]

# 415. Напишите программу, которая отсортирует список models по цвету в лексикографическом порядке (по алфавиту).
#      Затем распечатайте элементы этого списка, каждый элемент на новой строке в формате: Производитель: <make>, модель: <model>, цвет: <color>.

models = [{'make': 'Nokia', 'model': 216, 'color': 'Black'},
          {'make': 'Mi Max', 'model': 2, 'color': 'Gold'},
          {'make': 'Samsung', 'model': 7, 'color': 'Blue'},
          {'make': 'Apple', 'model': 10, 'color': 'Silver'},
          {'make': 'Oppo', 'model': 9, 'color': 'Red'},
          {'make': 'Huawei', 'model': 4, 'color': 'Grey'},
          {'make': 'Honor', 'model': 3, 'color': 'Black'}]
for i in sorted(models, key=lambda x: x["color"]):
    print(f'Производитель: {i["make"]}, модель: {i["model"]}, цвет: {i["color"]}')

# 416. Представьте, у нас есть список товаров и их стоимость, но мы хотим взглянуть на него в отсортированном виде. Вверху хотим видеть самые дорогие товары, внизу самые дешевые.
#      Программа будет принимать строки, в которых сперва указывается название товара, а затем через двоеточие с пробелом его цена - целое положительное число.
#      Строка «конец» означает завершение списка товаров и соответственно окончание ввода. Все товары имеют уникальные названия, цены не дублируются. 
#      Ваша задача вывести список товаров по уменьшению цены.

s, l = input(), []
while s != 'конец':
    l.append(s.split(': '))
    s = input()
[print(i[0]) for i in sorted(l, key=lambda x: int(x[1]), reverse=True)]

# 417. Представьте, что мы с вами сами можем решать кому и сколько статуэток Оскара уйдет (Лео бы тогда давно купался в этих статуэтках).
#      Ваша задача написать программу, которая находит информацию, кто из актеров получил наибольшее и наименьшее количество статуэток.
#      Входные данные: Программа принимает на вход в первой строке натуральное число n - количество вручаемых сегодня наград. 
#      И затем в n следующих строках вводятся имена актеров - победителей.
#      Выходные данные: Нужно вывести в  отдельных строках имена актеров набравших наибольшее и наименьшее количество статуэток и через запятую их количество. 
#      Гарантируется, что всегда будет только один человек, набравший наибольшее и наименьшее количество статуэток.

l = [input() for _ in range(int(input()))]
d = {i: l.count(i) for i in l}
x = sorted(d.items(), key=lambda x: x[1], reverse=True)
print(f"{x[0][0]}, {x[0][1]}")
print(f"{x[-1][0]}, {x[-1][1]}")

# 418. Петя очень популярный парень, у него много друзей и он хочет сохранить их контакты в телефонной книге. 
#      Известно, что у каждого друга может быть один или больше номеров телефонов. Напишите программу, которая поможет Пете находить все номера определённого друга.
#      Формат ввода: В первой строке задано одно целое число N (1 ≤ N ≤ 1000) — количество номеров телефонов, информацию о которых Петя  решил сохранить в телефонной книге. 
#      В следующих N строках заданы телефоны и имена их владельцев через пробел. Телефон — это несколько цифр, записанных подряд, имя же состоит только из русских букв. 
#      Записи не повторяются. В следующей строке записано целое число M (1 ≤ M ≤ 100) — количество запросов от Пети. В следующих M строках записаны сами запросы, 
#      по одному на строке. Каждый запрос — это имя какого-то друга, чьи телефоны Петя хочет сейчас найти, записанное в точности так, как в телефонной книге.
#      Формат вывода: Для каждого запроса от Пети выведите в отдельной строке все телефоны, принадлежащие человеку с этим именем. 
#      Телефоны одного человека выводите в одну строку через пробел в том порядке, в котором они были заданы во входных данных.
#      Если в телефонной книге нет телефонов человека с таким именем, выведите в соответствующей строке «Неизвестный номер» (без кавычек).

phone_book = {}
for _ in range(int(input())):
    phone, name = input().split()
    phone_book.setdefault(name, []).append(phone)
for _ in range(int(input())):
    name = input()
    print(*phone_book.get(name, ['Неизвестный номер']))

# 419. У Игоря N одноклассников. Игорь не смог запомнить их дни рождения и решил составить календарь дней рождений класса. 
#      По известному списку всех дней рождения научитесь определять, у кого день рождения в заданном месяце.
#      Формат ввода: В первой строчке записано целое число N (1 ≤ N ≤ 1000) — количество одноклассников Игоря. В следующих N строчках записана информация об их днях рождения. 
#      Каждая строчка состоит из трёх частей, разделённых пробелом — имени одноклассника, дня и месяца его рождения. 
#      Имя — это строка из русских букв, день — число от 1 до 31, а месяц — строка из набора «янв», «фев», «мар», «апр», «май», «июн», «июл», «авг», «сен», «окт», «ноя», «дек».
#      Имена всех одноклассников Игоря различны. В следующей строчке записано целое число M (1 ≤ M ≤ 100) — количество вопросов, на которое надо ответить. 
#      В следующих M строках содержатся сами вопросы. Вопрос — это название месяца в том же формате, в котором они задаются выше.
#      Формат вывода: Для каждого вопроса в отдельной строчке через пробел выведите имена всех одноклассников, которые родились в указанном месяце. Имена упорядочьте в лексикографическом порядке.
#      Если в заданном месяце никто не родился, выведите сообщение "Нет данных".

people = {}
for _ in range(int(input())):
    name, date, month = input().split()
    people.setdefault(month, []).append(name)
for _ in range(int(input())):
    month = input()
    print(*sorted(people.get(month, ['Нет данных'])))

# 420. Руководитель таксопарка хочет увидеть отчет по всем таксистам, где нужно указать имя таксиста и его среднюю оценку. Информацию в отчете нужно расположить по убыванию средней оценки таксиста.
#      После каждого успешно выполненного заказа, клиент выставляет таксисту оценку - целое число от 1 до 5.
#      Входные данные: Программа будет принимать строки, в которых сперва указывается имя таксиста, а затем через запятую с пробелом его оценка за заказ.
#      Строка "конец" является последней строкой и означает окончание ввода
#      Выходные данные: Нужно расположить таксистов в порядке убывания их средней оценке и вывести имя каждого таксиста и его среднюю оценку в отдельной строке. 
#      В случае совпадения средних оценок нужно расположить каждую группу таксистов, имеющих одинаковый рейтинг,  по имени в алфавитном порядке.

taxi = {}
for s in iter(input, 'конец'):
    name, score = s.split(', ')
    taxi.setdefault(name, []).append(int(score))
for k, v in taxi.items():
    taxi[k] = sum(v) / len(v)
for i in sorted(taxi.items(), key=lambda x: (-x[1], x[0])):
    print(*i)

# 421. Дили Вили Били завели себе аккаунты в одной известной соцсети. Их страницы стали пользоваться популярностью и, конечно же, появились поклонники, оставляющие комментарии. 
#      Ребята решили узнать у кого из них самое большое количество уникальных комментаторов. Ваша задача помочь им в этом и собрать нужную информацию.
#      Входные данные: В каждой строке будет вводиться одно из имен наших героев, а затем через двоеточие и пробел имя комментатора. Комментаторы могут повторяться и комментировать разных персонажей.
#      Строка "конец" означает окончание ввода и встречается последней.
#      Входные данные: Ваша задача вывести в порядке уменьшения популярности 3 строки вида: "Количество уникальных комментаторов у <имя героя> - <количество комментаторов>".
#      На склонение давайте не будем обращать внимание в этой задаче. Гарантируется, что количество уникальных комментаторов у всех наших героев разное. 
#      Могут быть ситуации, когда у героя нету ни единого комментатора, в таком случае все равно нужно выводить информацию о нем.

network = {'Дили': set(), 'Били': set(), 'Вили': set()}
for s in iter(input, 'конец'):
    name, celeb = s.split(': ')
    network[name].add(celeb) 
for k, v in sorted(network.items(), key=lambda x: -len(x[1])):
    print(f'Количество уникальных комментаторов у {k} - {len(v)}')

# 422. Исправьте код с предыдущего задания так, чтобы на экран вывело bye и hello
#      Код с предыдущего задания:
#      def outer() -> None:
#           def say_hello() -> None:
#               print('hello')
# 
#           def say_bye() -> None:
#               print('bye')
# 
#      say_hello()
#      say_bye()

def outer() -> None:
    def say_hello() -> None:
        print('hello')

    def say_bye() -> None:
        print('bye')
        
    say_bye()
    say_hello()
    
outer()

# 423. Пользуясь вложенными функциями, реализуйте простой калькулятор.
#      Необходимо реализовать функцию calculate , которая принимает три параметра:
#      - обязательный числовой параметр x
#      - обязательный числовой параметр y
#      - необязательный строковый параметр operation,  по умолчанию принимает значение английской буквы a
#      В данной функции должны быть реализованы следующие функции:
#      - addition - печатаем сложение двух чисел,
#      - subtraction - печатаем вычитание из первого переданного параметра второго;
#      - division - печатаем деление первого на второго,
#      - multiplication - печатаем умножение двух чисел.
#      Каждая из этих четырёх вложенных функций должна распечатать результат математической операции и ничего не возвращать.
#      А при помощи параметра operation и условного оператора нужно выбрать какая из функций должна быть вызвана:
#      - если operation = a, вызываем функцию addition;
#      - если operation = s, вызываем функции subtraction;
#      - если operation = d, вызываем функции division;
#      - если operation = m, вызываем функции multiplication;
#      calculate(2, 5) # Печатает 7.0
#      calculate(2.2, 15, 'a') # Печатает 17.2
#      calculate(22, 15, 's') # Печатает 7.0
#      calculate(2, 3.2, 'm') # Печатает 6.4
#      calculate(10, 0.4, 'd') # Печатает 25.0
#      Если operation принимает значение, отличное от перечисленных выше букв, то необходимо вывести на экран сообщение Ошибка. Данной операции не существует.
#      Также если мы выполняем деление, то второе число (y) не должен равняться нулю, в противном случае необходимо вывести на экран: На ноль делить нельзя!
#      Вам необходимо написать только определение функции calculate.

def calculate(x:float, y:float, operation:str='a') -> None:
    match operation:
        case 'a': addition = lambda x, y: x + y; print(addition(x, y))
        case 's': subtraction = lambda x, y: x - y;  print(subtraction(x, y))
        case 'm': multiplication = lambda x, y: x * y; print(multiplication(x, y))
        case 'd': division = lambda x, y: x / y; print(division(x, y) if y != 0 else 'На ноль делить нельзя!')
        case   _: print('Ошибка. Данной операции не существует')

# 424. Ваша задача создать функцию-замыкание create_accumulator, она должна накапливать(суммировать) в себе все значения, которые ей будут переданы, при создании сумма должна быть равна нулю. 
#      Посмотрите пример ниже:
#      summator_1 = create_accumulator()
#      print(summator_1(1)) # печатает 1
#      print(summator_1(5)) # печатает 6
#      print(summator_1(2)) # печатает 8
#      summator_2 = create_accumulator()
#      print(summator_2(3)) # печатает 3
#      print(summator_2(4)) # печатает 7
#      При каждом вызове должна возвращаться накопленная сумма, которая хранится в замыкании.
#      Обратите внимание, что объекты из примера summator_1 и summator_2 хранят и накапливают свои собственные суммы.
#      Необходимо только определить функцию-замыкание create_accumulator, остальное мы сделаем за вас.

def create_accumulator():
    s = 0
    def summator(n):
        nonlocal s
        s += n
        return s
    return summator

# 425. На предыдущем шаге мы реализовали функцию-замыкание create_accumulator, которая накапливала сумму, начиная с нуля. 
#      Давайте ее усовершенствуем, чтобы она могла начинать суммировать, начиная с определенного значения. Это значение мы ей будем передавать, но оно является необязательным.  
#      Посмотрите пример ниже:
#      summator_1 = create_accumulator(100)
#      print(summator_1(1)) # печатает 101
#      print(summator_1(5)) # печатает 106
#      print(summator_1(2)) # печатает 108
#      summator_2 = create_accumulator()
#      print(summator_2(3)) # печатает 3
#      print(summator_2(4)) # печатает 7
#      Во втором примере мы не передали значение и значит сумма по умолчанию должна считаться с нуля.
#      Обратите внимание, что объекты из примера summator_1 и summator_2 хранят и накапливают свои собственные суммы.
#      Необходимо только определить функцию-замыкание create_accumulator, остальное мы сделаем за вас.

def create_accumulator(s = 0):
    def summator(n):
        nonlocal s
        s += n
        return s
    return summator

# 426. Ваша задача создать функцию multiply, которая принимает один аргумент. Функция должна запомнить это значение, 
#      и вернуть результат умножения этого числа с переданным вновь значением (см. примеры)
#      f_2 = multiply(2)
#      print("Умножение 2 на 5 =", f_2(5)) #10
#      print("Умножение 2 на 15 =", f_2(15)) #30
#      f_3 = multiply(3)
#      print("Умножение 3 на 5 =", f_3(5)) #15
#      print("Умножение 3 на 15 =", f_3(15)) #45

def multiply(x):
    def inner(n):
        return x * n
    return inner

# 427. Ваша задача создать функцию-замыкание create_dict, она должна сохранять в себе все значения, которые ей будут переданы причем в виде словаря. 
#      Ключами данного словаря должны быть натуральные числа, равные номеру вызова данной функции. 
#      Посмотрите пример ниже:
#      f_1 = create_dict()
#      print(f_1('hello')) # f_1 возвращает {1: 'hello'}
#      print(f_1(100)) # f_1 возвращает {1: 'hello', 2: 100}
#      print(f_1([1, 2, 3])) # f_1 возвращает {1: 'hello', 2: 100, 3: [1, 2, 3]}
#      f_2 = create_dict() # создаем новое замыкание в f_2
#      print(f_2('PoweR')) # f_2 возвращает {1: 'PoweR'}
#      Вызывая первый раз f_1 мы создали пару 1: 'hello', вызывая второй раз добавилась пара 2: 100. и т.д.
#      При каждом вызове должен возвращаться словарь, хранящийся в замыкании.
#      Необходимо только определить функцию-замыкание create_dict, остальное мы сделаем за вас.

def create_dict():
    d = {}
    count = 0
    def inner(x):
        nonlocal d
        nonlocal count
        count += 1
        d.setdefault(count, x)
        return d
    return inner

# 428. Напишите декоратор text_decor, который оборачивает вызов декорированной функции фразами «Hello» и «Goodbye!»: фраза «Hello» печатается до вызова, фраза «Goodbye!» - после
#      @text_decor
#      def simple_func():
#          print('I just simple python func')
#      simple_func()
#      # Вывод
#      Hello
#      I just simple python func
#      Goodbye!
#      @text_decor
#      def multiply(num1, num2):
#          print(num1 * num2)
#      multiply(3, 5)
#      # Вывод
#      Hello
#      15
#      Goodbye!
#      Ваша задача написать только определение функции декоратора text_decor.

def text_decor(func):
    def inner(*args, **kwargs):
        print('Hello')
        func(*args, **kwargs)
        print('Goodbye!')
    return inner

# 429. Напишите декоратор repeater, который дважды вызывает декорированную функцию
#      @repeater
#      def multiply(num1, num2):
#          print(num1 * num2)
#      multiply(2, 7) # после этого распечатается две строки со значением 14
#      multiply(5, 3) # после этого распечатается две строки со значением 15
#      Ваша задача написать только определение функции декоратора repeater.

def repeater(func):
    def inner(*args, **kwargs):
        func(*args, **kwargs)
        func(*args, **kwargs)
    return inner

# 430. Напишите декоратор double_it, который возвращает удвоенный результат вызова декорированной функции
#      @double_it
#      def multiply(num1, num2):
#          return num1 * num2
#      res = multiply(9, 4) # произведение 9*4=36, но декоратор double_it удваивает это значение
#      print(res)
#      @double_it
#      def get_sum(*args):
#          return sum(args)
#      res = get_sum(1, 2, 3, 4, 5)
#      print(res) # печатает 30
#      Ваша задача написать только определение функции декоратора double_it.

def double_it(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs) * 2
    return wrapper


@double_it
def multiply(num1, num2):
    return num1 * num2


@double_it
def some_func_return(a, b, c):
    return a ** b + c


@double_it
def get_sum(*args):
    return sum(args)


assert multiply(9, 4) == 72
assert multiply(100, 4) == 800
assert get_sum(1, 2, 3, 4, 5) == 30
assert some_func_return(4, 5, 4) == 2056
assert get_sum(14, 51, 34) == 198
assert get_sum(14) == 28
assert get_sum() == 0
assert get_sum(43, 5, 43, 43, 43, 43, 3, 2) == 450
print('Good')