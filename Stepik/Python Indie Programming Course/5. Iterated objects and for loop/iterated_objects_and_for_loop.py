# 210. Допишите программу так, чтобы она печатала на экран список, содержащий последовательность чисел 0,1,2,3,4,5,6,7,8,9 ?

print(list(range(10)))

# 211. Какие параметры необходимо передать в функцию range, чтобы получилась последовательность чисел от 12 до 34 включительно ?

print(list(range(12, 35)))

# 212. Теперь давайте добавим шаг. Необходимо сформировать последовательность 25, 33, 41, 49, 57 .... , 169.

print(list(range(25, 170, 8)))

# 213. Нам осталось поработать с убывающими последовательностями. Сформируйте последовательность -11, -12, -13, -14 .... , -35.

print(list(range(-11, -36, -1)))

# 214. Еще одну. Сформируйте последовательность 10, 9, 8, 7, ... , 0.

print(list(range(10, -1, -1)))

# 215. И последняя последовательность 1000, 950, 900, 850, ... , 500.

print(list(range(1000, 450, -50)))

# 216. Программа принимает на вход натуральное число N. Ваша задача: вывести на экран все числа от 1 до N, каждое число на отдельной строке. 

print(*range(1, int(input()) + 1), sep='\n')

# 217. Напишите программу, которая выведет все элементы арифметической прогрессии от 0 до 500 включительно с шагом 5.
#      Каждый элемент выводится отдельно на своей строке в таком виде:
#      0
#      5
#      10
#      15
#      ...
#      495
#      500

print(*range(0, 505, 5), sep='\n')

# 218. Программа принимает на вход натуральное число N. Ваша задача: вывести на экран все числа от N до 1 в сторону уменьшения, каждое число на отдельной строке. 

print(*range(int(input()), 0, -1), sep='\n')

# 219. «Надо было брать биткоин в 2012!» именно такую фразу ваша программа должна вывести на экран 13 раз.
#      Программа должна вывести 13 раз фразу «Надо было брать биткоин в 2012!», каждый раз на отдельной строке и без кавычек.

[print('Надо было брать биткоин в 2012!') for _ in range(13)]

# 220. Каждый, кто смотрел Симпсонов, помнит, что в начале любой серии Барт писал забавные фразы на доске.
#      Давайте и мы напишем подобную программу. На вход ей будет поступать фраза и затем количество раз, которое эту фразу нужно повторить.

(lambda s: [print(s) for _ in range(int(input()))])(input())

# 221. Напишите программу, которая считывает два натуральных числа a и b (гарантируется, что a<b), после чего для всех чисел от a до b включительно выводит:
#      - “Fizz”, если это число делится на 3;
#      - “Buzz”, если это число делится на 5;
#      - “FizzBuzz”, если выполнены оба предыдущих условия;
#      - само это число в остальных случаях.
#      Формат ввода: Два числа a и b, каждое на отдельной строке.
#      Формат вывода: Для всех чисел от a до b напечатайте по одной строке, соответствующей правилам, описанным в условии.

for i in range(int(input()), int(input()) + 1):
    if not i % 3 and not i % 5: print('FizzBuzz')
    elif not i % 3: print('Fizz')
    elif not i % 5: print('Buzz')
    else: print(i)

# 222. Давайте составим сводную информацию о квадратах и кубах интервала чисел.
#      На вход программе подается два натуральных числа a и b (гарантируется, что a<b), после чего для каждого целого числа на интервале 
#      от a до b включительно необходимо вывести фразу следующего вида: «Число {число}; его квадрат = {квадрат}; его куб = {куб}»
#      Кавычки выводить не нужно и пользуйтесь f-строкой.
#      На вход программе подается два натуральных числа a и b, каждое на отдельной строке.
#      Программа должна вывести текст в соответствии с условием задачи.

(lambda a, b: [print(f'Число {i}; его квадрат = {i ** 2}; его куб = {i ** 3}') for i in range(a, b + 1)])(int(input()), int(input()))

# 223. Если перечислить все натуральные числа ниже 10, которые кратны 3 или 5, то получим 3, 5, 6 и 9. Сумма этих чисел 23.
#      Напишите программу, которая принимает натуральное число n и находит сумму всех чисел ниже переданного числа n, которые делятся на 3 или на 5.

print(sum(i for i in range(int(input())) if not i % 3 or not i % 5))

# 224. Стандартная задача на нахождения факториала. Факториал числа n! обозначается и находится по формуле n!=1∗2∗3∗...∗n
#      Значит, согласно этой формуле 4!=1∗2∗3∗4=24, 5!=1∗2∗3∗4∗5=120
#      Но учитывайте, что 1!=1, 0!=1
#      Входные данные: Поступает на вход одно целое число n (n>=0)
#      Выходные данные: Найдите и выведите на экран  n!

f = 1; [(f := f * i) for i in range(1, int(input()) + 1)]; print(f)

# 225. Мишка — маленький белый медвежонок. А как известно, маленькие медвежата в свободное время любят играть в кости на шоколадки. 
#      Одним замечательным солнечным утром, гуляя по льдинам, Мишка встретил своего друга Криса, которому и предложил сыграть в эту занимательную игру.
#      Правила её очень просты: сначала определяется значение n — количество раундов игры. В очередном раунде каждый из игроков один раз бросает стандартный игральный кубик, 
#      на грани которого нанесены различные числа от 1 до 6. Игрок, выбросивший большее значение, становится победителем в раунде. 
#      В случае, если выпавшие значения равны, победа не засчитывается никому.
#      В самой же игре побеждает участник, выигравший в большем количестве раундов. Если же количества побед, заслуженных игроками, равны, то объявляется ничья.
#      Мишка ещё совсем маленький и плохо умеет вести счёт, а потому попросил Вас понаблюдать за ходом игры и сообщить ему результат.
#      Входные данные: 
#      В первой строке входных данных содержится число n (1 ≤ n ≤ 100) — количество раундов игры.
#      Следующие n строк содержат описание раундов. В i-й из них содержится пара целых чисел mi и ci (1 ≤ mi,  ci ≤ 6) — результаты бросков Мишки и Криса в i-ом раунде соответственно.
#      Выходные данные:
#      В случае победы Мишки в единственной строке выведите "Mishka" (без кавычек), а в случае победы Криса выведите "Chris" (без кавычек). 
#      Если же игра сведётся к ничьей, то выведите "Friendship is magic!^^" (без кавычек).

mi = ch = 0
for i in range(int(input())):
    m, c = input().split()
    if m > c: mi += 1
    if m < c: ch += 1
print('Friendship is magic!^^' if mi == ch else 'Mishka' if mi > ch else 'Chris')

# 226. Найдите, в каких строках из введённых и в каком месте упоминается "рок", причем регистр букв не важен.
#      Вместо явного цикла прохода по строке в цикле используйте подходящий метод строки.
#      Формат ввода: На первой строке вводится натуральное число N — количество строк. Далее следуют N строк.
#      Формат вывода: Для каждой строки, в которой есть сочетание символов «рок», нужно вывести (в порядке появления таких строк) 
#      номер этой строки (нумерация начинается с единицы) и номер символа, с которого начинается первое вхождение этой подстроки (нумерация символов также с единицы).

for i in range(1, int(input()) + 1):
    s = input().lower()
    if 'рок' in s :
        print(i, s.find('рок') + 1)

# 227. Предположим, вы переписываете у друга рецепты в блокнотик, но вам не нравится "соль". Переписывайте без этого слова.
#      Формат ввода: На первой строке вводится натуральное число N — количество пунктов рецепта. Далее следуют N строк — пункты рецепта.
#      Формат вывода: Одна строка — пункты рецепта, разделённые запятой и пробелом, без пунктов с упоминанием слова "соль" (то есть таких, в которых нет подстроки "соль" в нижнем регистре).

print(', '.join(s for s in (input() for _ in range(int(input()))) if s.find('соль') == -1))

# 228. Иногда некоторые слова вроде «civilization» или «internationalization» настолько длинны, что их весьма утомительно писать много раз в каком-либо тексте.
#      Будем считать слово слишком длинным, если его длина строго больше 10 символов. Все слишком длинные слова можно заменить специальной аббревиатурой.
#      Эта аббревиатура строится следующим образом: записывается первая и последняя буква слова, а между ними — количество букв между первой 
#      и последней буквой (в десятичной системе счисления и без ведущих нулей). Таким образом, «civilization» запишется как «c10n», а «internationalization» как «i18n».
#      Вам предлагается автоматизировать процесс замены слов на аббревиатуры. При этом все слишком длинные слова должны быть заменены аббревиатурой, 
#      а слова, не являющиеся слишком длинными, должны остаться без изменений.
#      Входные данные: В первой строке содержится целое число n (1 ≤ n ≤ 100). В каждой из последующих n строк содержится по одному слову. 
#      Все слова состоят из малых латинских букв и имеют длину от 1 до 100 символов.
#      Выходные данные: Выведите n строк. В i строке должен находиться результат замены i-го слова из входных данных.

l = [input() for _ in range(int(input()))]
[print(f'{s[0]}{str(len(s[1:-1]))}{s[-1]}' if len(s) > 10 else s) for s in l]

# 229. Перед вами список numbers, состоящий из 100 целых чисел. Ваша задачи пройтись в цикле по элементам списка и вывести на экран каждый элемент на отдельной строке.

numbers = [99, 50, -16, 9, 47, -62, 5, -64, -68, 85, 11, -20, 16, 96, -43, 46, -25, 33, 81, -30, 64, 66, -11, 60, 3, -5, -1,
 -80, 49, -12, -86, -40, -98, -92, -91, -71, 56, -76, -30, -82, 17, -2, -64, 47, 22, -28, 40, 55, 54, -3, -58, -10,
 -35, -15, -2, -60, 70, 50, -77, 83, -49, 42, 27, -58, -79, -2, -100, -42, -18, 38, 95, 9, 98, -89, -46, 96, 64,
 -35, 41, 94, 1, -90, 29, 23, 39, -3, 11, -65, -64, 52, -69, 32, -14, -49, -28, -11, 85, -75, -6, 15]
for n in numbers:
    print(n)

# 230. Перед вами список words, состоящий из 100 строк. Ваша задачи пройтись в цикле по элементам списка и вывести на экран только те элементы, длина которых больше 6.
#      Выводить каждый элемент нужно на отдельной строке в том же порядке, в котором слова расположены в списке words.

words = ['require', 'build', 'head', 'land', 'dark', 'seat', 'have', 'five', 'particularly', 'focus', 'moment',
           'visit', 'past', 'turn', 'bad', 'modern', 'once', 'future', 'pay', 'assume', 'himself', 'physical', 'chance',
           'remember', 'better', 'former', 'believe', 'explain', 'reduce', 'whatever', 'theory', 'during', 'enough',
           'wall', 'commercial', 'challenge', 'tell', 'actually', 'include', 'somebody', 'decade', 'by', 'better',
           'would', 'five', 'cost', 'kitchen', 'our', 'affect', 'board', 'practice', 'full', 'instead', 'apply', 'good',
           'past', 'clearly', 'special', 'both', 'analysis', 'peace', 'truth', 'cultural', 'light', 'answer', 'build',
           'each', 'watch', 'buy', 'theory', 'pretty', 'expect', 'account', 'music', 'sell', 'newspaper', 'reach',
           'fish', 'tax', 'employee', 'start', 'most', 'during', 'citizen', 'develop', 'carry', 'only', 'certainly',
           'rock', 'economy', 'risk', 'later', 'one', 'body', 'star', 'they', 'choice', 'appear', 'return', 'sometimes']
print(*[w for w in words if len(w) > 6], sep='\n')

# 231. Перед вами список numbers, состоящий из 100 целых чисел. Ваша задача пройтись в цикле по элементам списка и увеличить каждый в 2 раза.
#      В итоге изначальный список numbers  должен измениться. В качестве ответа распечатайте измененный список numbers

numbers = [-35, 68, -91, 23, -92, -82, -74, 32, 39, -30, -100, -29, 54, 26, 54, -45, 20, 53, -17, 68, -35, 11, 26, -17, 
           70, 89, -81, -4, 61, -45, 13, 63, -48, -66, -92, -15, -88, -87, -75, 44, -49, -81, 19, -33, -59, 85, -69, -60, 
           9, -98, 28, 11, 15, -35, -80, 5, -20, -52, -45, 26, 47, -16, 40, -14, -12, 15, 73, -16, 29, -98, 93, -77, 1, 85, 
           77, 73, 100, -71, 99, 39, 2, -38, 49, -31, 15, 43, 94, -39, -89, -46, -71, 39, -56, 41, -93, 4, -79, 48, 88, -51]
print(numbers := [n * 2 for n in numbers])

# 232. Ваша задача создать список из n строк. Программа сперва будет принимать натуральное число n, а затем n строк в каждой отдельной строке. В качестве ответа выведите получившийся список.

print([input() for _ in range(int(input()))])

# 233. На первой строке вводится один символ — строчная буква. На второй строке вводится предложение.
#      Нужно вывести список слов (словом считается часть предложения, окружённая символами пустого пространства), 
#      в которых присутствует введённая буква в любом регистре, в том же порядке, в каком они встречаются в предложении.

char = input()
print(*[i for i in input().split() if char.lower() in i or char.upper() in i], sep='\n')

# 234. Линейный поиск, также известный как последовательный поиск, этот метод используется для поиска элемента в списке. Линейный поиск является одним из базовых алгоритмов, 
#      с которым вы должны познакомиться, изучая программирования. Суть алгоритма в следующем: вы должны проверять каждый элемент списка последовательно один за другим, 
#      пока не найдете интересующий вас элемент или пока не закончится весь список.
#      Входные данные: Программа получает на вход в одной строке элементы списка - целые числа, разделенные пробелом. Количество элементов произвольное.
#      И на следующей строке вводится одно число r - значение поиска
#      Выходные данные: Ваша задача реализовать линейный алгоритм поиска введенного значения r. 
#      В случае успеха - выведите порядковый номер(индекс) первого найденного элемента в списке при условии, что индексация начинается с единицы. 
#      Если данный элемент отсутствует - необходимо вывести строку ErrorValue.

s, r = input().split(), input()
for i in range(len(s)):
    if r == s[i]: print(i + 1); break
else: print('ErrorValue')

# 235. На вход программе поступает список из целых чисел. Ваша задача найти в данном списке наименьшее положительное значение. 
#      В случае, если положительных значений нет, выведите строку "Empty".

s = map(int, input().split())
for i in sorted(s):
    if i > 0: print(i); break
else: print('Empty')

# 236. Напишите программу, которая находит рекордное количество вхождений (не обязательно подряд) символа в строку.
#      Формат ввода: Вводится одна строка.
#      Формат вывода: Выводится одно целое число — максимальное количество раз, которое встречается какая-либо буква (без учёта регистра) или иной символ во введённой строке.

s = input().lower()
print(max([s.count(i) for i in s]))

# 237. Для делимости числа на 11 необходимо, чтобы разность между суммой цифр, стоящих на четных местах, и суммой цифр, стоящих на нечетных местах, делилась на 11.
#      Требуется написать программу, которая проверит делимость заданного числа на 11.
#      Программа получает на вход одно натуральное число N, делимость которого надо проверить (1 ≤ N ≤ 1010000).
#      Выведите “YES”, если число делится на 11, или “NO” иначе.

n, x, y = input(), 0, 0
for i in range(len(n)):
    if i % 2: x += int(n[i])
    else: y += int(n[i])
print('NO' if (x - y) % 11 else 'YES')

# 238. На вход программе подается строка, состоящая из различных символов: буквы, цифры, знаки препинания и т.д.
#      Ваша задача определить сколько символов в данной строке являются цифрами и также найти сумму всех этих цифр. Например, в строке "Комната 1408" содержится 4 цифры и их сумма равна 13.
#      В качестве ответа необходимо через пробел вывести 2 числа - количество цифр в введенной строке и их сумму.

s = [int(i) for i in input() if i.isdigit()]
print(len(s), sum(s))

# 239. Одна из стандартных задач на программирование. Подумайте над способом ее решения, если не приходит ничего в голову, загляните в подсказку).
#      Итак, у нас есть последовательность скобочных символов, состоящая только из символов ( и ). Ваша задача определить является ли введенная скобочная последовательность правильной.
#      Правильная скобочная последовательность (ПСП) называется строка, состоящая только символов "скобок", где каждой закрывающей скобке найдётся соответствующая открывающая. 
#      При этом учитывайте, что:
#      - Пустая последовательность является правильной.
#      - Если A – правильная скобочная последовательность, то (A) – правильные скобочные последовательности.
#      - Если A и B – правильные скобочные последовательности, то AB – правильная скобочная последовательность.
#      Если введенная строка является ПСП, выведите YES, в противном случае - NO.

s = input()
while '()' in s:
    s = s.replace('()', '')
print('NO' if s else 'YES') 

# 240. Наша программа принимает на вход последовательность скобочных символов. Ваша задача определить является ли введенная скобочная последовательность правильной.
#      Правильная скобочная последовательность (ПСП) называется строка, состоящая только из символов "скобки", где каждой закрывающей скобке найдётся соответствующая открывающая (причём того же типа). 
#      При этом учитывайте, что:
#      - Пустая последовательность является правильной.
#      - Если A – правильная скобочная последовательность, то (A), [A] и {A} – правильные скобочные последовательности.
#      - Если A и B – правильные скобочные последовательности, то AB – правильная скобочная последовательность.
#      - Если введенная строка является ПСП, выведите YES, в противном случае - NO.

s = input()
while '()' in s or '[]' in s or '{}' in s:
    s = s.replace('()', '')    
    s = s.replace('[]', '')
    s = s.replace('{}', '')
print('NO' if s else 'YES')

# 241. На вход программе поступает строка, состоящая из нескольких слов, знаком разделителем между словами будем считать символ пробела. 
#      Ваша задача исключить из строки дублирующие слова: первое появление слова остается в строке, второе и все последующие появления исключаются. 
#      При сравнении на дубли строк регистр букв не учитывать, это значит слова python и PyThOn считаются одинаковыми. В качестве ответа необходимо вывести итоговую строку без дублей.

s, tmp, result = input().split(), [], []
for i in s:
    if i.lower() not in tmp:
        tmp.append(i.lower())
        result.append(i)
print(*result)

# 242. Давайте на практике применим метод подсчета.
#      На вход вашей программе поступает положительное целое число n, а ваша задача вывести в порядке возрастания все цифры, которые встречались в этом числе, 
#      и напротив каждого также необходимо вывести сколько раз данная цифра встречалась в числе n

c = [0] * 10
for i in input():
    c[int(i)] += 1
for i in range(len(c)):
    if c[i] > 0: print(f'{i} {c[i]}')

# 243. Как видно из названия задачи, вам необходимо отсортировать список, состоящий только из чисел в пределах от -100 до 100 включительно, сортировкой подсчетом.
#      Программа получает на вход число n - количество элементов в списке, затем сами элементы списка. Вам необходимо вывести отсортированный список.
#      P.S. не пользуйтесь встроенной функцией sorted или методом sort.

n, l = int(input()), list(map(int, input().split()))
tmp = [0] * 201
for i in l:
    tmp[i + 100] += 1
for i in range(201):
    if tmp[i] > 0:
        print(tmp[i] * (str(i - 100) + ' '), end='')

# 244. Ваша задача найти сумму всех четырехзначных натуральных чисел, сумма цифр которых равна 20.

result = 0
for i in range(1000, 10000):
    s, x = 0, i
    while x > 0: s += x % 10; x //= 10
    if s == 20: result += i
print(result)

# 245. В этой задаче вам предстоит построить лесенку из чисел. Программа принимает на вход целое положительное число n (n<=15) - количество уровней, 
#      ваша задача вывести n уровней, в каждом из которых стоят числа от 1 до значения уровня.

for i in range(1, int(input()) + 1):
    for j in range(1, i + 1):
        print(j, end=' ')
    print()
    
# 246. Напишите программу для построения горизонтальных столбчатых диаграмм с помощью символа звёздочки. 
#      Формат ввода: Несколько натуральных чисел на одной строке.
#      Формат вывода: Несколько чисел на одной строке.

print(*[int(i) * '*' for i in input().split()], sep='\n')

# 247. Постулат Бертрана (теорема Бертрана-Чебышева, теорема Чебышева) гласит, что для любого n > 1 найдется простое число p в интервале n < p < 2n. 
#      Такая гипотеза была выдвинута в 1845 году французским математиком Джозефем Бертраном (проверившим ее до n=3000000) и доказана в 1850 году Пафнутием Чебышевым. 
#      Рамануджан в 1920 году нашел более простое доказательство, а Эрдеш в 1932 – еще более простое.
#      Ваша задача состоит в том, чтобы решить несколько более общую задачу – а именно по числу n найти количество простых чисел p из интервала n < p < 2n.
#      Напомним, что число называется простым, если оно делится только само на себя и на единицу.
#      Входные данные: Программа принимает на вход целое число n (2 ≤ n ≤ 50000).
#      Выходные данные: Вам необходимо вывести на экран одно число – количество простых чисел p на интервале  n < p < 2n.

n, count = int(input()), 0
for i in range(n + 1, n * 2):
    for j in range(2, int (i ** 0.5) + 1):
        if i % j == 0:
            break
    else:
        count += 1
print(count)

# 248. Вот мы с вами и добрались до легендарной сортировки пузырьком. Все просто, вам поступает число n - количество элементов в списке, и затем сам список.
#      Ваша задача отсортировать список по возрастанию при помощи пузырьковой сортировки, в случае если элементы соседние совпадают менять их ненужно.
#      В качестве ответа нужно вывести отсортированный список и какое количество раз пришлось переставлять элементы в процессе сортировки.

n, count = int(input()), 0
l = list(map(int, input().split()))
for i in range(n - 1):
    for j in range(n - i - 1):
        if l[j] > l[j + 1]:
            l[j], l[j + 1] = l[j + 1], l[j]
            count += 1
print(*l, f'\n{count}')

# 249. Фурик очень любит уроки математики, поэтому, в отличие от Рубика, он их не посещает. Но теперь Фурик хочет получить хорошую оценку по математике. 
#      Для этого Лариса Ивановна, учительница математики, дала ему новое задание. Фурик сразу же решил эту задачу, а вы сможете?
#      Задана система уравнений: 
#      a ** 2 + b = n
#      a + b ** 2 = n  
#      Нужно посчитать количество пар целых чисел (a, b) (0 ≤ a, b), которые удовлетворяют системе.
#      Входные данные: В единственной строке заданы два целых числа n, m (1 ≤ n, m ≤ 1000) — параметры системы. Числа в строке разделены пробелом.
#      Выходные данные: В единственную строку выведите ответ на задачу.

(n, m), count = map(int, input().split()), 0
for a in range(n + 1):
    for b in range(m + 1):
        if a ** 2 + b == n and a + b ** 2 == m: count += 1
print(count)

# 250. Сортировка вставками. Это еще один вид сортировки, который реализуется при помощи вложенных циклов.
#      Программа получает на вход число n - количество элементов в списке, и затем в следующей строке сам список.
#      Ваша задача отсортировать список по возрастанию при помощи сортировки вставками, в случае если элементы соседние совпадают менять их ненужно.
#      В качестве ответа нужно вывести отсортированный список.

n, l = int(input()), list(map(int, input().split()))
for i in range(1, len(l)):
    for j in range(i, 0, -1):
        if l[j] < l[j - 1]: l[j], l[j - 1] = l[j - 1], l[j]
        else: break
print(*l)

# 251. Вам нужно посчитать сумму элементов двумерного квадратного (NxN) списка, которые расположены на главной диагонали.
#      Под главной диагональю матрицы подразумевается диагональ, проведённая из левого верхнего угла в правый нижний.
#      Отличительной особенностью элементов, расположенных на главной диагонали, является то, что у них номер строки совпадает с номером столбца. 
#      У всех остальных элементов матрицы номера строки и столбца различаются.
#      Программа сперва принимает на вход число N (N<=15) - количество строк и столбцов в списке, а затем в N строках записаны элементы списка.

n, res = int(input()), 0
l = [list(map(int, input().split())) for i in range(n)]
for i in range(n):
    for j in range(n):
        if i == j: res += l[i][j]
print(res)

# 252. Задана целочисленная квадратная матрица размером N x N. Необходимо обойти элементы этой матрицы сверху вниз слева направо и вывести элементы именно в таком порядке в виде таблицы. 
#      Программа принимает на вход натуральное число N – количество строк и столбцов матрицы. В каждой из последующих N строк записаны N целых чисел – элементы матрицы. 
#      Все числа во входных данных не превышают 100 по абсолютной величине.

n = int(input())
l = [list(map(int, input().split())) for i in range(n)]
for j in range(n):
    for i in range(n):
        print(l[i][j], end=' ')
    print()

# 253. Задана целочисленная квадратная матрица размером N x N. Необходимо обойти элементы этой матрицы снизу вверх справа налево и вывести элементы именно в таком порядке в виде таблицы. 
#      Программа принимает на вход натуральное число N – количество строк и столбцов матрицы. В каждой из последующих N строк записаны N целых чисел – элементы матрицы.

n = int(input())
l = [list(map(int, input().split())) for i in range(n)]
for i in range(n):
    for j in range(n):
        print(l[~j][~i], end=' ')
    print()

# 254. Задана целочисленная матрица, состоящая из N строк и M столбцов. Необходимо обойти элементы этой матрицы cправа налево сверху вниз и вывести элементы именно в таком порядке в виде таблицы. 
#      Программа принимает на вход два натуральных числа N и M – количество строк и столбцов матрицы. В каждой из последующих N строк записаны M целых чисел – элементы матрицы.

n, m = map(int, input().split())
l = [list(map(int, input().split())) for i in range(n)]
for i in range(n):
    for j in range(m):
        print(l[i][~j], end=' ')
    print()

# 255. Задана целочисленная матрица, состоящая из N строк и M столбцов. Необходимо обойти элементы этой матрицы слева направо снизу вверх и вывести элементы именно в таком порядке в виде таблицы. 
#      Программа принимает на вход два натуральных числа N и M – количество строк и столбцов матрицы. В каждой из последующих N строк записаны M целых чисел – элементы матрицы.

n, m = map(int, input().split())
l = [list(map(int, input().split())) for i in range(n)]
for i in range(n):
    for j in range(m):
        print(l[~i][j], end=' ')
    print()

# 256. Перед Вами матрица размера 5 × 5, состоящая из 24-x нулей и единственной единицы. Строки матрицы пронумеруем числами от 1 до 5 сверху вниз, 
#      столбцы матрицы пронумеруем числами от 1 до 5 слева направо. За один ход разрешается применить к матрице одно из двух следующих преобразований:
#      - Поменять местами две соседние строки матрицы, то есть строки с номерами i и i + 1 для некоторого целого i (1 ≤ i < 5).
#      - Поменять местами два соседних столбца матрицы, то есть столбцы с номерами j и j + 1 для некоторого целого j (1 ≤ j < 5).
#      Вы считаете, что матрица будет выглядеть красиво, если единственная единица этой матрицы будет находиться в ее центре 
#      (в клетке, которая находится на пересечении третьей строки и третьего столбца). Посчитайте, какое минимальное количество ходов потребуется, чтобы сделать матрицу красивой.
#      Входные данные: Входные данные состоят из пяти строк, в каждой из которых записаны пять целых чисел: j-ое число в i-ой строке входных данных обозначает элемент матрицы, 
#      стоящий на пересечении i-ой строки и j-ого столбца. Гарантируется, что матрица состоит из 24-x нулей и единственной единицы.
#      Выходные данные: Выведите единственное целое число — минимальное количество действий, которое требуется, чтобы сделать матрицу красивой.

l = [list(map(int, input().split())) for i in range(5)]
for i in range(5):
    for j in range(5):
        if l[i][j] == 1: print(abs(2 - i) + abs(2 - j))

# 257. Задан целочисленный двумерный массив, состоящий из N строк и M столбцов. Требуется вычислить сумму элементов в каждой строке и в каждом столбце.
#      Программа получает на вход два натуральных числа N и M – количество строк и столбцов двумерного массива. В каждой из последующих N строк записаны M целых чисел – элементы массива. 
#      Все числа во входных данных не превышают 1000 по абсолютной величине.
#      В первой строке вам необходимо вывести N чисел – суммы элементов массива для каждой строки в отдельности.
#      Во второй строке в аналогичном формате выведите M чисел – суммы элементов для каждого столбца.

n, m = map(int, input().split())
l = [list(map(int, input().split())) for i in range(n)]
print(*[sum(l[i][j] for j in range(m)) for i in range(n)])
print(*[sum(l[i][j] for i in range(n)) for j in range(m)])

# 258. Проверьте, является ли двумерный массив симметричным относительно главной диагонали. Главная диагональ — та, которая идёт из левого верхнего угла двумерного массива в правый нижний.
#      Входные данные: Программа получает на вход число n<100, являющееся числом строк и столбцов в массиве. Далее во входном потоке идет n строк по n чисел, являющихся элементами массива.
#      Выходные данные: Программа должна выводить слово Yes для симметричного массива и слово No для несимметричного.

n, c = int(input()), 0
l = [list(map(int, input().split())) for i in range(n)]
for i in range(n):
    for j in range(n):
        if l[i][j] != l[j][i]: c += 1
print('No' if c > 0 else 'Yes')

# 259. В метании молота состязается n спортcменов. Каждый из них сделал m бросков. Победителем считается тот спортсмен, у которого сумма результатов по всем броскам максимальна.
#      Если перенумеровать спортсменов числами от 0 до n-1, а попытки каждого из них – от 0 до m-1, то на вход программа получает массив A[n][m], состоящий из неотрицательных целых чисел. 
#      Программа должна определить максимальную сумму чисел в одной строке и вывести на экран эту сумму и номер строки, для которой достигается эта сумма.
#      Входные данные: Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве. Далее во входном потоке идет n строк по m чисел, являющихся элементами массива.
#      Выходные данные: Программа должна вывести  2 числа: сумму и номер строки, для которой эта сумма достигается. Если таких строк несколько, то выводится номер наименьшей из них. 
#      Не забудьте, что нумерация строк (спортсменов) начинается с 0.

n, m = map(int, input().split())
l, res = [list(map(int, input().split())) for i in range(n)], []
for i in l:
    res.append(sum(i))
print(max(res), res.index(max(res)), sep='\n') 

# 260. В метании молота состязается n спортcменов. Каждый из них сделал m бросков. Победителем соревнований объявляется тот спортсмен, у которого максимален наилучший результат по всем броскам. 
#      Таким образом, программа должна найти значение максимального элемента в данном массиве, а также его индексы (то есть номер спортсмена и номер попытки).
#      Входные данные: Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве. Далее во входном потоке идет n строк по m чисел, являющихся элементами массива.
#      Выходные данные: Программа выводит значение максимального элемента, затем номер строки и номер столбца, в котором он встречается. 
#      Если в массиве несколько максимальных элементов, то нужно вывести минимальный номер строки, в которой встречается такой элемент, 
#      а если в этой строке таких элементов несколько, то нужно вывести минимальный номер столбца. Не забудьте, что все строки и столбцы нумеруются с 0.

n, m = map(int, input().split())
l = [list(map(int, input().split())) for i in range(n)]
res = [max(i) for i in l]
for i in range(n):
    if max(res) in l[i]:
        print(max(res))
        print(i, l[i].index(max(res)), sep = ' ')
        break

# 261. В метании молота состязается n спортcменов. Каждый из них сделал m бросков. Побеждает спортсмен, у которого максимален наилучший бросок. 
#      Если таких несколько, то из них побеждает тот, у которого наилучшая сумма результатов по всем попыткам. Если и таких несколько, победителем считается спортсмен с минимальным номером. 
#      Определите номер победителя соревнований.
#      Входные данные: Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве. Далее во входном потоке идет n строк по m чисел, являющихся элементами массива.
#      Выходные данные: Программа должна вывести одно число - номер победителя соревнований. Не забудьте, что  строки  (спортсмены) нумеруются с 0.

n, m = map(int, input().split())
l, res = [list(map(int, input().split())) for i in range(n)], []
for i in range(n):
    res.append([max(l[i]), sum(l[i])])
print(res.index(max(res)))

# 262. В метании молота состязается n спортcменов. Каждый из них сделал m бросков. Победитель определяется по лучшему результату. 
#      Определите количество участников состязаний, которые разделили первое место, то есть определите количество строк в массиве, которые содержат значение, равное наибольшему.
#      Входные данные: Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве. Далее во входном потоке идет n строк по m чисел, являющихся элементами массива.
#      Выходные данные: Программа должна вывести  одно число - количество победителей соревнования.

n, m = map(int, input().split())
l = [list(map(int, input().split())) for i in range(n)]
maximum = [max(i) for i in l]
print(maximum.count(max(maximum)))

# 263. На днях Иван у себя в прихожей выложил кафель, состоящий из квадратных черных и белых плиток. Прихожая Ивана имеет квадратную форму 4х4, вмещающую 16 плиток. 
#      Теперь Иван переживает, что узор из плиток, который у него получился, может быть не симпатичным. 
#      С точки зрения дизайна симпатичным узором считается тот, который не содержит в себе квадрата 2х2, состоящего из плиток одного цвета.
#      По заданному расположению плиток в прихожей Ивана требуется определить: является ли выполненный узор симпатичным.
#      Программе поступает на вход 4 строки по 4 символа «W» или «B» в каждой, описывающие узор из плиток. Символ «W» обозначает плитку белого цвета, а «B» - черного.
#      Ваша задача вывести «Yes», если узор является симпатичным и «No» в противном случае.

b1 = b2 = w1 = w2 = 0 
for i in range(0, 2):
    s = input()
    for j in range(4):
        if s[j] == 'B': b1 += 1
        else: w1 += 1
for i in range(2, 4):
    s = input()
    for j in range(4):
        if s[j] == 'B': b2 += 1
        else: w2 += 1
print('Yes' if (b1 % 2 or w1 % 2) and (b2 % 2 or w2 % 2) else 'No')

# 264. Миша уже научился хорошо фотографировать и недавно увлекся программированием. Первая программа, которую он написал, позволяет формировать негатив бинарного черно-белого изображения.
#      Бинарное черно-белое изображение – это прямоугольник, состоящий из пикселей, каждый из которых может быть либо черным, либо белым. 
#      Негатив такого изображения получается путем замены каждого черного пикселя на белый, а каждого белого пикселя – на черный.
#      Миша, как начинающий программист, написал свою программу с ошибкой, поэтому в результате ее исполнения мог получаться некорректный негатив. 
#      Для того чтобы оценить уровень несоответствия получаемого негатива исходному изображению, Миша начал тестировать свою программу.
#      В качестве входных данных он использовал исходные изображения. Сформированные программой негативы он начал тщательно анализировать, 
#      каждый раз определяя число пикселей негатива, которые получены с ошибкой.
#      Требуется написать программу, которая в качестве входных данных использует исходное бинарное черно-белое изображение и полученный Мишиной программой негатив, 
#      и на основе этого определяет количество пикселей, в которых допущена ошибка.
#      Программа сперва считывает числа n и m (1 ≤ n, m ≤ 100) – высоту и ширину исходного изображения (в пикселях). Последующие n строк содержат описание исходного изображения. 
#      Каждая строка состоит из m символов «B» и «W». Символ «B» соответствует черному пикселю, а символ «W» – белому. 
#      Далее следует пустая строка, а после нее – описание выведенного Мишиной программой изображения в том же формате, что и исходное изображение.
#      Необходимо вывести на экран число пикселей негатива, которые неправильно сформированы Мишиной программой.

n, m = map(int, input().split())
l1 = [input() for _ in range(n + 1)]
l2 = [input() for _ in range(n)]
count = 0
for i in range(n):
    for j in range(m):
        if l1[i][j] == l2[i][j]:
            count += 1
print(count)

# 265. Рассмотрим таблицу из n строк и n столбцов. Известно, что в клетке, образованной пересечением i-й строки и j-го столбца, записано число i × j. Строки и столбцы нумеруются с единицы.
#      Дано целое положительное число x. Требуется посчитать количество клеток таблицы, в которых находится число x.
#      Входные данные: В единственной строке находятся числа n и x (1 ≤ n ≤ 105, 1 ≤ x ≤ 109) — размер таблицы и число, которое мы ищем в таблице.
#      Выходные данные: Выведите единственное число: количество раз, которое число x встречается в таблице.

n, x = map(int, input().split())
print(sum([i * j == x for j in range(1, n + 1) for i in range(1, n + 1)]))

# 266. Дана матрица размером NxN, требуется найти максимальное значение среди элементов, расположенных на побочной диагонали.
#      Под побочной диагональю матрицы подразумевается диагональ, проведённая из правого верхнего угла до левого нижнего угла.
#      Входные данные: Программа сперва принимает на вход число N (N<=15) - количество строк и столбцов в списке, а затем в N строках записаны элементы списка.
#      Выходные данные: Вывести самой большой элемент на побочной диагонали.

n = int(input())
mtrx, res = [list(map(int, input().split())) for _ in range(n)], []
for i in range(n):
    for j in range(n):
        if i + j + 1 == n: res.append(mtrx[i][j])
print(max(res))

# 267. Ваша задача сформировать квадратную матрицу размером NxN, в которой используется следующее заполнение:
#      - все элементы, находящиеся выше главной диагонали, заполняются значением A;
#      - все элементы, находящиеся ниже главной диагонали, заполняются значением B;
#      - все элементы, находящиеся на главной диагонали, заполняются значением C.
#      В качестве ответа, выведите на экран полученную матрицу.
#      Входные данные: Программа сперва принимает на вход число N (N<=15) - количество строк и столбцов в матрицы, а затем на новой строке три целых числа  A, B и C. 
#      Данные числа используются для заполнения.
#      Выходные данные: Заполните и распечатайте матрицу.

n = int(input())
a, b, c = map(int, input().split())
l = [[0] * n for _ in range(n)]       
for i in range(n):
    for j in range(n):
        if i == j: l[i][j] = c
        elif i < j: l[i][j] = a
        else: l[i][j] = b
[print(*i) for i in l]

# 268. Манао работает на спортивном телевидении. Он долгое время наблюдал за футбольными матчами чемпионата одной страны и начал замечать разные закономерности. 
#      Например, у каждой команды есть две формы: домашняя и выездная. Когда команда проводит матч на своем стадионе, футболисты надевают домашнюю форму, а когда на чужом — выездную. 
#      Единственное исключение из этого правила — когда цвет домашней формы принимающей команды совпадает с цветом формы гостей. В таком случае домашняя команда облачается в свою выездную форму. 
#      Цвета домашней и выездной формы для каждой команды различны.
#      В чемпионате страны участвует n команд и он состоит из n·(n - 1) матчей: каждая из команд принимает каждую другую команду на своем стадионе. 
#      Манао задумался, а сколько раз в течение одного чемпионата случится, что команда, играющая на своем стадионе, оденет выездную форму? 
#      Обратите внимание, что для подсчета этого количества порядок матчей не играет никакого значения.
#      Вам даны цвета домашней и выездной формы каждой команды. Для удобства эти цвета пронумерованы целыми числами таким образом, что никакие два разных цвета не имеют одинаковый номер. 
#      Помогите Манао найти ответ на его вопрос.
#      Входные данные: В первой строке содержится целое число n (2 ≤ n ≤ 30). 
#      В каждой из следующих n строк записана пара разделенных одним пробелом различных целых чисел hi, ai (1 ≤ hi, ai ≤ 100) — номер цвета домашней и выездной форм i-ой команды соответственно.
#      Выходные данные: В единственной строке выведите количество матчей, в которых домашняя команда выступит в выездной форме.

n = int(input())
l = [list(map(int, input().split())) for _ in range(n)]
count = 0
for i in range(n):
    for j in range(n):
        if l[i][0] == l[j][1]:
            count += 1
print(count)