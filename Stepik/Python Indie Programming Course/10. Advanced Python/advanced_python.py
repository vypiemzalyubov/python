# 454. Ниже представлен код, который вам нужно будет дописать.
#      В переменную from_10_to_20 при помощи генератора-выражения сохраните последовательность от 10 до 20 включительно.
#      Затем при помощи функции next выведите первые три элемента. И остается вывести оставшиеся элементы в цикле.

from_10_to_20 = (i for i in range(10, 21))

print(next(from_10_to_20))
print(next(from_10_to_20))
print(next(from_10_to_20))

for value in from_10_to_20:
    print(value)

# 455. Перед вами список words. Необходимо сохранить в переменной lens генератор-выражение, который генерирует длины слов списка words по порядку.
#      Больше от вас в этой задаче ничего не требуется.

words = ['feel', 'graduate', 'movie', 'fashionable', 'bacon', 'drop', 'produce', 'acquisition',
         'cheap', 'strength', 'master', 'perception', 'noise', 'strange', 'am']

lens = (len(word) for word in words)

for i in lens:
    print(i)

# 456. Давайте напишем выражение-генератор, который будет генерировать кортеж состоящий из двух элементов: названия дня недели и номер дня в году.
#      За начало отсчета возьмем наш «любимый» 2022 год. Он начался в субботу, потом воскресенье, понедельник, вторник, ..., пятница, суббота и далее по кругу.
#      Результат выражения-генератор сохраните в переменную days.
#      Названия дней недели должны совпадать с этими значениями: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].
#      Значит при первой итерации генератор должен вернуть кортеж:
#      (1, 'Saturday')
#      При второй итерации вернется значение:
#      (2, 'Sunday')
#      Ваша задача распечатать на удачу 77 первых дней 2022 года. Выводить на экран нужно сами кортежи и первые десять значений в выводе должны выглядеть вот так:
#      (1, 'Saturday')
#      (2, 'Sunday')
#      (3, 'Monday')
#      (4, 'Tuesday')
#      (5, 'Wednesday')
#      (6, 'Thursday')
#      (7, 'Friday')
#      (8, 'Saturday')
#      (9, 'Sunday')
#      (10, 'Monday')

day = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
days = ((i + 1, day[(5 + i) % 7]) for i in range(77))
for _ in range(77):
    print(next(days))

# 457. Ваша задача создать функцию-генератор gen_squares, которая принимает аргумент n и генерирует квадраты чисел от 1 до n включительно. Ниже несколько вариантов использования:
#      for i in gen_squares(5):
#           print(i)
#      # Будет напечатано
#      # 1
#      # 4
#      # 9
#      # 16
#      # 25
#      Ваша задача написать только определение функции gen_squares.

def gen_squares(n: int):
    for i in range(1, n + 1):
        yield i ** 2

# 458. Ваша задача создать функцию-генератор gen_fibonacci_numbers, которая принимает аргумент n и генерирует n-ое количество чисел Фибоначчи.
#      Будем считать, что последовательность Фибоначчи такая: 1, 1, 2, 3, 5, 8, 13, 21, 34, ...
#      Ниже несколько вариантов использования:
#      for i in gen_fibonacci_numbers(5):
#            print(i)
#      # Будет напечатано
#      # 1
#      # 1
#      # 2
#      # 3
#      # 5
#      Ваша задача написать только определение функции gen_fibonacci_numbers.

def gen_fibonacci_numbers(n: int):
    a = b = 1
    for _ in range(n):
        yield a
        a, b = b, a + b

# 459. Ваша задача создать функцию-генератор my_range_gen, которая копирует работу range. 
#      1. my_range_gen можно запускать, передав ей один параметр stop:
#         my_range_gen(stop)
#         и она должна генерировать последовательность от 0 до stop не включительно:
#         for i in my_range_gen(5):
#               print(i)
#         # Будет напечатано
#         # 0
#         # 1
#         # 2
#         # 3
#         # 4
#      2. my_range_gen можно запускать, передав ей два параметра start и stop:
#         my_range_gen(start, stop)
#         и она должна генерировать последовательность от start включительно до stop не включительно:
#         for i in my_range_gen(4, 8):
#               print(i)
#         # Будет напечатано
#         # 4
#         # 5
#         # 6
#         # 7
#      3. my_range_gen можно запускать, передав ей три параметра start, stop и step:
#         my_range_gen(start, stop, step)
#         и она должна генерировать последовательность от start включительно до stop не включительно c шагом step:
#         for i in my_range_gen(4, 8, 2):
#               print(i)
#         # Будет напечатано
#         # 4
#         # 6
#      4. предусмотрите вариант запуска my_range_gen со значением step=0. При таком варианте вызова, функция не должна генерировать ни одной последовательности и закончить свою работу. 
#         Такое же поведение должно быть если переданы нелогичные значения start, stop и step (см. примеры):
#         for i in my_range_gen(4, 8, 0):
#               print(i)
#         # Ничего не печатает
#         for i in my_range_gen(20, 10, 3):
#               print(i)
#         # Ничего не печатает, потому что нельзя пройти от 20 до 10 с шагом 3
#         Ваша задача написать только определение функции my_range_gen. И да, функцией range пользоваться нельзя, можете конечно попробовать, но у вас ничего не получится. 

def my_range_gen(*args):
    if len(args) == 1:
        start = args[0]
        count = 0
        while count < start:
            yield count
            count += 1
    elif len(args) == 2:
        start, stop = args[0], args[1]
        while start < stop:
            yield start
            start += 1
    else:
        start, stop, step = args[0], args[1], args[2]
        if start < stop and step > 0:
            while start < stop:
                yield start
                start += (step)
        elif start > stop and step < 0:
             while start > stop:
                yield start
                start += (step)

# 460. Перед вами имеется список numbers, состоящий из целых чисел. Ваша задача преобразовать каждый элемент списка numbers в строку и сохранить полученный результат в новый список strings. 
#      Для преобразования используйте map. В качестве ответа выведите переменную strings.

numbers = [116, -411, 448, 636, -254, -295, 220, 216, 187, -150, -458, -372, 450, 141, -626, -168, -383, 389, -184, 609, 221, 311, 526, 254, -631, 
           -174, -555, -338, 226, 695, -16, 333, 12, -600, -258, -383, -101, 121, 40, 278, 118, -462, -671, 78, -69, -568, -228, -445, -47, -565]
print(strings := list(map(str, numbers)))

# 461. Перед вами имеется список numbers, состоящий из целых чисел. Ваша задача увеличить каждый элемент списка numbers втрое и сохранить полученный результат в новый список increase_3. 
#      Для преобразования используйте функцию map. В качестве ответа выведите переменную increase_3.

numbers = [116, -411, 448, 636, -254, -295, 220, 216, 187, -150, -458, -372, 450, 141, -626, -168, -383, 389, -184, 609, 221, 311, 526, 254, -631, 
           -174, -555, -338, 226, 695, -16, 333, 12, -600, -258, -383, -101, 121, 40, 278, 118, -462, -671, 78, -69, -568, -228, -445, -47, -565]
print(increase_3 := [*map(lambda x: x * 3, numbers)])

# 462. Напишите программу, которая возводит в квадрат и в куб каждое число из списка numbers пользуясь при этом функциями map и lambda.
#      В результате у вас должно получится два отдельных списка: в одном квадраты, в другом кубы. Их необходимо вывести на экран.

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print([*map(lambda x: x ** 2, numbers)], [*map(lambda x: x ** 3, numbers)], sep='\n')

# 463. Помните задачку про RGB? Сейчас вам предстоит выполнить обратное преобразование. Ваша задача создать функцию from_hex_to_rgb, которая принимает на вход строку
#      - закодированный код цвета в формате RGB и возвращает кортеж из трех значений (оттенок_красного, оттенок_зеленого, оттенок_синего). 
#      Вот посмотрите примеры:
#      from_hex_to_rgb(#000000) => (0, 0, 0)
#      from_hex_to_rgb(#FFFFFF) => (255, 255, 255)
#      from_hex_to_rgb(#FF0000) => (255,0, 0)
#      from_hex_to_rgb(#00FF00) => (0,255, 0)
#      from_hex_to_rgb(#0000FF) => (0,0,255)
#      from_hex_to_rgb(#FFFFFF) => (255,255,255)
#      from_hex_to_rgb(#87CEEB) => (135,206,235)
#      from_hex_to_rgb(#87CEFA) => (135,206,250)
#      from_hex_to_rgb(#191970) => (25,25,112)
#      Как только функция будет готова, ее необходимо применить ко всем элементам списка colors при помощи функции map. 
#      Ниже уже имеется готовый список colors и цикл обхода результата функции map. Добавьте только название функции внутри вызова map, все остальное код сделает за вас.

def from_hex_to_rgb(color: str) -> tuple:
    color = color[1:3], color[3:5], color[5:7]
    return tuple(map(lambda x: int(x, 16), color))

colors = ['#B22222', '#DC143C', '#FF0000', '#FF6347', '#FF7F50', '#CD5C5C', '#F08080', '#E9967A',
          '#FA8072', '#FFA07A', '#FF4500', '#FF8C00', '#FFA500', '#FFD700', '#B8860B', '#DAA520',
          '#EEE8AA', '#BDB76B', '#F0E68C', '#808000', '#FFFF00', '#9ACD32', '#556B2F', '#6B8E23',
          '#7CFC00', '#7FFF00', '#ADFF2F']

for red, green, blue in map(from_hex_to_rgb, colors):
    print(f"Red={red}, Green={green}, Blue={blue}")

# 464. На вход вашей программе поступают английские буквы через пробел в верхнем или маленьком регистре.
#      Ваша задача сформировать список кортежей. Каждый элемент кортежа будет состоять из двух значений: берется соответствующая буква сперва в верхнем регистре, а затем в нижнем (см. примеры ниже)
#      Выведите на экран полученный список кортежей.

print([*map(lambda x: (x.upper(), x.lower()), input().split())])

# 465. Перед вами имеется список кортежей names. Каждый кортеж состоит из двух элементов: имени и фамилии. 
#      Ваша задача на основании списка names создать новый список new_names, где каждый кортеж должен замениться на строку конкатенации имени и фамилии, между которыми стоит пробел. 
#      Вот пример на других данных:
#      names = [('Monica', 'Waters'), ('Juan', 'Lee'), ('Donna', 'Walker')]
#      new_names = ['Monica Waters', 'Juan Lee', 'Donna Walker']
#      Для преобразования используйте функцию map. В качестве ответа выведите переменную new_names.

names = [('Gerald', 'Tucker'), ('Tricia', 'Johnson'), ('Robert', 'Mendez'),
         ('Shawn', 'Gutierrez'), ('Gary', 'Ross'), ('Melanie', 'Warren'),
         ('Drew', 'May'), ('Jennifer', 'Carroll'), ('Ann', 'Lynn'), ('Ralph', 'Vazquez'),
         ('Brittany', 'Erickson'), ('Mark', 'Montoya'), ('Randall', 'Hicks'),
         ('Tyler', 'Miller'), ('Bryan', 'Brown'), ('Joshua', 'Sawyer'),
         ('Sarah', 'Phillips'), ('Donna', 'Davenport'), ('Rebekah', 'Johnson'),
         ('Andrew', 'Reynolds'), ('April', 'Turner'), ('Amanda', 'Ryan'), ('Jennifer', 'Poole'),
         ('Jonathan', 'Lane'), ('Laura', 'Stone'), ('Sara', 'Brown'), ('Alexander', 'Johnson'),
         ('Emily', 'Phillips'), ('Tyler', 'Smith'), ('Victor', 'Kelly'), ('Audrey', 'Thomas'),
         ('Melissa', 'Green'), ('Bethany', 'Holt'), ('Christopher', 'Kerr'), ('Gabrielle', 'Black'),
         ('Jennifer', 'Wade'), ('Douglas', 'Horton'), ('Steven', 'Welch'),
         ('Terri', 'Thompson'), ('Cassandra', 'Nelson'), ('Andrew', 'Jones'),
         ('James', 'Schultz'), ('Richard', 'Castillo'), ('Shaun', 'Logan'),
         ('Danielle', 'Lane'), ('Mark', 'Anderson'), ('Charles', 'Shaw'),
         ('Derrick', 'Grant'), ('Tracy', 'Pierce'), ('Robert', 'Washington')]
print(new_names := [*map(lambda x: f'{x[0]} {x[1]}', names)])

# 466. Перед вами имеется список словарь persons. Изучите внимательно все элементы списка, у них имеется одинаковый набор ключей. 
#      Ваша задача на основании списка persons отобрать информацию о номерах телефона и сложить их в отдельный список phones. 
#      Номера в списке phones должны располагаться в том же порядке, в котором расположены их владельцы в списке persons.
#      В качестве ответа выведите переменную phones. Используйте функцию map.

persons = [
    {
        'birthday': '1983-10-25',
        'job': 'Field seismologist',
        'name': 'Andrew Hernandez',
        'phone': '680-436-8521x3468'
    },
    {
        'birthday': '1993-10-03',
        'job': 'Pathologist',
        'name': 'Paul Harmon',
        'phone': '602.518.4130'
    },
    {
        'birthday': '2002-06-11',
        'job': 'Designer, multimedia',
        'name': 'Gregory Flores',
        'phone': '691-498-5303x079'
    },
    {
        'birthday': '2006-11-28',
        'job': 'Print production planner',
        'name': 'Jodi Garcia',
        'phone': '(471)195-7189'},
    {
        'birthday': '2019-12-05',
        'job': 'Warehouse manager',
        'name': 'Elizabeth Cannon',
        'phone': '001-098-434-5950x276'
    },
    {
        'birthday': '1984-06-12',
        'job': 'Visual merchandiser',
        'name': 'Troy Lucas',
        'phone': '+1-018-070-2288x18433'
    },
    {
        'birthday': '1993-09-14',
        'job': 'International aid/development worker',
        'name': 'Laurie Sandoval',
        'phone': '2930693269'
    },
    {
        'birthday': '1999-05-25',
        'job': 'Editor, film/video',
        'name': 'Jack Clark',
        'phone': '8643048473'
    },
    {
        'birthday': '1985-09-11',
        'job': 'Magazine journalist',
        'name': 'Kimberly Johnson',
        'phone': '+1-583-428-7663'
    },
    {
        'birthday': '1990-10-07',
        'job': 'Museum/gallery curator',
        'name': 'Austin Liu PhD',
        'phone': '714-879-5250'
    }
]
print(phones := [*map(lambda x: x['phone'], persons)])

# 467. Имеется три списка из 50 элементов: list_x, list_y и list_w. Ваша задача произвести научные расчеты для соответствующий значений этих списков. 
#      Нужно подставить в формулу: x ** 2 - x * y * w - w ** 4. 
#      Поочередно первые значения из списков list_x, list_y и list_w, потом вторые, затем третьи и т.д.  Значения из списка list_x должны подставляться в переменную x, 
#      из списка list_y - в переменную y и из списка list_w - в переменную w. Всего должно получиться 50 вычисленных значений. Их необходимо сложить в список и вывести на экран.

list_x = [25, 48, 23, 13, -18, -10, -3, 16, 2, -12, 20, -14, 14, 45, 41, 6, 11, 15, 22,
          -14, -11, 41, 15, 48, 47, 41, -8, 1, 4, 1, 40, 27, -11, -2, -14, -15, 35, 4,
          49, 4, 5, 13, 50, 35, -3, 3, 30, -11, 7, 12]

list_y = [-9, 17, 41, 47, -5, -10, -5, 13, 31, -11, 37, 9, 46, 27, -1, 36, 32, 23, -12,
          38, 8, 9, 17, 16, 29, -4, 4, 2, 1, 46, 6, 49, -16, 21, -19, -10, 15, -13, 20,
          13, -18, 21, -17, 21, 10, 5, 38, -1, 18, 22]

list_w = [9, -26, 3, 21, 48, -14, 43, -4, -16, 16, 41, 43, -27, -9, 10, -10, 4, -2, 1,
          7, 30, -29, 11, 17, 31, 31, -26, 38, 38, -17, 35, 17, 35, 10, -25, 42, -30,
          -10, -20, 20, 15, 0, 29, -30, -21, -13, -27, -21, -18, -26]

print([*map(lambda x, y, w: pow(x, 2) - x * y * w + pow(w, 4), list_x, list_y, list_w)])

# 468. Напишите программу, которая отфильтрует список numbers так, чтобы в нем остались только четные значения. Используйте при этом lambda функцию.
#      Распечатайте получившийся список.

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(list(filter(lambda x: not x % 2, numbers)))

# 469. Вам дан список numbers, в нем есть и отрицательные числа и нули и положительные значения. Гарантируется, что список целиком состоит только из чисел.
#      Необходимо при помощи функций filter и len определить в этом списке количество:
#      - отрицательных значений
#      - нулевых значений
#      - положительных
#      Вывести найденные значения в том же порядке в одну строку через пробел.

numbers = [54, 71, 65, 51, 36, -82, -32, 61, -61, 92, 17, -68, -62, 40, 16, -49, -51, -38, 60, -24, -61, 3, -26, -46, -97, -28, 36, 7, 52, 56, -96, -69, 67, 
           76, 16, 36, 38, 74, 11, -87, 69, 69, -69, -61, 92, 67, -45, -26, 94, 38, 27, -26, 10, 55, 28, -81, 53, -75, -32, -83, 38, 83, -40, -51, 88, 28, 76, 
           25, 84, -79, -69, -65, 6, 12, 81, -58, -92, 44, -41, 60, -14, -65, 7, 64, -40, -25, -91, -23, -19, -40, -4, 36, 38, 28, -27, -28, 72, 47, -95, 47, 
           10, 31, 62, -75, 22, -34, 44, -62, -30, -41, 19, -13, 30, -11, -54, -46, -80, -57, -60, 72, -49, 84, 5, 66, 62, -35, 69, 23, 41, -15, 75, -53, 94, 
           -76, -28, -41, -17, 71, 67, -50, 18, 65, -16, -27, -88, 21, -42, 58, 85, 36, 9, -72, -26, -73, -1, 41, -87, 85, 5, -92, -60, -33, 33, -74, 17, 47, 
           -38, -95, -39, 64, 85, -27, -42, -91, -39, -15, -75, 78, -54, 26, -10, -3, 89, -11, -71, -85, 63, 9, -59, 72, 27, 40, 99, -9, 77, 64, -39, -28, 73, 
           -50, -80, -74, 52, 26, 53, -18, 22, 70, 85, 1, -90, 53, -19, -80, -14, -29, -64, -21, 23, 99, 15, -52, 66, 30, 82, -81, -30, -68, 30, -25, -63, 33, 
           1, 0, 84, 18, -35, 31, -34, 10, 48, -37, -41, -94, -1, -14, -87, -37, -6, 48, 38, 33, -13, 71, -81, 45, -63, 52, -35, 34, -88, -82, -7, -92, -22, 96, 
           -28, 0, 21, 74, -28, 81, 81, 44, -16, 17, -95, 18, -73, 15, -61, 6, -43, -67, -31, -61, -72, -66, 60, 67, -13, 47, 29, 44, -93, 55, -13, -23, 74, 79, 
           32, -20, 33, 17, -48, 7, 24, 19, 89, -60, 34, 81, 18, -39, 56, 10, -32, 46, -33, -75, -99, -37, -23, 59, -33, -1, 75, -65, 92, 80, 51, -59, -28, -22, 
           -47, -1, 28, -85, 1, 23, -15, -66, -97, -25, 7, 17, -87, -60, 14, -70, 88, 20, 40, -89, 38, -41, -97, 76, 80, 43, 22, -72, -38, 47, -2, 12, 58, -91, 82, 
           -98, 50, 15, -33, -56, 69, -27, 94, -90, 92, -71, -73, -71, -78, 22, -86, -48, 10, 46, 19, 68, -23, 52, -42, 74, 44, 89, -71, 93, 43, -86, 79, 3, -56, 14, 
           41, 15, -37, 77, -9, 36, 51, -89, 1, 37, 82, 27, 72, -92, 91, 94, 71, -81, -49, -42, 26, 57, -30, -40, 86, -77, -85, 1, 71, 16, 73, -82, 26, -90, 72, 14, 
           -65, -55, 34, 45, 66, -64, -40, 92, 42, -78, -22, 53, -18, -41, -75, 10, -59, -55, 8, -90, -3, -65, 43, -49, -86, -96, 69, 48, 27, -48, -42, -34, -6, 7, 
           50, -55, -65, 79, 30, 16, -21, -98, -73, -25, -20, -51, 20, 17, -91, 34, 96, 12, 13, -58, -73, -82, 19, -48, -61, 57, 96, 74, 34, -63, 38, -27, -12, -24, 
           94, -25, -10, -41, 53, -13, 16, -21, 24, 96, 95, 58, 83, 10, 42, -11, -33, 10, 38, -6, -66, -40, -36, -99, -55, 37, -81, -93, 67, -77, -3, 77, 25, 38, -16, 
           21, -82, 77, 95, 73, 9, 94, -27, -21, -33, -90, 31, 98, 28, -63, 75, 53, -17, -1, 6, 51, 11, -92, 30, -24, 12, 47, -75, -15, -63, 57, 3, 37, -82, -28, -26, 
           -3, -30, -90, -45, 20, -41, 72, -42, 15, -3, 92, 57, -1, 40, -65, 88, 28, -76, 52, -63, -51, 59, 69, -39, -47, -1, -18, -57, 68, 77, 66, 62, -71, 31, -50, 
           61, 88, 98, 5, 98, -57, -46, 2, 90, 43, 67, 76, -81, -57, 77, 25, -66, -81, -92, -76, 72, 14, 59, 52, 36, 20, -2, 92, 58, 36, -34, 94, -74, 42, -56, 96, -81,
           69, -83, 71, -13, -13, 56, 86, -29, 58, -17, 65, 70, 74, 28, 8, 91, 51, 79, -57, -86, 5, -37, -67, -28, 56, 65, -90, 97, -20, 81, -85, -45, 46, -74, 76, -75, 
           -7, 74, 82, 56, 14, -43, 20, -48, -99, 19, -39, -66, 44, -75, 24, -5, -70, 85, -12, 20, -85, -69, -26, -57, 28, -96, 42, -56, 13, 80, -48, 59, 11, -30, 4, -96, 
           58, 41, -2, -84, -51, 52, -69, 37, 60, -12, 48, -5, -48, 29, -62, 42, 15, 16, 65, 60, 43, -53, 4, 50, -21, 1, -21, -42, -57, -21, -50, -67, 77, -22, -5, 59, -67,
           86, -77, 39, -67, 41, 83, -21, 33, 73, 55, 80, 93, 44, -71, 38, -93, 4, 83, -52, 75, -51, 1, -11, -45, 56, 81, 84, 70, 23, -36, -63, 69, 1, 86, -21, 53, -85, 70, 
           -89, -31, -10, -94, -76, -17, -21, -60, 49, -22, -48, 67, 21, 18, 89, 20, 73, -43, -17, -52, 36, -21, 6, -37, -98, 94, 56, 31, 99, 86, 65, -19, -67, 46, 20, -29, 
           -88, -54, 88, -12, -69, 17, 83, -94, 21, 59, -99, 70, -54, -35, 2, 58, 93, 1, -35, -44, 47, 40, 55, 10, -15, -96, -42, 10, -83, -82, -26, 48, 78, -72, 56, -99, -36, 
           25, 76, -3, -95, -38, -24, 96, 82, 7, 84, 46, 8, 93, -52, -86, 87, -85, -81, 52, -67, 52, -45, -93, -69, 60, -83, -20, -14, 80, -36, 62, -78, 3, -61, 51, 48, 73, 92, 
           -65, 71, -86, 8, -14, 82, 58, -58, -21, 62, -38, 16, 20, -80, -78, 19, 19, 93, -83, 2, 71, 85, 71, -4, 81, 4, 90, 73, 21, -3, -55, 49, 66, -4, -6, 42, 76, -3, -94, 49, 
           55, -53, 12, 1, -25, 56, 93, -68, -21, 15, -13, 35, 71, -68, 34, -44, 48, 97, 51, 32, 87, 27, -85, -41, -27, 54, -91, -99, 83, -44, 70, -87, -76, 49, 99, 38, 15, 75, -54, 
           -59, 22, 80, 49, -63, 8, -46, 97, -4, -92, -47, -20]
print(*[len(list(filter(func, numbers))) for func in [lambda x: x < 0, lambda x: not x, lambda x: x > 0]])

# 470. Напишите программу, которая отфильтрует список days так, чтобы в нем остались только дни, названия которых состоят из  четырех символов или начинаются с буквы S. 
#      Используйте при этом lambda функцию. Распечатайте получившийся список в алфавитном порядке, каждый элемент на новой строчке.

days = ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Eleven', 'Twelve']
print(*sorted(list(filter(lambda x: len(x) == 4 or x[0] == 'S', days))), sep='\n')

# 471. Перед вами два списка одинаковой длины keys и values.
#      Ваша задача создать словарь result, в котором пара ключ-значение берется из значений списков, стоящих на одинаковых индексах. В качестве ответа выведите словарь result.

keys = ['Ten', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety', 'One hundred']
values = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
print(result := {k: v for k, v in zip(keys, values)})

# 472. Перед вами два списка:
#      1. employees содержит имена работников
#      2. identifiers содержит уникальные идентификаторы работников
#      Сейчас значения в каждом списке перемешаны и не понятно какому работнику какой идентификатор принадлежит. Отдел кадров просит вас создать словарь employees_data, 
#      в котором, ключами будут идентификаторы, а значениями - имена работников. При этом отдел кадров просит соотнести идентификатор работника с именем следующим образом:
#      - Выбирается самый маленький идентификатор из списка identifiers
#      - Выбирается первое имя по алфавиту из списка employees
#      - Создается пара ключ-значение. В нашем случае самый маленький идентификатор 5, первое имя по алфавиту будет Anfisa. Значит создаем пару 5: 'Anfisa'
#      - Процесс повторяется со следующими значениями. Берется второй по старшинству идентификатор и второе имя по алфавиту, создается пара в словаре и вновь повторяем процесс
#      В итоге у вас должен получится словарь employees_data , его выводить не нужно!!! Только правильно заполнить.

employees = [
    'Pankratiy', 'Innokentiy', 'Anfisa', 'Yaroslava', 'Veniamin',
    'Leonti', 'Daniil', 'Mishka', 'Lidochka',
    'Terenti', 'Vladik', 'Svetka', 'Maks', 'Yura', 'Sergei'
]

identifiers = [77, 48, 88, 85, 76, 81, 62, 43, 5, 56, 17, 20, 37, 32, 96]

employees_data = dict(zip(*map(sorted, (identifiers, employees))))

# 473. Напишите функцию zip_with_function(), которая принимает список списков и функцию, которая принимает несколько аргументов и возвращает значение. 
#      Функция zip_with_function() должна использовать функцию zip() для объединения списков в кортежи, а затем применять заданную функцию к кортежам из соответствующих позиций каждого списка. 
#      Результатом должен быть новый список, содержащий значения, возвращаемые функцией для каждой комбинации элементов.
#      Например, имеется функция:
#      def get_sum_two_numbers(a, b):
#          return a + b
#      Тогда вызов
#      zip_with_function([[1, 2, 4], [3, 5, 8]], get_sum_two_numbers)
#      должен вернуть список [4, 7, 12].
#      Ваша задача написать только определение функции zip_with_function.

def zip_with_function(lists, func):
    return [func(*args) for args in zip(*lists)]

def combine_strings(a: str, b: str) -> str:
    return a + b

def get_sum_two_numbers(a: int, b: int) -> int:
    return a + b

def get_sum_three_numbers(a: int, b: int, c: int) -> int:
    return a + b + c

assert zip_with_function([[1, 2, 4], [3, 5, 8]], get_sum_two_numbers) == [4, 7, 12]
assert zip_with_function([[10, 20], [30, 0]], get_sum_two_numbers) == [40, 20]
assert zip_with_function([[2, 5, 8], [3, 4, 7], [5, 6, 5]], get_sum_three_numbers) == [10, 15, 20]
assert zip_with_function([[1, 2, 3], [4, 5, 6], [7, 8, 9]], get_sum_three_numbers) == [12, 15, 18]
assert zip_with_function([["a", "b"], ["1", "2"]], combine_strings) == ['a1', 'b2']

# 474. Ваша задача написать функцию count_strings, которая принимает произвольное количество аргументов. 
#      Функция должна среди всех переданных значений найти только строки, найти их количество и вернуть в качестве результата.
#      Ниже представлены примеры:
#      count_strings(1, 2, 'hello', [2, 3, 4], True) => 1
#      count_strings('am', 'world', 'hello', 'is') => 4
#      count_strings() => 0 
#      count_strings(True, False) => 0
#      Ваша задача написать только определение функции count_strings.

def count_strings(*args):
    return sum(1 for c in args if isinstance(c, str))

# 475. Ваша задача написать функцию find_keys, которая принимает произвольное количество именованных аргументов. Функция должна отобрать только те имена параметров, 
#      у которых значения являются списками или кортежами. Функция find_keys должна собрать все имена таких параметров в список, отсортировать их по алфавиту 
#      вне зависимости от регистра букв и вернуть в качестве результата.
#      Ниже представлены примеры:
#      find_keys(t=[4, 5], W=[5, 3], A=(3, 2), a={2, 3}, b=[4]) => ['A', 'b', 't', 'W']
#      find_keys(name='Bruce', surname='Wayne') => []
#      find_keys(marks=[4, 5], name='ashle', surname='Brown', age=20, Also=(1, 2)) => ['Also', 'marks']
#      Ваша задача написать только определение функции find_keys.

def find_keys(**kwargs):
    keys = [k for k, v in kwargs.items() if isinstance(v, list|tuple)]
    return sorted(keys, key=lambda x: x.lower())