# Реализуйте программу, которая принимает последовательность чисел и выводит их сумму.
# Вашей программе на вход подается последовательность строк.
# Первая строка содержит число n (1 ≤ n ≤ 100).
# В следующих n строках содержится по одному целому числу.
# Выведите одно число – сумму данных n чисел.

print(sum([int(input()) for _ in range(int(input()))]))

# Реализуйте программу, которая будет вычислять количество различных объектов в списке.
# Два объекта a и b считаются различными, если a is b равно False.
# Вашей программе доступна переменная с названием objects, которая ссылается на список, содержащий не более 100 объектов. 
# Выведите количество различных объектов в этом списке.

objects = input()
print(len({id(x) for x in objects}))

# Напишите реализацию функции closest_mod_5, принимающую в качестве единственного аргумента целое число x и возвращающую самое маленькое целое число y, такое что:
# - y больше или равно x
# - y делится нацело на 5

def closest_mod_5(x):
    while x % 5:
        x += 1
    return x

# Сочетанием из n элементов по k называется подмножество этих n элементов размера k.
# Два сочетания называются различными, если одно из сочетаний содержит элемент, который не содержит другое.
# Числом сочетаний из n по k называется количество различных сочетаний из n по k. Обозначим это число за C(n, k).
# Пример:
# Пусть n = 3, т. е. есть три элемента (1, 2, 3). Пусть k = 2.
# Все различные сочетания из 3 элементов по 2: (1, 2), (1, 3), (2, 3).
# Различных сочетаний три, поэтому C(3, 2) = 3.
# Несложно понять, что C(n, 0) = 1, так как из n элементов выбрать 0 можно единственным образом, а именно, ничего не выбрать.
# Также несложно понять, что если k > n, то C(n, k) = 0, так как невозможно, например, из трех элементов выбрать пять.
# Для вычисления C(n, k) в других случаях используется следующая рекуррентная формула:
# C(n, k) = C(n - 1, k) + C(n - 1, k - 1).
# Реализуйте программу, которая для заданных n и k вычисляет C(n, k).
# Вашей программе на вход подается строка, содержащая два целых числа n и k (1 ≤ n ≤ 10, 0 ≤ k ≤ 10).
# Ваша программа должна вывести единственное число: C(n, k).

def combine(n, k):
    if k == 0:
        return 1
    elif k > n:
        return 0
    return combine(n - 1, k) + combine(n - 1, k - 1)

n, k = map(int, input().split())
print(combine(n, k))

# Реализуйте программу, которая будет эмулировать работу с пространствами имен. Необходимо реализовать поддержку создания пространств имен и добавление в них переменных.
# В данной задаче у каждого пространства имен есть уникальный текстовый идентификатор – его имя.
# Вашей программе на вход подаются следующие запросы:
# - create <namespace> <parent> –  создать новое пространство имен с именем <namespace> внутри пространства <parent>
# - add <namespace> <var> – добавить в пространство <namespace> переменную <var>
# - get <namespace> <var> – получить имя пространства, из которого будет взята переменная <var> при запросе из пространства <namespace>, или None, если такого пространства не существует
# 
# Рассмотрим набор запросов
# - add global a
# - create foo global
# - add foo b
# - create bar foo
# - add bar a
# 
# Структура пространств имен описанная данными запросами будет эквивалентна структуре пространств имен, созданной при выполнении данного кода
# a = 0
# def foo():
#   b = 1
#   def bar():
#     a = 2
# 
# В основном теле программы мы объявляем переменную a, тем самым добавляя ее в пространство global. Далее мы объявляем функцию foo, что влечет за собой создание локального 
# для нее пространства имен внутри пространства global. В нашем случае, это описывается командой create foo global. Далее мы объявляем внутри функции foo функцию bar, 
# тем самым создавая пространство bar внутри пространства foo, и добавляем в bar переменную a.
# 
# Добавим запросы get к нашим запросам
# - get foo a
# - get foo c
# - get bar a
# - get bar b
# 
# Представим как это могло бы выглядеть в коде
# a = 0
# def foo():
#   b = 1
#   get(a)
#   get(c)
#   def bar():
#     a = 2
#     get(a)
#     get(b)
# 
# Результатом запроса get будет имя пространства, из которого будет взята нужная переменная.
# Например, результатом запроса get foo a будет global, потому что в пространстве foo не объявлена переменная a, но в пространстве global, внутри которого находится пространство foo, она объявлена. 
# Аналогично, результатом запроса get bar b будет являться foo, а результатом работы get bar a будет являться bar.
# Результатом get foo c будет являться None, потому что ни в пространстве foo, ни в его внешнем пространстве global не была объявлена переменная с.
# 
# Более формально, результатом работы get <namespace> <var> является
# - <namespace>, если в пространстве <namespace> была объявлена переменная <var>
# - get <parent> <var> – результат запроса к пространству, внутри которого было создано пространство <namespace>, если переменная не была объявлена
# - None, если не существует <parent>, т. е. <namespace>﻿ – это global
# 
# Формат входных данных
# В первой строке дано число n (1 ≤ n ≤ 100) – число запросов.
# В каждой из следующих n строк дано по одному запросу.
# Запросы выполняются в порядке, в котором они даны во входных данных.
# Имена пространства имен и имена переменных представляют из себя строки длины не более 10, состоящие из строчных латинских букв.
# 
# Формат выходных данных
# Для каждого запроса get выведите в отдельной строке его результат.

scopes = dict({'global':[None]})

def create(namespace, parent):
    scopes.update({namespace:[parent]})

def add(namespace, var):
    scopes[namespace].append(var)

def get(namespace, var):
    while namespace != None and var not in scopes[namespace][1:]:
        namespace = scopes[namespace][0]
    print(namespace)

operations = {'create': create, 'add': add, 'get': get}
for i in range(int(input())):
    n = input().split()
    operations[n[0]](n[1], n[2])

# Реализуйте класс MoneyBox, для работы с виртуальной копилкой.
# Каждая копилка имеет ограниченную вместимость, которая выражается целым числом – количеством монет, которые можно положить в копилку. 
# Класс должен поддерживать информацию о количестве монет в копилке, предоставлять возможность добавлять монеты в копилку и узнавать, 
# можно ли добавить в копилку ещё какое-то количество монет, не превышая ее вместимость.
# 
# Класс должен иметь следующий вид
# class MoneyBox:
#     def __init__(self, capacity):
#         # конструктор с аргументом – вместимость копилки
# 
#     def can_add(self, v):
#         # True, если можно добавить v монет, False иначе
# 
#     def add(self, v):
#         # положить v монет в копилку
# 
# При создании копилки, число монет в ней равно 0.
# Примечание: Гарантируется, что метод add(self, v) будет вызываться только если can_add(self, v) – True.

class MoneyBox:
    def __init__(self, capacity):
        self.capacity = capacity
        self.count = 0
    
    def can_add(self, v):
        return self.count + v <= self.capacity
    
    def add(self, v):
        self.count += v

# Вам дается последовательность целых чисел и вам нужно ее обработать и вывести на экран сумму первой пятерки чисел из этой последовательности, затем сумму второй пятерки, и т. д.
# Но последовательность не дается вам сразу целиком. С течением времени к вам поступают её последовательные части. 
# Например, сначала первые три элемента, потом следующие шесть, потом следующие два и т. д.
# Реализуйте класс Buffer, который будет накапливать в себе элементы последовательности и выводить сумму пятерок последовательных элементов по мере их накопления.
# Одним из требований к классу является то, что он не должен хранить в себе больше элементов, чем ему действительно необходимо, 
# т. е. он не должен хранить элементы, которые уже вошли в пятерку, для которой была выведена сумма.
# 
# Класс должен иметь следующий вид
# class Buffer:
#     def __init__(self):
#         # конструктор без аргументов
#     
#     def add(self, *a):
#         # добавить следующую часть последовательности
# 
#     def get_current_part(self):
#         # вернуть сохраненные в текущий момент элементы последовательности в порядке, в котором они были     
#         # добавлены
# 
# Пример работы с классом
# buf = Buffer()
# buf.add(1, 2, 3)
# buf.get_current_part() # вернуть [1, 2, 3]
# buf.add(4, 5, 6) # print(15) – вывод суммы первой пятерки элементов
# buf.get_current_part() # вернуть [6]
# buf.add(7, 8, 9, 10) # print(40) – вывод суммы второй пятерки элементов
# buf.get_current_part() # вернуть []
# buf.add(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) # print(5), print(5) – вывод сумм третьей и четвертой пятерки
# buf.get_current_part() # вернуть [1]
# 
# Обратите внимание, что во время выполнения метода add выводить сумму пятерок может потребоваться несколько раз до тех пор, пока в буфере не останется менее пяти элементов.

class Buffer:

    def __init__(self):
        self.current_part = []

    def add(self, *a):
        self.current_part.extend(a)
        while len(self.current_part) - 5 >= 0:
            print(sum(self.current_part[0:5]))
            del(self.current_part[:5])

    def get_current_part(self):
        return self.current_part