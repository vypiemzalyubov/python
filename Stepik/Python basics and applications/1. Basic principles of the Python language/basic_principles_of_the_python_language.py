# Реализуйте программу, которая принимает последовательность чисел и выводит их сумму.
# Вашей программе на вход подается последовательность строк.
# Первая строка содержит число n (1 ≤ n ≤ 100).
# В следующих n строках содержится по одному целому числу.
# Выведите одно число – сумму данных n чисел.

print(sum([int(input()) for _ in range(int(input()))]))

# Реализуйте программу, которая будет вычислять количество различных объектов в списке.
# Два объекта a и b считаются различными, если a is b равно False.
# Вашей программе доступна переменная с названием objects, которая ссылается на список, содержащий не более 100 объектов. 
# Выведите количество различных объектов в этом списке.

objects = input()
print(len({id(x) for x in objects}))

# Напишите реализацию функции closest_mod_5, принимающую в качестве единственного аргумента целое число x и возвращающую самое маленькое целое число y, такое что:
# - y больше или равно x
# - y делится нацело на 5

def closest_mod_5(x):
    while x % 5:
        x += 1
    return x

# Сочетанием из n элементов по k называется подмножество этих n элементов размера k.
# Два сочетания называются различными, если одно из сочетаний содержит элемент, который не содержит другое.
# Числом сочетаний из n по k называется количество различных сочетаний из n по k. Обозначим это число за C(n, k).
# Пример:
# Пусть n = 3, т. е. есть три элемента (1, 2, 3). Пусть k = 2.
# Все различные сочетания из 3 элементов по 2: (1, 2), (1, 3), (2, 3).
# Различных сочетаний три, поэтому C(3, 2) = 3.
# Несложно понять, что C(n, 0) = 1, так как из n элементов выбрать 0 можно единственным образом, а именно, ничего не выбрать.
# Также несложно понять, что если k > n, то C(n, k) = 0, так как невозможно, например, из трех элементов выбрать пять.
# Для вычисления C(n, k) в других случаях используется следующая рекуррентная формула:
# C(n, k) = C(n - 1, k) + C(n - 1, k - 1).
# Реализуйте программу, которая для заданных n и k вычисляет C(n, k).
# Вашей программе на вход подается строка, содержащая два целых числа n и k (1 ≤ n ≤ 10, 0 ≤ k ≤ 10).
# Ваша программа должна вывести единственное число: C(n, k).

def combine(n, k):
    if k == 0:
        return 1
    elif k > n:
        return 0
    return combine(n - 1, k) + combine(n - 1, k - 1)

n, k = map(int, input().split())
print(combine(n, k))

# Реализуйте программу, которая будет эмулировать работу с пространствами имен. Необходимо реализовать поддержку создания пространств имен и добавление в них переменных.
# В данной задаче у каждого пространства имен есть уникальный текстовый идентификатор – его имя.
# Вашей программе на вход подаются следующие запросы:
# - create <namespace> <parent> –  создать новое пространство имен с именем <namespace> внутри пространства <parent>
# - add <namespace> <var> – добавить в пространство <namespace> переменную <var>
# - get <namespace> <var> – получить имя пространства, из которого будет взята переменная <var> при запросе из пространства <namespace>, или None, если такого пространства не существует
# 
# Рассмотрим набор запросов
# - add global a
# - create foo global
# - add foo b
# - create bar foo
# - add bar a
# 
# Структура пространств имен описанная данными запросами будет эквивалентна структуре пространств имен, созданной при выполнении данного кода
# a = 0
# def foo():
#   b = 1
#   def bar():
#     a = 2
# 
# В основном теле программы мы объявляем переменную a, тем самым добавляя ее в пространство global. Далее мы объявляем функцию foo, что влечет за собой создание локального 
# для нее пространства имен внутри пространства global. В нашем случае, это описывается командой create foo global. Далее мы объявляем внутри функции foo функцию bar, 
# тем самым создавая пространство bar внутри пространства foo, и добавляем в bar переменную a.
# 
# Добавим запросы get к нашим запросам
# - get foo a
# - get foo c
# - get bar a
# - get bar b
# 
# Представим как это могло бы выглядеть в коде
# a = 0
# def foo():
#   b = 1
#   get(a)
#   get(c)
#   def bar():
#     a = 2
#     get(a)
#     get(b)
# 
# Результатом запроса get будет имя пространства, из которого будет взята нужная переменная.
# Например, результатом запроса get foo a будет global, потому что в пространстве foo не объявлена переменная a, но в пространстве global, внутри которого находится пространство foo, она объявлена. 
# Аналогично, результатом запроса get bar b будет являться foo, а результатом работы get bar a будет являться bar.
# Результатом get foo c будет являться None, потому что ни в пространстве foo, ни в его внешнем пространстве global не была объявлена переменная с.
# 
# Более формально, результатом работы get <namespace> <var> является
# - <namespace>, если в пространстве <namespace> была объявлена переменная <var>
# - get <parent> <var> – результат запроса к пространству, внутри которого было создано пространство <namespace>, если переменная не была объявлена
# - None, если не существует <parent>, т. е. <namespace>﻿ – это global
# 
# Формат входных данных
# В первой строке дано число n (1 ≤ n ≤ 100) – число запросов.
# В каждой из следующих n строк дано по одному запросу.
# Запросы выполняются в порядке, в котором они даны во входных данных.
# Имена пространства имен и имена переменных представляют из себя строки длины не более 10, состоящие из строчных латинских букв.
# 
# Формат выходных данных
# Для каждого запроса get выведите в отдельной строке его результат.

scopes = dict({'global':[None]})

def create(namespace, parent):
    scopes.update({namespace:[parent]})

def add(namespace, var):
    scopes[namespace].append(var)

def get(namespace, var):
    while namespace != None and var not in scopes[namespace][1:]:
        namespace = scopes[namespace][0]
    print(namespace)

operations = {'create': create, 'add': add, 'get': get}
for i in range(int(input())):
    n = input().split()
    operations[n[0]](n[1], n[2])