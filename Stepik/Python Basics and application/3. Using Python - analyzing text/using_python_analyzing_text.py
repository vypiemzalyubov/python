# Вашей программе на вход подаются три строки s, a, b, состоящие из строчных латинских букв.
# За одну операцию вы можете заменить все вхождения строки a в строку s на строку b.
#
# Например, s = "abab", a = "ab", b = "ba", тогда после выполнения одной операции строка s перейдет в строку "baba",
# после выполнения двух и операций – в строку "bbaa", и дальнейшие операции не будут изменять строку s.
#
# Необходимо узнать, после какого минимального количества операций в строке s не останется вхождений строки a. Если операций потребуется более 1000, выведите Impossible.
#
# Выведите одно число – минимальное число операций, после применения которых в строке s не останется вхождений строки a, или Impossible, если операций потребуется более 1000.

s, a, b = [input() for _ in range(3)]
count = 0
while a in s:
    if a in b:
        count = 'Impossible'
        break
    s = s.replace(a, b)
    count += 1
print(count)

# Вашей программе на вход подаются две строки s и t, состоящие из строчных латинских букв.
# Выведите одно число – количество вхождений строки t в строку s.
# 
# Пример:
# s = "abababa"
# t = "aba"
# 
# Вхождения строки t в строку s:
# abababa
# abababa
# abababa

s, t = [input() for _ in range(2)]
print(sum([1 for i in range(len(s)) if s[i:].startswith(t)]))

# Вам дана последовательность строк.
# Выведите строки, содержащие "cat" в качестве подстроки хотя бы два раза.

import re
import sys

for line in sys.stdin:
    line = line.rstrip()
    if re.search(r'((cat).*){2,}', line):
        print(line)

# Вам дана последовательность строк.
# Выведите строки, содержащие "cat" в качестве слова.

import re
import sys

for line in sys.stdin:
    line = line.rstrip()
    if re.search(r'\bcat\b', line):
        print(line)

# Вам дана последовательность строк.
# Выведите строки, содержащие две буквы "z", между которыми ровно три символа.

for line in __import__('sys').stdin:
    line = line.rstrip()
    if __import__('re').search(r'z.{3}z', line):
        print(line)

# Вам дана последовательность строк.
# Выведите строки, содержащие обратный слеш "\".

for line in __import__('sys').stdin:
    line = line.rstrip()
    if __import__('re').search(r'\\', line):
        print(line)

# Вам дана последовательность строк.
# Выведите строки, содержащие слово, состоящее из двух одинаковых частей (тандемный повтор).

for line in __import__('sys').stdin:
    line = line.rstrip()
    if __import__('re').search(r'\b(\w+)\1\b', line):
        print(line)

# Вам дана последовательность строк.
# В каждой строке замените все вхождения подстроки "human" на подстроку "computer"﻿ и выведите полученные строки.

for line in __import__('sys').stdin:
    line = line.rstrip()
    print(__import__('re').sub(r'human', 'computer', line))

# Вам дана последовательность строк.
# В каждой строке замените первое вхождение слова, состоящего только из латинских букв "a" (регистр не важен), на слово "argh".

for line in __import__('sys').stdin:
    print(__import__('re').sub(r'\b[a]+\b', 'argh', line.rstrip(), 1, __import__('re').I))

# Вам дана последовательность строк.
# В каждой строке поменяйте местами две первых буквы в каждом слове, состоящем хотя бы из двух букв.
# Буквой считается символ из группы \w.

for line in __import__('sys').stdin:
    print(__import__('re').sub(r'\b(\w)(\w)(\w*)\b', r'\2\1\3', line.rstrip()))

# Вам дана последовательность строк.
# В каждой строке замените все вхождения нескольких одинаковых букв на одну букву.
# Буквой считается символ из группы \w.

for line in __import__('sys').stdin:
    print(__import__('re').sub(r'(\w)\1+', r'\1', line.rstrip()))

# Рассмотрим два HTML-документа A и B.
# Из A можно перейти в B за один переход, если в A есть ссылка на B, т. е. внутри A есть тег <a href="B">, возможно с дополнительными параметрами внутри тега.
# Из A можно перейти в B за два перехода если существует такой документ C, что из A в C можно перейти за один переход и из C в B можно перейти за один переход.
# 
# Вашей программе на вход подаются две строки, содержащие url двух документов A и B.
# Выведите Yes, если из A в B можно перейти за два перехода, иначе выведите No.
# 
# Обратите внимание на то, что не все ссылки внутри HTML документа могут вести на существующие HTML документы.

a, b = [input() for _ in range(2)]
urls = []
pattern = r'<a.*href="(.*)">'

for url in __import__('re').findall(pattern, __import__('requests').get(a).text):
    urls.extend(__import__('re').findall(pattern, __import__('requests').get(url).text))

urls = list(map(lambda url: url.replace('stepic.org', 'stepik.org'), urls))
print('Yes' if b in urls else 'No')

# Вашей программе на вход подается ссылка на HTML файл.
# Вам необходимо скачать этот файл, затем найти в нем все ссылки вида <a ... href="..." ... > и вывести список сайтов, на которые есть ссылка.
# 
# Сайтом в данной задаче будем называть имя домена вместе с именами поддоменов. То есть, это последовательность символов, которая следует сразу после символов протокола, 
# если он есть, до символов порта или пути, если они есть, за исключением случаев с относительными ссылками вида <a href="../some_path/index.html">.
# 
# Сайты следует выводить в алфавитном порядке.

response = __import__('requests').get(input())
pattern = __import__('re').compile(r'<a.*?href=["|\'](.*?:\/\/)?(\w.*?)([/|:].*)?["|\'].*')

domains = [link[1] for link in pattern.findall(response.text)]
[print(domain) for domain in sorted(set(domains))]